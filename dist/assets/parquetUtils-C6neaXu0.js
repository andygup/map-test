import{$T as e,BT as t,Lx as n,VT as r,Vp as i,bd as a,iw as o,kD as s,kw as c,qT as l}from"./index-BN8X5Ryz.js";import{t as u}from"./locationUtils-DIRJcjU5.js";import{n as d,r as f,t as p}from"./parquet-CCCEcOEs.js";var m=class extends c(o){constructor(e){super(e),this.type=null}};s([t({type:[`wkb`,`location`],nonNullable:!0,readOnly:!0,json:{read:!1,write:{isRequired:!0}}})],m.prototype,`type`,void 0),m=s([r(`esri.layers.support.ParquetGeometryEncodingBase`)],m);var h=class extends m{constructor(e){super(e),this.type=`location`,this.xField=null,this.yField=null}};s([t({type:[`location`]})],h.prototype,`type`,void 0),s([t({type:String,json:{write:{isRequired:!0}}})],h.prototype,`xField`,void 0),s([t({type:String,json:{write:{isRequired:!0}}})],h.prototype,`yField`,void 0),h=s([r(`esri.layers.support.ParquetGeometryEncodingLocation`)],h);var g=class extends m{constructor(e){super(e),this.type=`wkb`,this.field=null}};s([t({type:[`wkb`]})],g.prototype,`type`,void 0),s([t({type:[`counter-clockwise`],json:{write:!0}})],g.prototype,`orientation`,void 0),s([t({type:String,json:{write:{isRequired:!0}}})],g.prototype,`field`,void 0),g=s([r(`esri.layers.support.ParquetGeometryEncodingWkb`)],g);var _=new l({esriGeometryPoint:`point`,esriGeometryPolygon:`polygon`,esriGeometryPolyline:`polyline`,esriGeometryMultipoint:`multipoint`}),v=new Set([`uncompressed`,`snappy`,`gzip`]);function y(e){return _.toJSON(e)}function b(e){return _.fromJSON(e)}async function x(t,r={}){if(t.urls.length<1)throw new e(`parquet:bad-input`,`At least one url must be specified`,t);if(t.geometryType&&t.spatialReference&&t.geometryEncoding&&t.fields)return t;let o=await d(t.urls.getItemAt(0),{getCustomParameters:()=>r.customParameters});for(let t of o.compressionCodecs())if(!v.has(t))throw new e(`parquet:unsupported`,`Compression codec ${t} is unsupported. Must be of type ${Array.from(v).join(`,`)}`);let s=p(o),c={...t,file:o};if(c.fields??=o.fields(!1).map(e=>a.fromJSON({name:e.name,alias:e.name,type:e.type})),c.geometryEncoding!=null){let t=c.geometryEncoding;switch(t.type){case`wkb`:{let n=c.fields.find(e=>e.name===t.field);if(!n)throw new e(`parquet:unsupported`,`Geometry encoding references field ${t.field} which does not exist`);if(n.type!==`blob`)throw new e(`parquet:unsupported`,`Invalid field type for geometry encoding. Found ${n.type} but expected 'blob'`);break}case`location`:for(let n of[t.xField,t.yField])if(n!=null){let t=c.fields.find(e=>e.name===n);if(!t)throw new e(`parquet:unsupported`,`Geometry encoding references field ${n} which does not exist`);if(!i(t))throw new e(`parquet:unsupported`,`Invalid field type for location geometry encoding. Found ${t.type} but expected a numeric`)}}}c.geometryEncoding??=S(s,c.fields);let l=f(o);if(l&&(c.displayOptimization=l),c.geometryEncoding)switch(c.geometryEncoding.type){case`location`:c.spatialReference??=n.WGS84,c.geometryType??=`point`;break;case`wkb`:{if(!s)return c;let e=s.primary_column,t=s.columns[e];if(c.geometryType||=w(t),c.spatialReference||=T(t),c.fields)for(let e of Object.keys(s.columns))c.fields=c.fields.filter(t=>t.name!==e)}}if(c.displayOptimization){let e=c.displayOptimization.index;if(!c.spatialReference&&e.wkid&&(c.spatialReference=new n({wkid:e.wkid})),!c.geometryType)switch(e.type){case`z`:c.geometryType=`point`;break;case`xz`:c.geometryType=e.geometryType}}return c}function S(e,t){if(e!=null){let t=e.primary_column,n=e.columns[t];return new g({field:t,orientation:n.orientation===`counterclockwise`?`counter-clockwise`:null})}let n=t.filter(e=>i(e)).map(e=>e.name),r=u(n);return r.latitudeFieldName&&r.longitudeFieldName?new h({xField:r.longitudeFieldName,yField:r.latitudeFieldName}):null}function C(e){switch(e){case`Point`:return`point`;case`Polygon`:case`MultiPolygon`:return`polygon`;case`LineString`:return`polyline`;case`MultiPoint`:return`multipoint`;default:return null}}function w(t){let{geometry_types:n}=t,r=new Set;for(let e of n){let t=C(e);t&&r.add(t)}if(r.size>1)throw new e(`parquet:unsupported`,`Parquet mixed geometry types are not supported`,{geometryTypes:r});return r.size===1?r.values().next().value:void 0}function T(e){let t=e.crs?.id?.code;return t&&typeof t==`number`?new n({wkid:t}):void 0}export{g as a,b as i,_ as n,h as o,x as r,m as s,y as t};