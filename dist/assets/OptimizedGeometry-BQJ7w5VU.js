import{r as e}from"./memoryEstimations-D_IbKyOk.js";var t=class t{constructor(e=[],t=[],n=!1,r=!1){this.lengths=e??[],this.coords=t??[],this.hasZ=n,this.hasM=r}static fromJSON({lengths:e,coords:n,hasZ:r,hasM:i}){return new t(e,n,r||!1,i||!1)}static fromRect([e,n,r,i]){let a=r-e,o=i-n;return new t([5],[e,n,a,0,0,o,-a,0,0,-o])}get isPoint(){return this.lengths.length===0&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.isPoint?1:this.lengths.reduce((e,t)=>e+t,0)}get usedMemory(){return 64+e(this.lengths,this.coords)}get stride(){return 2+(this.hasZ?1:0)+(this.hasM?1:0)}area(){if(this.isPoint)return 0;let e=0,t=0;for(let n of this.lengths){if(n<3)continue;let{stride:r}=this,i=this.coords[r*t],a=this.coords[r*t+1];for(let o=1;o<n;o+=1){let n=r*(t+o),s=this.coords[n],c=this.coords[n+1];e+=-.5*(s-i)*(c+a),i=s,a=c}t+=n}return e}forEachVertex(e){let t=0;if(this.isPoint)return e(this.coords[0],this.coords[1]);let{stride:n}=this;for(let r of this.lengths){for(let i=0;i<r;i++){let r=n*(t+i);e(this.coords[r],this.coords[r+1])}t+=r}}deltaDecode(){let e=this.clone(),{coords:t,lengths:n}=e,r=0,{stride:i}=this;for(let e of n){for(let n=1;n<e;n++){let e=i*(r+n);t[e]+=t[e-i],t[e+1]+=t[e+1-i]}r+=e}return e}clone(e){if(this.isPoint)return new t([],Array.from(this.coords.slice(0,this.stride)),this.hasZ,this.hasM);let n=Array.from(this.lengths),{stride:r,size:i}=this,a=this.coords.slice(0,i*r);return e?(e.set(a),new t(n,e)):new t(n,Array.from(a),this.hasZ,this.hasM)}justXY(){let{stride:e,size:n}=this;if(e===2)return this;let r=Array(n*e);for(let t=0,n=0;t<r.length;t+=e)r[n++]=this.coords[t],r[n++]=this.coords[t+1];return new t(this.lengths,r,!1,!1)}};export{t};