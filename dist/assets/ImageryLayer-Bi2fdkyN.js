const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/imageryUtils-jsOtpBJ2.js","assets/index-CzMixifc.js","assets/index-CDgdHpAj.css","assets/originUtils-CL6wvYk_.js","assets/datasetUtils-qcMNA5LE.js","assets/utils-WUTqSxls.js","assets/saveUtils-BKglk9b-.js"])))=>i.map(i=>d[i]);
import{$T as e,A as t,AT as n,Ai as r,BS as i,BT as a,DT as o,Dh as s,Di as c,Dv as l,En as u,FT as d,GC as f,Ha as p,Hw as m,Ii as h,Jw as g,Kx as _,L as ee,Li as v,M as te,MT as ne,Ni as re,O as ie,OT as y,Oh as b,PT as ae,Qf as oe,RS as x,SE as S,Zx as se,_ as ce,_u as C,ad as le,ai as ue,ax as de,ba as fe,ca as pe,du as me,eE as he,eS as ge,fS as _e,gC as ve,gD as w,gu as T,gw as E,ha as ye,hu as D,iE as be,j as xe,jT as O,kv as Se,nv as Ce,pa as we,pv as k,px as A,rd as Te,tE as j,uE as Ee,ua as De,ud as Oe,vd as ke,vv as M,wx as N,xa as Ae,y as je,zi as Me}from"./index-CzMixifc.js";import"./memoryEstimations-C3WUBUZI.js";import"./OptimizedGeometry-5fDazGe-.js";import"./OptimizedFeatureSet-D4F9ObY_.js";import"./urlUtils-7tPnOsRB.js";import"./_commonjsHelpers-4rFoZa9I.js";import{n as Ne}from"./imageBitmapUtils-DL-p4JOA.js";import{o as Pe,p as Fe,t as Ie}from"./elevationInfoUtils-BcUBf70F.js";import"./generateRendererUtils-Boi4GqnB.js";import"./pbf-Dny0go3N.js";import"./pbfQueryUtils-Dy8pLZgd.js";import"./queryUtils-ByyjBzze.js";import"./query-BeU-rNp1.js";import{n as Le,r as Re,t as ze}from"./executeForIds-D5xadeH1.js";import{n as Be}from"./executeQueryJSON-BmDY9cVm.js";import{t as Ve}from"./isImageryGraphicOrigin-Qwa2m0c8.js";import{a as He,n as Ue,o as We,p as Ge,r as Ke}from"./multidimensionalUtils-D8kRIpRe.js";import{B as qe,E as Je,H as Ye,L as Xe,M as Ze,N as Qe,O as $e,T as et,U as tt,V as nt,k as rt,t as it,z as at}from"./RasterSymbolizer-CSgBrmNy.js";import{l as ot,t as st}from"./PixelBlock-Cu1E_t0b.js";import{C as ct,o as lt}from"./vectorFieldUtils-BZ6-deEm.js";import{_ as ut,a as dt,c as ft,d as pt,h as mt,i as ht,l as gt,m as _t,n as vt,o as yt,s as bt,t as xt,u as St,v as P,y as F}from"./RasterJobHandlerMixin-CluH4gXo.js";import"./colorUtils-Btp0B-0Y.js";import{a as Ct,c as wt,d as Tt,f as Et,i as Dt,l as Ot,n as kt,o as At,p as jt,r as Mt,s as Nt,t as Pt,u as Ft}from"./rasterFieldUtils-B81vnJaq.js";import"./datasetUtils-qcMNA5LE.js";import"./cimSymbolUtils-Dwr_LmxD.js";import"./utils-BroCumRv.js";import{i as It,n as Lt,r as Rt,t as zt}from"./RasterPresetRendererMixin-B-0Lw7T3.js";import"./dataUtils-CAfnFU_x.js";var Bt,Vt=class extends fe{get[(Bt=Ve,Ae)](){return this.layer}constructor(e){super(),this[Bt]=!0,this.type=`imagery`,this.layer=e}get id(){return this.layer.id}},Ht={StretchFunction:{arguments:{ComputeGamma:{isDataset:!1,isPublic:!1,name:`ComputeGamma`,type:`RasterFunctionVariable`,value:!1},DRA:{isDataset:!1,isPublic:!1,name:`DRA`,type:`RasterFunctionVariable`,value:!1},EstimateStatsHistogram:{isDataset:!1,isPublic:!1,name:`EstimateStatsHistogram`,type:`RasterFunctionVariable`,value:!1},Gamma:{displayName:`Gamma`,isDataset:!1,isPublic:!1,name:`Gamma`,type:`RasterFunctionVariable`},Histograms:{isDataset:!1,isPublic:!1,name:`Histograms`,type:`RasterFunctionVariable`},Max:{isDataset:!1,isPublic:!1,name:`Max`,type:`RasterFunctionVariable`,value:255},MaxPercent:{isDataset:!1,isPublic:!1,name:`MaxPercent`,type:`RasterFunctionVariable`,value:.5},Min:{isDataset:!1,isPublic:!1,name:`Min`,type:`RasterFunctionVariable`,value:0},MinPercent:{isDataset:!1,isPublic:!1,name:`MinPercent`,type:`RasterFunctionVariable`,value:.25},NumberOfStandardDeviations:{isDataset:!1,isPublic:!1,name:`NumberOfStandardDeviation`,type:`RasterFunctionVariable`,value:2},Raster:{isDataset:!0,isPublic:!1,name:`Raster`,type:`RasterFunctionVariable`},SigmoidStrengthLevel:{isDataset:!1,isPublic:!1,name:`SigmoidStrengthLevel`,type:`RasterFunctionVariable`,value:2},Statistics:{isDataset:!1,isPublic:!1,name:`Statistics`,type:`RasterFunctionVariable`},StretchType:{isDataset:!1,isPublic:!1,name:`StretchType`,type:`RasterFunctionVariable`,value:0},type:`StretchFunctionArguments`,UseGamma:{isDataset:!1,isPublic:!1,name:`UseGamma`,type:`RasterFunctionVariable`,value:!1}},description:`Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.`,function:{description:`Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.`,name:`Stretch`,pixelType:`UNKNOWN`,type:`StretchFunction`},functionType:0,name:`Stretch`,thumbnail:``},RemapFunction:{name:`Remap`,description:`Changes pixel values by assigning new values to ranges of pixel values or using an external table.`,function:{type:`RemapFunction`,pixelType:`UNKNOWN`,name:`Remap`,description:`Changes pixel values by assigning new values to ranges of pixel values or using an external table.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},UseTable:{name:`UseTable`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},InputRanges:{name:`InputRanges`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`Input Ranges`},OutputValues:{name:`OutputValues`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`Output Values`},NoDataRanges:{name:`NoDataRanges`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`NoData Ranges`},Table:{name:`Table`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},InputField:{name:`InputField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},OutputField:{name:`OutputField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},InputMaxField:{name:`InputMaxField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},RemapTableType:{name:`RemapTableType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},AllowUnmatched:{name:`AllowUnmatched`,isPublic:!1,isDataset:!1,value:!0,type:`RasterFunctionVariable`},type:`RemapFunctionArguments`},functionType:0,thumbnail:``},ColormapFunction:{name:`Colormap`,description:`Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.`,function:{type:`ColormapFunction`,pixelType:`UNKNOWN`,name:`Colormap`,description:`Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ColorSchemeType:{name:`ColorSchemeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},Colormap:{name:`Colormap`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},ColormapName:{name:`ColormapName`,isPublic:!1,isDataset:!1,value:`Gray`,type:`RasterFunctionVariable`},ColorRamp:{name:`ColorRamp`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},type:`ColormapFunctionArguments`},functionType:0,thumbnail:``},ShadedReliefFunction:{name:`Shaded Relief`,description:`Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.`,function:{type:`ShadedReliefFunction`,pixelType:`UNKNOWN`,name:`Shaded Relief`,description:`Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ColorSchemeType:{name:`ColorSchemeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ColorRamp:{name:`ColorRamp`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},HillshadeType:{name:`HillshadeType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},Colormap:{name:`Colormap`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},Azimuth:{name:`Azimuth`,isPublic:!1,isDataset:!1,value:315,type:`RasterFunctionVariable`},Altitude:{name:`Altitude`,isPublic:!1,isDataset:!1,value:45,type:`RasterFunctionVariable`},SlopeType:{name:`SlopeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ZFactor:{name:`ZFactor`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},PSPower:{name:`PSPower`,isPublic:!1,isDataset:!1,value:.664,type:`RasterFunctionVariable`},PSZFactor:{name:`PSZFactor`,isPublic:!1,isDataset:!1,value:.024,type:`RasterFunctionVariable`},RemoveEdgeEffect:{name:`RemoveEdgeEffect`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},type:`ShadedReliefFunctionArguments`},functionType:0,thumbnail:``},HillshadeFunction:{name:`Hillshade`,description:`Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image`,function:{type:`HillshadeFunction`,pixelType:`UNKNOWN`,name:`Hillshade`,description:`Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image`},arguments:{DEM:{name:`DEM`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},HillshadeType:{name:`HillshadeType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},Azimuth:{name:`Azimuth`,isPublic:!1,isDataset:!1,value:315,type:`RasterFunctionVariable`},Altitude:{name:`Altitude`,isPublic:!1,isDataset:!1,value:45,type:`RasterFunctionVariable`},SlopeType:{name:`SlopeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ZFactor:{name:`ZFactor`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},PSPower:{name:`PSPower`,isPublic:!1,isDataset:!1,value:.664,type:`RasterFunctionVariable`},PSZFactor:{name:`PSZFactor`,isPublic:!1,isDataset:!1,value:.024,type:`RasterFunctionVariable`},RemoveEdgeEffect:{name:`RemoveEdgeEffect`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},type:`HillshadeFunctionArguments`},functionType:0,thumbnail:``},ResampleFunction:{name:`Resample`,description:`Changes the cell size of a raster.`,function:{type:`ResampleFunction`,pixelType:`UNKNOWN`,name:`Resample`,description:`Changes the cell size of a raster.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ResamplingType:{name:`ResamplingType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},InputCellSize:{name:`InputCellsize`,isPublic:!1,isDataset:!1,value:{x:0,y:0},type:`RasterFunctionVariable`},OutputCellSize:{name:`OutputCellsize`,isPublic:!1,isDataset:!1,value:{x:0,y:0},type:`RasterFunctionVariable`},type:`ResampleFunctionArguments`},functionType:0,thumbnail:``}},Ut=new Set([`u1`,`u2`,`u4`,`u8`,`s8`,`u16`,`s16`]),Wt={simple_scalar:`Simple Scalar`,wind_barb:`Wind Barb`,single_arrow:`Single Arrow`,beaufort_kn:`Beaufort Wind (Knots)`,beaufort_m:`Beaufort Wind (MetersPerSecond)`,ocean_current_m:`Ocean Current (MetersPerSecond)`,ocean_current_kn:`Ocean Current (Knots)`},Gt=new Set([`raster-stretch`,`unique-value`,`class-breaks`,`raster-shaded-relief`,`vector-field`,`raster-colormap`]);function Kt(e){return Gt.has(e.type)}function qt(e,t){if(!e||!t)return S(e||t);let n=S(e);if(n.functionDefinition&&t.rasterFunctionDefinition){let e=t.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=void 0),Jt(n.functionDefinition.arguments,t),n.rasterFunctionDefinition=n.functionDefinition.toJSON()}else t.functionName?.toLowerCase()!==`none`&&(Xt(n.functionArguments).Raster=t);return n}function Jt(e,t){for(let n in e)n.toLowerCase()===`raster`&&(e[n].type===`RasterFunctionVariable`?(e[n]=t.rasterFunctionDefinition,e[n].type=`RasterFunctionTemplate`):e[n].type===`RasterFunctionTemplate`&&Jt(e[n].arguments,t))}function I(e){let t=S(Ht[e.functionName+`Function`]),n=e.functionArguments;for(let e in n)e.toLowerCase()===`raster`?(t.arguments[e]=I(n[e]),t.arguments[e].type=`RasterFunctionTemplate`):e.toLowerCase()===`colormap`?(t.arguments[e].value=cn(n[e]),t.arguments.ColorSchemeType.value=0):t.arguments[e].value=n[e];return t}function Yt(e,t){switch(t||={},e.type){case`raster-stretch`:return en(e,t);case`class-breaks`:return tn(e,t);case`unique-value`:return an(e,t);case`raster-colormap`:return sn(e,t);case`vector-field`:return Qt(e,t);case`raster-shaded-relief`:return $t(e,t);case`flow`:throw Error(`Unsupported rendering rule.`)}}function Xt(e){let t=e?.Raster??e?.raster;return t&&t.declaredClass===`esri.layers.support.RasterFunction`?Xt(t.functionArguments):e}var Zt={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function Qt(e,t){let n=new F;n.functionName=`VectorFieldRenderer`;let{dataType:r,bandNames:i}=t,a=r===`vector-uv`,o,s;if(i?.length===2){let e=i.map(e=>e.toLowerCase());o=e.indexOf(`magnitude`),s=e.indexOf(`direction`)}o!==-1&&o!==null||(o=0,s=1);let c=e.rotationType===`arithmetic`?1:2,l=e.flowRepresentation===`flow-from`?0:1,u=e.visualVariables?e.visualVariables.find(e=>e.field===`Magnitude`):new ue;n.functionArguments={magnitudeBandID:o,directionBandID:s,isUVComponents:a,referenceSystem:c,massFlowAngleRepresentation:l,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:`Vector Average`,symbologyName:Wt[e.style.toLowerCase().replace(`-`,`_`)],minimumMagnitude:u.minDataValue,maximumMagnitude:u.maxDataValue,minimumSymbolSize:u.minSize,maximumSymbolSize:u.maxSize};let d=I(n);return t.convertToRFT?F.fromJSON({rasterFunctionDefinition:d}):n}function $t(e,t){let n=t.convertToRFT;if(t.dataType!==`elevation`&&(t.dataType!==`generic`||t.bandCount!==1||t.pixelType!==`s16`&&t.pixelType!==`s32`&&t.pixelType!==`f32`&&t.pixelType!==`f64`))return new F;let r=new F;r.functionName=`Hillshade`;let i=e.hillshadeType===`traditional`?0:1,a=e.scalingType===`none`?1:3,o={HillshadeType:i,SlopeType:a,ZFactor:e.zFactor};return i===0&&(o.Azimuth=e.azimuth,o.Altitude=e.altitude),a===3&&(o.PSPower=e.pixelSizePower,o.PSZFactor=e.pixelSizeFactor),r.functionArguments=o,r.variableName=`Raster`,e.colorRamp&&(r.functionName=`ShadedRelief`,n?o.ColorRamp=Ze(e.colorRamp):o.Colormap=rt(e.colorRamp)),n?new F({rasterFunctionDefinition:I(r)}):r}function en(e,t){let n=t.convertToRFT,r=new F;r.functionName=`Stretch`;let i=Zt[$e.toJSON(e.stretchType)],a=e.customStatistics?.map(e=>[e.min,e.max,e.avg??0,e.stddev??1]),o={StretchType:i,Statistics:a,DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(e.outputMin!=null&&(o.Min=e.outputMin),e.outputMax!=null&&(o.Max=e.outputMax),i===Zt.standardDeviation?(o.NumberOfStandardDeviations=e.numberOfStandardDeviations,r.outputPixelType=`u8`):i===Zt.percentClip?(o.MinPercent=e.minPercent,o.MaxPercent=e.maxPercent,r.outputPixelType=`u8`):i===Zt.minMax?r.outputPixelType=`u8`:i===Zt.sigmoid&&(o.SigmoidStrengthLevel=e.sigmoidStrengthLevel),r.functionArguments=o,r.variableName=`Raster`,e.colorRamp){let i=e.colorRamp,a=new F;if(n)a.functionArguments={ColorRamp:Ze(i)};else{let n=Xe(i,!0);if(n)a.functionArguments={colorRampName:n};else if(!t.convertColorRampToColormap||i.type!==`algorithmic`&&i.type!==`multipart`){let t=e.colorRamp.toJSON();t.type===`algorithmic`?t.algorithm=t.algorithm||`esriCIELabAlgorithm`:t.type===`multipart`&&t.colorRamps?.length&&t.colorRamps.forEach(e=>e.algorithm=e.algorithm||`esriCIELabAlgorithm`),a.functionArguments={colorRamp:t}}else a.functionArguments={Colormap:rt(i)}}return a.variableName=`Raster`,a.functionName=`Colormap`,a.functionArguments.Raster=r,n?new F({rasterFunctionDefinition:I(a)}):a}return n?new F({rasterFunctionDefinition:I(r)}):r}function tn(e,t){let n=[],r=[],i=[],a=[],o=1e-4,{pixelType:s,rasterAttributeTable:c}=t,l=c==null?null:c.features,u=rn(c);if(u&&l&&Array.isArray(l)&&e.classBreakInfos){e.classBreakInfos.forEach((t,n)=>{let r=t.symbol?.color,i;r?.a&&t.minValue!=null&&t.maxValue!=null&&l.forEach(o=>{t.minValue!=null&&t.maxValue!=null&&(i=o.attributes[e.field],(i>=t.minValue&&i<t.maxValue||n===e.classBreakInfos.length-1&&i>=t.minValue)&&a.push([o.attributes[u],r.r,r.g,r.b]))})});let n=s?nn(a,s):a,r=new F;return r.functionName=`Colormap`,r.functionArguments={},r.functionArguments.Colormap=n,r.variableName=`Raster`,t.convertToRFT?new F({rasterFunctionDefinition:I(r)}):r}e.classBreakInfos.forEach((e,t)=>{if(e.minValue==null||e.maxValue==null)return;let s=e.symbol&&e.symbol.color;s?.a?(t===0?n.push(e.minValue,e.maxValue+o):n.push(e.minValue+o,e.maxValue+o),r.push(t),a.push([t,s.r,s.g,s.b])):i.push(e.minValue,e.maxValue)});let d=s?nn(a,s):a,f=new F;f.functionName=`Remap`,f.functionArguments={InputRanges:n,OutputValues:r,NoDataRanges:i},f.variableName=`Raster`;let p=new F;return p.functionName=`Colormap`,p.functionArguments={Colormap:d,Raster:f},t.convertToRFT?new F({rasterFunctionDefinition:I(p)}):p}function nn(e,t){let n=Ut.has(t)?ot(t):null;return n&&e.push([Math.floor(n[0]-1),0,0,0],[Math.ceil(n[1]+1),0,0,0]),e}function rn(e){if(e==null)return;let{fields:t}=e;return t?.find(e=>e?.name&&e.name.toLowerCase()===`value`)?.name}function an(e,t){let n=[],{pixelType:r,rasterAttributeTable:i}=t,a=i==null?null:i.features,o=rn(i),s=e.defaultSymbol?.color?.toRgb(),c=e.uniqueValueInfos;if(c)if(a){if(o){let t=new Map;c.forEach(e=>{let n=e.value,r=on(e);n!=null&&r?.a&&t.set(String(n),r.toRgb())});let r=e.field;r&&a.forEach(({attributes:e})=>{let i=String(e[r]),a=e[o],c=t.get(i);c?n.push([a,...c]):s&&n.push([a,...s])})}}else for(let e=0;e<c.length;e++){let t=c[e],r=on(t),i=+t.value;if(r?.a){if(isNaN(i))return null;n.push([i,r.r,r.g,r.b])}}let l=r?nn(n,r):n,u=new F;return u.functionName=`Colormap`,u.functionArguments={},u.functionArguments.Colormap=l,u.variableName=`Raster`,t.convertToRFT?new F({rasterFunctionDefinition:I(u)}):u}function on(e){return e.symbol?.type===`polygon-3d`?e.symbol.symbolLayers?.find(e=>e.type===`fill`)?.material?.color:e.symbol?.color}function sn(e,t){let n=e.extractColormap();if(!n||n.length===0)return null;let{pixelType:r}=t,i=r?nn(n,r):n,a=new F;return a.functionName=`Colormap`,a.functionArguments={},a.functionArguments.Colormap=i,t.convertToRFT?new F({rasterFunctionDefinition:I(a)}):a}function cn(e){let t=[],n=[];return e.forEach(e=>{t.push(e[0]),n.push(Qe([...e.slice(1),255]))}),{type:`RasterColormap`,values:t,colors:n}}var L=class extends f{constructor(){super(...arguments),this.layer=null,this.requestRawData=!1,this.compression=void 0,this.lercVersion=2}get adjustAspectRatio(){return this.layer.adjustAspectRatio}writeAdjustAspectRatio(e,t,n){this.layer.version<10.3||(t[n]=e)}get bandIds(){return this.layer.bandIds}get compressionQuality(){return this.layer.compressionQuality}writeCompressionQuality(e,t,n){this.format&&this.format.toLowerCase().includes(`jpg`)&&e!=null&&(t[n]=e)}get compressionTolerance(){return this.layer.compressionTolerance}writeCompressionTolerance(e,t,n){this.format===`lerc`&&e!=null&&(t[n]=e)}get format(){return this.requestRawData||this.layer.renderer?.type===`vector-field`?`lerc`:this.layer.format}get interpolation(){return this.layer.interpolation}get noData(){return this.layer.noData}get noDataInterpretation(){return this.layer.noDataInterpretation}get pixelType(){let{layer:e}=this;return e.pixelType===e.serviceRasterInfo.pixelType?void 0:e.pixelType}writeLercVersion(e,t,n){this.format===`lerc`&&this.layer.version>=10.5&&(t[n]=e)}get version(){let e=this.layer;return e.commitProperty(`bandIds`),e.commitProperty(`format`),e.commitProperty(`compressionQuality`),e.commitProperty(`compressionTolerance`),e.commitProperty(`interpolation`),e.commitProperty(`noData`),e.commitProperty(`noDataInterpretation`),e.commitProperty(`mosaicRule`),e.commitProperty(`rasterFunction`),e.commitProperty(`adjustAspectRatio`),e.commitProperty(`pixelFilter`),e.commitProperty(`pixelType`),e.commitProperty(`definitionExpression`),e.commitProperty(`multidimensionalSubset`),(this._get(`version`)||0)+1}set version(e){this._set(`version`,e)}get mosaicRule(){let e=this.layer,t=e.mosaicRule,n=e.definitionExpression;return t?n&&n!==t.where&&(t=t.clone(),t.where=n):n&&(t=new P({where:n})),t}get rasterFunction(){let e=this.layer,{rasterFunction:t}=e,n=e.pixelFilter,r=!e.format||e.format.includes(`jpg`)||e.format.includes(`png`);this.requestRawData||(t=this._addResampleRasterFunction(t));let i=e.multidimensionalSubset?.areaOfInterest;return i&&(t=ln(t,i)),this.requestRawData||!r||n||e.renderer?.type===`vector-field`||(t=this.combineRendererWithRenderingRule(t)),t}combineRendererWithRenderingRule(e){let t=this.layer,{rasterInfo:n,renderer:r}=t;return e||=t.rasterFunction,!r||!Kt(r)?e:qt(Yt(r,{rasterAttributeTable:n.attributeTable,pixelType:n.pixelType,dataType:n.dataType,bandNames:n.bandInfos.map(({name:e})=>e),convertColorRampToColormap:t.version<10.6,convertToRFT:!!e?.rasterFunctionDefinition,bandCount:n.bandCount}),e)}_addResampleRasterFunction(e){if(this.layer.renderer?.type!==`vector-field`||e?.functionName===`Resample`)return e;let t=this.layer.serviceDataType===`esriImageServiceDataTypeVector-UV`?7:10,n=this.layer.serviceRasterInfo.pixelSize,r=new F({functionName:`Resample`,functionArguments:{ResamplingType:t,InputCellSize:n}});return r=e?.rasterFunctionDefinition?new F({rasterFunctionDefinition:I(r)}):r,qt(r,e)}};function ln(e,t){let n=new F({functionName:`Clip`,functionArguments:{ClippingGeometry:t.toJSON(),ClippingType:1}});return qt(n,e)}w([o()],L.prototype,`layer`,void 0),w([o()],L.prototype,`requestRawData`,void 0),w([o({json:{write:!0}})],L.prototype,`adjustAspectRatio`,null),w([n(`adjustAspectRatio`)],L.prototype,`writeAdjustAspectRatio`,null),w([o({json:{write:!0}})],L.prototype,`bandIds`,null),w([o({json:{write:!0}})],L.prototype,`compression`,void 0),w([o({json:{write:!0}})],L.prototype,`compressionQuality`,null),w([n(`compressionQuality`)],L.prototype,`writeCompressionQuality`,null),w([o({json:{write:!0}})],L.prototype,`compressionTolerance`,null),w([n(`compressionTolerance`)],L.prototype,`writeCompressionTolerance`,null),w([o({json:{write:!0}})],L.prototype,`format`,null),w([o({type:String,json:{read:{reader:at.read},write:{writer:at.write}}})],L.prototype,`interpolation`,null),w([o({json:{write:!0}})],L.prototype,`noData`,null),w([o({type:String,json:{read:{reader:qe.read},write:{writer:qe.write}}})],L.prototype,`noDataInterpretation`,null),w([o({type:nt.apiValues,json:{read:nt.read,write:nt.write}})],L.prototype,`pixelType`,null),w([o({json:{write:!0}})],L.prototype,`lercVersion`,void 0),w([n(`lercVersion`)],L.prototype,`writeLercVersion`,null),w([o({type:Number})],L.prototype,`version`,null),w([o({json:{write:!0}})],L.prototype,`mosaicRule`,null),w([o({json:{write:!0,name:`renderingRule`}})],L.prototype,`rasterFunction`,null),L=w([y(`esri.layers.support.ExportImageServiceParameters`)],L);var un=class extends E(f){constructor(e){super(e),this.fromGeometry=null,this.toGeometry=null,this.objectIds=null,this.where=null,this.maxCount=null}};w([o({type:A,json:{read:!0}})],un.prototype,`fromGeometry`,void 0),w([o({type:A,json:{read:!0,write:!0}})],un.prototype,`toGeometry`,void 0),w([o({json:{write:!0}})],un.prototype,`objectIds`,void 0),w([o({type:String,json:{write:!0}})],un.prototype,`where`,void 0),w([o({type:Number,json:{write:!0}})],un.prototype,`maxCount`,void 0),un=w([y(`esri.rest.support.FindImagesParameters`)],un);var dn=e=>{let t=e,n=class extends t{constructor(){super(...arguments),this.make=null,this.model=null,this.focalLength=null,this.pixelSize=null,this.rows=null,this.cols=null}};return w([o({json:{write:!0}})],n.prototype,`make`,void 0),w([o({json:{write:!0}})],n.prototype,`model`,void 0),w([o({json:{write:!0}})],n.prototype,`focalLength`,void 0),w([o({json:{write:!0}})],n.prototype,`pixelSize`,void 0),w([o({json:{write:!0}})],n.prototype,`rows`,void 0),w([o({json:{write:!0}})],n.prototype,`cols`,void 0),n=w([y(`esri.rest.support.CameraInfoMixin`)],n),n},R=class extends dn(f){constructor(){super(...arguments),this.id=null,this.referenceUri=null,this.acquisitionDate=null,this.cameraID=null,this.center=null,this.perspectiveCenter=null,this.orientation=null}writeAcquisitionDate(e,t){t.acquisitionDate=e?.getTime()}};w([o({json:{write:!0}})],R.prototype,`id`,void 0),w([o({json:{name:`uri`,write:!0}})],R.prototype,`referenceUri`,void 0),w([o({type:Date,json:{write:!0}})],R.prototype,`acquisitionDate`,void 0),w([n(`acquisitionDate`)],R.prototype,`writeAcquisitionDate`,null),w([o({json:{write:!0}})],R.prototype,`cameraID`,void 0),w([o({type:A,json:{write:!0}})],R.prototype,`center`,void 0),w([o({type:A,json:{write:!0}})],R.prototype,`perspectiveCenter`,void 0),w([o({json:{write:!0}})],R.prototype,`orientation`,void 0),R=w([y(`esri.rest.support.ImageInspectionInfo`)],R);var fn=R,pn=class extends f{constructor(e){super(e),this.images=null}};w([o({type:[fn],json:{write:!0}})],pn.prototype,`images`,void 0),pn=w([y(`esri.rest.support.FindImagesResult`)],pn);var mn,hn=mn=class extends f{constructor(e){super(e),this.angleNames=null,this.point=null,this.spatialReference=null,this.rasterId=null}clone(){return new mn(S({angleNames:this.angleNames,point:this.point,spatialReference:this.spatialReference,rasterId:this.rasterId}))}};w([o({type:[String],json:{name:`angleName`,write:!0}})],hn.prototype,`angleNames`,void 0),w([o({type:A,json:{write:!0}})],hn.prototype,`point`,void 0),w([o({type:N,json:{write:!0}})],hn.prototype,`spatialReference`,void 0),w([o({type:be,json:{write:!0}})],hn.prototype,`rasterId`,void 0),hn=mn=w([y(`esri.rest.support.ImageAngleParameters`)],hn);var gn=class extends f{constructor(e){super(e),this.north=null,this.up=null,this.spatialReference=null}};w([o({type:Number,json:{write:!0}})],gn.prototype,`north`,void 0),w([o({type:Number,json:{write:!0}})],gn.prototype,`up`,void 0),w([o({type:N,json:{write:!0}})],gn.prototype,`spatialReference`,void 0),gn=w([y(`esri.rest.support.ImageAngleResult`)],gn);var z=new ae({esriMensurationPoint:`point`,esriMensurationCentroid:`centroid`,esriMensurationDistanceAndAngle:`distance-and-angle`,esriMensurationAreaAndPerimeter:`area-and-perimeter`,esriMensurationHeightFromBaseAndTop:`base-and-top`,esriMensurationHeightFromBaseAndTopShadow:`base-and-top-shadow`,esriMensurationHeightFromTopAndTopShadow:`top-and-top-shadow`,esriMensurationPoint3D:`point-3D`,esriMensurationCentroid3D:`centroid-3D`,esriMensurationDistanceAndAngle3D:`distance-and-angle-3D`,esriMensurationAreaAndPerimeter3D:`area-and-perimeter-3D`}),B=class extends f{constructor(e){super(e),this.type=null,this.measureOperation=null,this.mosaicRule=null,this.pixelSize=null,this.raster=void 0}};w([o()],B.prototype,`type`,void 0),w([o({type:z.apiValues,json:{read:z.read,write:z.write}})],B.prototype,`measureOperation`,void 0),w([o({type:P,json:{write:!0}})],B.prototype,`mosaicRule`,void 0),w([o({type:A,json:{write:!0}})],B.prototype,`pixelSize`,void 0),w([o({json:{write:!0}})],B.prototype,`raster`,void 0),B=w([y(`esri.rest.support.BaseImageMeasureParameters`)],B);var _n,V=_n=class extends B{constructor(e){super(e),this.type=`area-perimeter`,this.geometry=null,this.is3D=!1,this.linearUnit=`meters`,this.areaUnit=`square-meters`}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=e.toJSON())}get measureOperation(){return this.is3D?`area-and-perimeter-3D`:`area-and-perimeter`}clone(){return new _n(S({geometry:this.geometry,is3D:this.is3D,linearUnit:this.linearUnit,areaUnit:this.areaUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};w([o({types:k,json:{name:`fromGeometry`,read:!0,write:!0}})],V.prototype,`geometry`,void 0),w([n(`geometry`)],V.prototype,`writeGeometry`,null),w([o({type:z.apiValues,json:{write:z.write}})],V.prototype,`measureOperation`,null),w([o({json:{read:!0}})],V.prototype,`is3D`,void 0),w([o({type:String,json:{read:ge.read,write:ge.write}})],V.prototype,`linearUnit`,void 0),w([o({type:String,json:{read:se.read,write:se.write}})],V.prototype,`areaUnit`,void 0),V=_n=w([y(`esri.rest.support.ImageAreaParameters`)],V);var vn=class extends f{constructor(e){super(e),this.name=null,this.sensorName=null}};w([o({type:String,json:{read:!0,write:!0}})],vn.prototype,`name`,void 0),w([o({type:String,json:{read:!0,write:!0}})],vn.prototype,`sensorName`,void 0),vn=w([y(`esri.rest.support.BaseImageMeasureResult`)],vn);var H=class extends f{constructor(){super(...arguments),this.value=null,this.displayValue=null,this.uncertainty=null}};w([o({type:String})],H.prototype,`unit`,void 0),w([o({type:Number,json:{read:!0,write:!0}})],H.prototype,`value`,void 0),w([o({type:String,json:{read:!0,write:!0}})],H.prototype,`displayValue`,void 0),w([o({type:Number,json:{read:!0,write:!0}})],H.prototype,`uncertainty`,void 0),H=w([y(`esri.rest.support.BaseImageMeasureResultValue`)],H);var yn=class extends H{constructor(){super(...arguments),this.unit=null}};w([o({json:{read:se.read,write:se.write}})],yn.prototype,`unit`,void 0),yn=w([d(`esri.rest.support.ImageMeasureResultAreaValue`)],yn);var bn=class extends H{constructor(){super(...arguments),this.unit=null}};w([o({json:{read:ge.read,write:ge.write}})],bn.prototype,`unit`,void 0),bn=w([y(`esri.rest.support.ImageMeasureResultLengthValue`)],bn);var xn=class extends vn{constructor(e){super(e),this.area=null,this.perimeter=null}};w([o({type:yn,json:{read:!0,write:!0}})],xn.prototype,`area`,void 0),w([o({type:bn,json:{read:!0,write:!0}})],xn.prototype,`perimeter`,void 0),xn=w([y(`esri.rest.support.ImageAreaResult`)],xn);var Sn=class extends E(f){constructor(e){super(e),this.outSpatialReference=null}};w([o({type:N,json:{name:`outSR`,write:!0}})],Sn.prototype,`outSpatialReference`,void 0),Sn=w([y(`esri.rest.support.ImageBoundaryParameters`)],Sn);var Cn=class extends f{constructor(e){super(e),this.area=null,this.geometry=null}readGeometry(e,t){return e==null?null:e.rings?Se.fromJSON(e):de.fromJSON(e)}};w([o({type:Number,json:{write:!0}})],Cn.prototype,`area`,void 0),w([o({types:k,json:{name:`shape`,write:!0}})],Cn.prototype,`geometry`,void 0),w([O(`geometry`)],Cn.prototype,`readGeometry`,null),Cn=w([y(`esri.rest.support.ImageBoundaryResult`)],Cn);var wn,U=wn=class extends B{constructor(e){super(e),this.type=`distance-angle`,this.fromGeometry=null,this.toGeometry=null,this.is3D=!1,this.linearUnit=`meters`,this.angularUnit=`degrees`}writeFromGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=e.toJSON())}get measureOperation(){return this.is3D?`distance-and-angle-3D`:`distance-and-angle`}clone(){return new wn(S({fromGeometry:this.fromGeometry,toGeometry:this.toGeometry,is3D:this.is3D,linearUnit:this.linearUnit,angularUnit:this.angularUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};w([o({type:A,json:{read:!0,write:!0}})],U.prototype,`fromGeometry`,void 0),w([n(`fromGeometry`)],U.prototype,`writeFromGeometry`,null),w([o({type:A,json:{read:!0,write:!0}})],U.prototype,`toGeometry`,void 0),w([o({type:z.apiValues,json:{write:z.write}})],U.prototype,`measureOperation`,null),w([o({json:{read:!0}})],U.prototype,`is3D`,void 0),w([o({type:String,json:{read:ge.read,write:ge.write}})],U.prototype,`linearUnit`,void 0),w([o({type:String,json:{read:_.read,write:_.write}})],U.prototype,`angularUnit`,void 0),U=wn=w([y(`esri.rest.support.ImageDistanceParameters`)],U);var Tn=class extends H{constructor(){super(...arguments),this.unit=null}};w([o({json:{read:_.read,write:_.write}})],Tn.prototype,`unit`,void 0),Tn=w([y(`esri.rest.support.ImageMeasureResultAngleValue`)],Tn);var En=class extends vn{constructor(e){super(e),this.distance=null,this.azimuthAngle=null,this.elevationAngle=null}};w([o({type:bn,json:{read:!0,write:!0}})],En.prototype,`distance`,void 0),w([o({type:Tn,json:{read:!0,write:!0}})],En.prototype,`azimuthAngle`,void 0),w([o({type:Tn,json:{read:!0,write:!0}})],En.prototype,`elevationAngle`,void 0),En=w([y(`esri.rest.support.ImageDistanceResult`)],En);var W=class extends E(f){constructor(e){super(e),this.geometry=null,this.objectIds=null,this.spatialRelationship=`intersects`,this.timeExtent=null,this.where=null}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=JSON.stringify(e.toJSON()))}};w([o({types:k,json:{read:M,write:!0}})],W.prototype,`geometry`,void 0),w([n(`geometry`)],W.prototype,`writeGeometry`,null),w([o({json:{write:!0}})],W.prototype,`objectIds`,void 0),w([ne(le,{ignoreUnknown:!1,name:`spatialRel`})],W.prototype,`spatialRelationship`,void 0),w([o({type:b,json:{name:`time`,write:!0}})],W.prototype,`timeExtent`,void 0),w([o({type:String,json:{write:!0}})],W.prototype,`where`,void 0),W=w([y(`esri.rest.support.ImageGPSInfoParameters`)],W);var Dn=class extends dn(f){constructor(){super(...arguments),this.id=null}};w([o({json:{write:!0}})],Dn.prototype,`id`,void 0),Dn=w([y(`esri.rest.support.CameraInfo`)],Dn);var On=Dn,G=class extends f{constructor(){super(...arguments),this.id=null,this.name=null,this.acquisitionDate=null,this.cameraID=null,this.center=null,this.gps=null,this.orientation=null}writeAcquisitionDate(e,t){t.acquisitionDate=e?.getTime()}};w([o({json:{write:!0}})],G.prototype,`id`,void 0),w([o({json:{write:!0}})],G.prototype,`name`,void 0),w([o({type:Date,json:{write:!0}})],G.prototype,`acquisitionDate`,void 0),w([n(`acquisitionDate`)],G.prototype,`writeAcquisitionDate`,null),w([o({json:{write:!0}})],G.prototype,`cameraID`,void 0),w([o({type:A,json:{write:!0}})],G.prototype,`center`,void 0),w([o({json:{write:!0}})],G.prototype,`gps`,void 0),w([o({json:{write:!0}})],G.prototype,`orientation`,void 0),G=w([y(`esri.rest.support.ImageGPSInfo`)],G);var kn=G,An=class extends f{constructor(e){super(e),this.images=null,this.cameras=null}};w([o({type:[kn],json:{write:!0}})],An.prototype,`images`,void 0),w([o({type:[On],json:{write:!0}})],An.prototype,`cameras`,void 0),An=w([y(`esri.rest.support.ImageGPSInfoResult`)],An);var jn,K=jn=class extends B{constructor(e){super(e),this.type=`height`,this.fromGeometry=null,this.toGeometry=null,this.operationType=`base-and-top`,this.linearUnit=`meters`}writeFromGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=e.toJSON())}get measureOperation(){return this.operationType}clone(){return new jn(S({fromGeometry:this.fromGeometry,toGeometry:this.toGeometry,operationType:this.operationType,linearUnit:this.linearUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};w([o({type:A,json:{read:!0}})],K.prototype,`fromGeometry`,void 0),w([n(`fromGeometry`)],K.prototype,`writeFromGeometry`,null),w([o({type:A,json:{read:!0,write:!0}})],K.prototype,`toGeometry`,void 0),w([o({type:z.apiValues,json:{write:z.write}})],K.prototype,`measureOperation`,null),w([o({json:{read:!0}})],K.prototype,`operationType`,void 0),w([o({type:String,json:{read:ge.read,write:ge.write}})],K.prototype,`linearUnit`,void 0),K=jn=w([y(`esri.rest.support.ImageHeightParameters`)],K);var Mn=class extends vn{constructor(e){super(e),this.height=null}};w([o({type:bn,json:{read:!0,write:!0}})],Mn.prototype,`height`,void 0),Mn=w([y(`esri.rest.support.ImageHeightResult`)],Mn);var Nn,q=Nn=class extends f{constructor(e){super(e),this.geometry=null,this.rasterFunctions=null,this.pixelSize=null,this.returnGeometry=!0,this.returnCatalogItems=!0,this.returnPixelValues=!0,this.maxItemCount=null,this.timeExtent=null,this.raster=void 0,this.viewId=void 0,this.processAsMultidimensional=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=JSON.stringify(e.toJSON()))}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=P.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set(`mosaicRule`,t)}writeMosaicRule(e,t,n){e!=null&&(t[n]=JSON.stringify(e.toJSON()))}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=F.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set(`rasterFunction`,t)}writeRasterFunction(e,t,n){e!=null&&(t[n]=JSON.stringify(e.toJSON())),e.rasterFunctionDefinition&&(t[n]=JSON.stringify(e.rasterFunctionDefinition))}writeRasterFunctions(e,t,n){e!=null&&(t[n]=JSON.stringify(e.map(e=>e.rasterFunctionDefinition||e.toJSON())))}writePixelSize(e,t,n){e!=null&&(t[n]=JSON.stringify(e))}writeTimeExtent(e,t,n){if(e!=null){let r=e.start==null?null:e.start.getTime(),i=e.end==null?null:e.end.getTime();t[n]=r==null?null:i==null?`${r}`:`${r},${i}`}}clone(){return new Nn(S({geometry:this.geometry,mosaicRule:this.mosaicRule,rasterFunction:this.rasterFunction,rasterFunctions:this.rasterFunctions,pixelSize:this.pixelSize,returnGeometry:this.returnGeometry,returnCatalogItems:this.returnCatalogItems,returnPixelValues:this.returnPixelValues,maxItemCount:this.maxItemCount,processAsMultidimensional:this.processAsMultidimensional,raster:this.raster,viewId:this.viewId,timeExtent:this.timeExtent}))}};w([o({types:k,json:{write:!0}})],q.prototype,`geometry`,void 0),w([n(`geometry`)],q.prototype,`writeGeometry`,null),w([o({type:P,json:{write:!0}})],q.prototype,`mosaicRule`,null),w([n(`mosaicRule`)],q.prototype,`writeMosaicRule`,null),w([o({type:F,json:{write:!0,name:`renderingRule`}})],q.prototype,`rasterFunction`,null),w([n(`rasterFunction`)],q.prototype,`writeRasterFunction`,null),w([o({type:[F],json:{write:!0,name:`renderingRules`}})],q.prototype,`rasterFunctions`,void 0),w([n(`rasterFunctions`)],q.prototype,`writeRasterFunctions`,null),w([o({type:A,json:{write:!0}})],q.prototype,`pixelSize`,void 0),w([n(`pixelSize`)],q.prototype,`writePixelSize`,null),w([o({type:Boolean,json:{write:!0}})],q.prototype,`returnGeometry`,void 0),w([o({type:Boolean,json:{write:!0}})],q.prototype,`returnCatalogItems`,void 0),w([o({type:Boolean,json:{write:!0}})],q.prototype,`returnPixelValues`,void 0),w([o({type:Number,json:{write:!0}})],q.prototype,`maxItemCount`,void 0),w([o({type:b,json:{write:{target:`time`}}})],q.prototype,`timeExtent`,void 0),w([n(`timeExtent`)],q.prototype,`writeTimeExtent`,null),w([o({json:{write:!0}})],q.prototype,`raster`,void 0),w([o({json:{write:!0}})],q.prototype,`viewId`,void 0),w([o({type:Boolean,json:{write:!0}})],q.prototype,`processAsMultidimensional`,void 0),q=Nn=w([y(`esri.rest.support.ImageIdentifyParameters`)],q);var J=class extends f{constructor(e){super(e),this.catalogItemVisibilities=null,this.catalogItems=null,this.location=null,this.name=null,this.objectId=null,this.processedValues=null,this.properties=null,this.value=null}};w([o({json:{write:!0}})],J.prototype,`catalogItemVisibilities`,void 0),w([o({type:ye,json:{write:!0}})],J.prototype,`catalogItems`,void 0),w([o({type:A,json:{write:!0}})],J.prototype,`location`,void 0),w([o({json:{write:!0}})],J.prototype,`name`,void 0),w([o({json:{write:!0}})],J.prototype,`objectId`,void 0),w([o({json:{write:!0}})],J.prototype,`processedValues`,void 0),w([o({json:{write:!0}})],J.prototype,`properties`,void 0),w([o({json:{write:!0}})],J.prototype,`value`,void 0),J=w([y(`esri.rest.support.ImageIdentifyResult`)],J);var Pn,Fn=Pn=class extends f{constructor(e){super(e),this.geometries=null,this.rasterId=null}writeGeometry(e,t,n){t.geometries={geometryType:`esriGeometryPoint`,geometries:e.map(e=>e.toJSON())}}clone(){return new Pn({geometries:this.geometries?.map(e=>e.clone())??[],rasterId:this.rasterId})}};w([o({type:[A],json:{write:!0}})],Fn.prototype,`geometries`,void 0),w([n(`geometries`)],Fn.prototype,`writeGeometry`,null),w([o({type:be,json:{write:!0}})],Fn.prototype,`rasterId`,void 0),Fn=Pn=w([y(`esri.rest.support.ImagePixelLocationParameters`)],Fn);var In=class extends f{constructor(e){super(e),this.geometries=null}};w([o({json:{write:!0}})],In.prototype,`geometries`,void 0),In=w([y(`esri.rest.support.ImagePixelLocationResult`)],In);var Ln,Rn=Ln=class extends B{constructor(e){super(e),this.type=`point`,this.geometry=null,this.is3D=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=e.toJSON())}get measureOperation(){let{is3D:e,geometry:t}=this;return t.type===`point`?e?`point-3D`:`point`:e?`centroid-3D`:`centroid`}clone(){return new Ln(S({geometry:this.geometry,is3D:this.is3D,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};w([o({types:k,json:{name:`fromGeometry`,read:M}})],Rn.prototype,`geometry`,void 0),w([n(`geometry`)],Rn.prototype,`writeGeometry`,null),w([o({type:z.apiValues,json:{read:z.read,write:z.write}})],Rn.prototype,`measureOperation`,null),w([o({json:{read:!0}})],Rn.prototype,`is3D`,void 0),Rn=Ln=w([y(`esri.rest.support.ImagePointParameters`)],Rn);var zn=class extends vn{constructor(e){super(e),this.point=null}};w([o({type:A,json:{name:`point.value`,read:!0,write:!0}})],zn.prototype,`point`,void 0),zn=w([y(`esri.rest.support.ImagePointResult`)],zn);var Bn=class extends E(f){constructor(e){super(e),this.geometries=[],this.rasterIds=null,this.outSpatialReference=null}writeGeometries(e,t,n){t.geometries=e?.length?{geometryType:l(e[0]),geometries:e.map(e=>({...e.toJSON(),spatialReference:void 0}))}:null}};w([o({types:[k]})],Bn.prototype,`geometries`,void 0),w([n(`geometries`)],Bn.prototype,`writeGeometries`,null),w([o({type:[be],json:{write:!0}})],Bn.prototype,`rasterIds`,void 0),w([o({type:N,json:{name:`outSR`,write:!0}})],Bn.prototype,`outSpatialReference`,void 0),Bn=w([y(`esri.rest.support.ImageToMapMultirayParameters`)],Bn);var Y=class extends E(f){constructor(e){super(e),this.geometry=null,this.rasterId=null,this.outSpatialReference=null,this.depthOffset=0,this.adjust=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]={...e.toJSON(),spatialReference:void 0})}};w([o({types:k,json:{read:M,write:!0}})],Y.prototype,`geometry`,void 0),w([n(`geometry`)],Y.prototype,`writeGeometry`,null),w([o({json:{write:!0}})],Y.prototype,`rasterId`,void 0),w([o({type:N,json:{name:`outSR`,write:!0}})],Y.prototype,`outSpatialReference`,void 0),w([o({json:{name:`options.DOff`,write:!0}})],Y.prototype,`depthOffset`,void 0),w([o({json:{name:`options.Adjust`,write:!0}})],Y.prototype,`adjust`,void 0),Y=w([y(`esri.rest.support.ImageToMapParameters`)],Y);var Vn=class extends E(f){constructor(e){super(e),this.referenceUri=null,this.rasterId=null}};w([o({type:String,json:{name:`uri`,write:!0}})],Vn.prototype,`referenceUri`,void 0),w([o({type:Number,json:{write:!0}})],Vn.prototype,`rasterId`,void 0),Vn=w([y(`esri.rest.support.ImageUrlParameters`)],Vn);var Hn=class extends f{constructor(e){super(e),this.url=null}};w([o({json:{name:`imageURL`,write:!0}})],Hn.prototype,`url`,void 0),Hn=w([y(`esri.rest.support.ImageUrlResult`)],Hn);var Un=new ae({0:`constant`,1:`plane`,2:`minimum`,3:`maximum`,4:`average`},{useNumericKeys:!0}),X=class extends E(f){constructor(){super(...arguments),this.geometries=[],this.mosaicRule=null,this.pixelSize=null,this.constantZ=null,this.baseType=`plane`}writeGeometries(e,t,n){e?.length&&(t.geometryType=l(e[0]),t.geometries=e.map(e=>e.toJSON()))}};w([o({types:[k]})],X.prototype,`geometries`,void 0),w([n(`geometries`)],X.prototype,`writeGeometries`,null),w([o({type:P,json:{write:!0}})],X.prototype,`mosaicRule`,void 0),w([o({type:A,json:{write:!0}})],X.prototype,`pixelSize`,void 0),w([o({json:{write:!0}})],X.prototype,`constantZ`,void 0),w([o({type:Un.apiValues,json:{read:Un.read,write:Un.write}})],X.prototype,`baseType`,void 0),X=w([y(`esri.rest.support.ImageVolumeParameters`)],X);var Z=class extends f{constructor(){super(...arguments),this.area=null,this.cut=null,this.fill=null,this.maxZ=null,this.minZ=null,this.meanZ=null,this.cutCellCount=null,this.fillCellCount=null}};w([o({json:{write:!0}})],Z.prototype,`area`,void 0),w([o({json:{write:!0}})],Z.prototype,`cut`,void 0),w([o({json:{write:!0}})],Z.prototype,`fill`,void 0),w([o({json:{name:`maxz`,write:!0}})],Z.prototype,`maxZ`,void 0),w([o({json:{name:`minz`,write:!0}})],Z.prototype,`minZ`,void 0),w([o({json:{name:`meanz`,write:!0}})],Z.prototype,`meanZ`,void 0),w([o({json:{write:!0}})],Z.prototype,`cutCellCount`,void 0),w([o({json:{write:!0}})],Z.prototype,`fillCellCount`,void 0),Z=w([y(`esri.rest.support.ImageVolume`)],Z);var Wn=Z,Gn=class extends f{constructor(e){super(e),this.volumes=[]}};w([o({type:[Wn],json:{write:!0}})],Gn.prototype,`volumes`,void 0),Gn=w([y(`esri.rest.support.ImageVolumeResult`)],Gn);var Kn=class extends E(f){constructor(e){super(e),this.geometry=null,this.rasterId=null,this.visibleOnly=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]=JSON.stringify(e))}};w([o({types:k,json:{read:M,write:!0}})],Kn.prototype,`geometry`,void 0),w([n(`geometry`)],Kn.prototype,`writeGeometry`,null),w([o({json:{write:!0}})],Kn.prototype,`rasterId`,void 0),w([o({json:{name:`options.VisibleOnly`,write:!0}})],Kn.prototype,`visibleOnly`,void 0),Kn=w([y(`esri.rest.support.MapToImageParameters`)],Kn);var qn=class extends f{constructor(e){super(e),this.geometry=null,this.length=null,this.area=null,this.center=null}readCenter(e,t){return e.spatialReference||(e={...e,spatialReference:t.Shape.spatialReference}),A.fromJSON(e)}};w([o({types:k,json:{name:`Shape`,read:M,write:!0}})],qn.prototype,`geometry`,void 0),w([o({json:{name:`Length`,write:!0}})],qn.prototype,`length`,void 0),w([o({json:{name:`Area`,write:!0}})],qn.prototype,`area`,void 0),w([o({type:A,json:{name:`Center`,write:!0}})],qn.prototype,`center`,void 0),w([O(`center`)],qn.prototype,`readCenter`,null),qn=w([y(`esri.rest.support.MeasureAreaFromImageResult`)],qn);var Jn,Yn=Jn=class extends f{constructor(e){super(e),this.geometry=null,this.rasterId=void 0}writeGeometry(e,t,n){e!=null&&(t.geometryType=l(e),t[n]={...e.toJSON(),spatialReference:void 0})}clone(){let e=S({geometry:this.geometry,rasterId:this.rasterId});return new Jn(e)}};w([o({types:k,json:{name:`fromGeometry`,read:M,write:!0}})],Yn.prototype,`geometry`,void 0),w([n(`geometry`)],Yn.prototype,`writeGeometry`,null),w([o({json:{write:!0}})],Yn.prototype,`rasterId`,void 0),Yn=Jn=w([y(`esri.rest.support.MeasureFromImageParameters`)],Yn);var Xn=class extends f{constructor(e){super(e),this.geometry=null,this.length=null}};w([o({types:k,json:{name:`Shape`,read:M,write:!0}})],Xn.prototype,`geometry`,void 0),w([o({json:{name:`Length`,write:!0}})],Xn.prototype,`length`,void 0),Xn=w([y(`esri.rest.support.MeasureLengthFromImageResult`)],Xn);function Zn(e){let t=e?.time;if(t&&(t.start!=null||t.end!=null)){let n=[];t.start!=null&&n.push(t.start),t.end==null||n.includes(t.end)||n.push(t.end),e.time=n.join(`,`)}}async function Qn(e,t,n){t=j(dt,t);let r=D(e),i=t.geometry?[t.geometry]:[],a=await me(i),o=t.toJSON();Zn(o);let s=a?.[0];s!=null&&(o.geometry=Q(s));let c=C({...r.query,f:`json`,...o});return T(c,n)}async function $n(e,t,n){let r=(t=j(X,t)).toJSON();r.geometries=JSON.stringify(r.geometries);let i=D(e),a=C({...i.query,f:`json`,...r}),o=T(a,n),{data:s}=await x(`${i.path}/calculateVolume`,o);return Gn.fromJSON({volumes:s.results})}async function er(e,t,n){let r=j(hn,t),i=r.toJSON();i.angleName!=null&&(i.angleName=i.angleName.join(`,`)),r?.point?.spatialReference?.imageCoordinateSystem&&(i.point.spatialReference=mr(r.point.spatialReference)),r?.spatialReference?.imageCoordinateSystem&&(i.spatialReference=hr(r.spatialReference));let a=D(e),o=C({...a.query,f:`json`,...i}),s=T(o,n),{data:c}=await x(`${a.path}/computeAngles`,s);return c.spatialReference=c.spatialReference?c.spatialReference.geodataXform==null?N.fromJSON(c.spatialReference):new N({wkid:0,imageCoordinateSystem:c.spatialReference}):null,c.north===`NaN`&&(c.north=null),c.up===`NaN`&&(c.up=null),new gn(c)}async function tr(e,t,n){let r=(t=j(Fn,t)).toJSON(),{geometries:i}=t;if(i)for(let e=0;e<i.length;e++)i[e].spatialReference?.imageCoordinateSystem&&(r.geometries.geometries[e].spatialReference=mr(i[e].spatialReference));let a=D(e),o=C({...a.query,f:`json`,...r}),s=T(o,n),{data:c}=await x(`${a.path}/computePixelLocation`,s);return In.fromJSON(c)}async function nr(e,t,n){let r=await Qn(e,t,n),i=D(e),{data:a}=await x(`${i.path}/computeStatisticsHistograms`,r),{statistics:o}=a;return o?.length&&o.forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),{statistics:o,histograms:a.histograms}}async function rr(e,t,n){let r=await Qn(e,t,n),i=D(e),{data:a}=await x(`${i.path}/computeHistograms`,r);return{histograms:a.histograms}}async function ir(e,t,n){let r=(t=j(ht,t)).toJSON();Zn(r),r.outFields?.length&&(r.outFields=r.outFields.join(`,`));let i=await me(t.geometry),a=i?.[0];a!=null&&(r.geometry=Q(a));let o=D(e),s=C({...o.query,f:`json`,...r}),c=T(s,n),{data:l}=await x(`${o.path}/getSamples`,c),u=l.samples.map(e=>{let t=e.value===`NaN`||e.value===``?null:e.value.split(` `).map(e=>Number(e));return{...e,pixelValue:t}});return vt.fromJSON({samples:u})}async function ar(e,t,n){t=j(q,t);let r=D(e),i=t.geometry?[t.geometry]:[];return me(i).then(e=>{let i=t.toJSON(),a=e?.[0];a!=null&&(i.geometry=JSON.stringify(Q(a)));let o=C({...r.query,f:`json`,...i}),s=T(o,n);return x(r.path+`/identify`,s)}).then(e=>J.fromJSON(e.data))}async function or(e,t,n){let r=j(K,t),i=await ur(e,r,[r.fromGeometry,r.toGeometry],n);return Mn.fromJSON(i)}async function sr(e,t,n){let r=j(V,t),i=await ur(e,r,[r.geometry],n);return xn.fromJSON(i)}async function cr(e,t,n){let r=j(Rn,t),i=await ur(e,r,[r.geometry],n);return zn.fromJSON(i)}async function lr(e,t,n){let r=j(U,t),i=await ur(e,r,[r.fromGeometry,r.toGeometry],n);return En.fromJSON(i)}async function ur(e,t,n,r){let i=D(e),a=await me(n),o=t.toJSON();a[0]!=null&&(o.fromGeometry=JSON.stringify(Q(a[0]))),a[1]!=null&&(o.toGeometry=JSON.stringify(Q(a[1])));let s=C({...i.query,f:`json`,...o}),c=T(s,r),{data:l}=await x(i.path+`/measure`,c);return l}async function dr(e,t,n){let r=await pr(e,t,n);return Xn.fromJSON(r)}async function fr(e,t,n){let r=await pr(e,t,n);return qn.fromJSON(r)}async function pr(e,t,n){t=j(Yn,t);let r=D(e),i=t.toJSON(),a=C({...r.query,f:`json`,...i}),o=T(a,n),{data:s}=await x(r.path+`/measureFromImage`,o);return s}function Q(e){let t=e.toJSON();return e.spatialReference?.imageCoordinateSystem&&(t.spatialReference=mr(e.spatialReference)),t}function mr(e){let{imageCoordinateSystem:t}=e;if(t){let{id:e,referenceServiceName:n}=t;return e==null?{ics:t}:n?{icsid:e,icsns:n}:{icsid:e}}return e.toJSON()}function hr(e,t){if(!e.imageCoordinateSystem)return _e(e);let n=mr(e),{icsid:r,icsns:i}=n;return r==null||i!=null&&!t?.toLowerCase().includes(`/`+i.toLowerCase()+`/`)?JSON.stringify(n):`0:${r}`}async function gr(e,t,n){t=j(Sn,t);let r=D(e),i=t.toJSON();t.outSpatialReference&&(i.outSR=hr(t.outSpatialReference));let a=C({...r.query,f:`json`,...i}),o=T(a,n),{data:s}=await x(r.path+`/queryBoundary`,o);return Cn.fromJSON(s)}async function _r(e,t,n){let r=(t=j(W,t)).toJSON();Zn(r),r.objectIds?.length&&(r.objectIds=r.objectIds.join(`,`)),r.geometry||r.objectIds||r.time||r.where||(r.where=`1=1`);let i=await me(t.geometry),a=i?.[0];a!=null&&(r.geometry=Q(a));let o=a?.spatialReference??t.geometry?.spatialReference;o&&(r.inSR=hr(o));let s=D(e),c=C({...s.query,f:`json`,...r}),l=T(c,n),{data:u}=await x(`${s.path}/queryGPSInfo`,l);return An.fromJSON(u)}async function vr(e,t,n){let r=(t=j(Y,t)).toJSON();t.geometry.spatialReference.imageCoordinateSystem&&(r.geometry=Q(t.geometry)),t.depthOffset&&t.adjust||delete r.options;let i=D(e),a=C({...i.query,f:`json`,...r}),o=T(a,n),{data:s}=await x(`${i.path}/imageToMap`,o);return M(s)}async function yr(e,t,n){let r=(t=j(Bn,t)).toJSON();t.rasterIds?.length&&(r.rasterIds=t.rasterIds.join(`,`));let i=D(e),a=C({...i.query,f:`json`,...r}),o=T(a,n),{data:s}=await x(`${i.path}/imageToMapMultiray`,o);return M(s)}async function br(e,t,n){let r=(t=j(Kn,t)).toJSON(),i=await me(t.geometry),a=i?.[0];a!=null&&(r.geometry=Q(a)),t.visibleOnly||delete r.options;let o=a?.spatialReference??t.geometry?.spatialReference;o&&(r.inSR=hr(o));let s=D(e),c=C({...s.query,f:`json`,...r}),l=T(c,n),{data:u}=await x(`${s.path}/mapToImage`,l);return M(u)}async function xr(e,t,n){let r=(t=j(Vn,t)).toJSON(),i=D(e),a=C({...i.query,f:`json`,...r}),o=T(a,n),{data:s}=await x(`${i.path}/getImageUrl`,o);return Hn.fromJSON(s)}async function Sr(e,t,n){let r=(t=j(un,t)).toJSON(),i=await me([t.fromGeometry,t.toGeometry]);i[0]!=null&&(r.fromGeometry=Q(i[0]),i[0].spatialReference&&(r.inSR=hr(i[0].spatialReference))),i[1]!=null&&(r.toGeometry=Q(i[1])),t.objectIds?.length&&(r.objectIds=r.objectIds.join(`,`));let a=D(e),o=C({...a.query,f:`json`,...r}),s=T(o,n),{data:c}=await x(`${a.path}/find`,s);return pn.fromJSON(c)}async function Cr(e,t,n){let r=D(e),i=C({...r?.query,f:`json`}),a=T(i,n),o=`${r?.path}/${t}/info`,s=x(`${o}`,a),c=x(`${o}/keyProperties`,a),l=await Promise.allSettled([s,c]),u=l[0].status===`fulfilled`?l[0].value.data:null,d=l[1].status===`fulfilled`?l[1].value.data:null,f=null;u.statistics?.length&&(f=u.statistics.map(e=>({min:e[0],max:e[1],avg:e[2],stddev:e[3]})));let p=de.fromJSON(u.extent),m=Math.ceil(p.width/u.pixelSizeX-.1),h=Math.ceil(p.height/u.pixelSizeY-.1),g=p.spatialReference,_=new A({x:u.pixelSizeX,y:u.pixelSizeY,spatialReference:g}),ee=u.histograms?.length?u.histograms:null,v=new Je({origin:u.origin,blockWidth:u.blockWidth,blockHeight:u.blockHeight,firstPyramidLevel:u.firstPyramidLevel,maximumPyramidLevel:u.maxPyramidLevel});return new et({width:m,height:h,bandCount:u.bandCount,extent:p,spatialReference:g,pixelSize:_,pixelType:u.pixelType.toLowerCase(),statistics:f,histograms:ee,keyProperties:d,storageInfo:v})}var wr=new Set([`png`,`png8`,`png24`,`png32`,`jpg`,`bmp`,`gif`,`jpgpng`,`lerc`,`tiff`]),Tr=he(e,{min:0,max:255});function Er(e){let t=JSON.stringify(e),n=t.includes(`"rasterFunctionDefinition":{`),r=n?t.match(/"type":"(.*?FunctionArguments")/gi):t.match(/"rasterFunction":"(.*?")/gi),i=r?.map(e=>n?e.slice(8,-18):e.slice(18,-1));return i?i.join(`/`):null}var Dr=e=>{let t=e,r=class extends t{constructor(){super(...arguments),this._functionRasterInfos={},this._serviceSupportsMosaicRule=null,this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType=`polygon`,this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set(`exportImageServiceParameters`,new L({layer:this}))}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get _rasterFunctionNamesIndex(){let e=new Map;return!this.rasterFunctionInfos||this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.length<1||this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.forEach(t=>{e.set(t.name.toLowerCase().replaceAll(/ /gi,`_`),t.name)}),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every(e=>typeof e==`number`))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,n){e!=null&&this.format!==`lerc`&&(t[n]=e)}writeCompressionTolerance(e,t,n){this.format===`lerc`&&e!=null&&(t[n]=e)}readDefaultMosaicRule(e,t){return this._serviceSupportsMosaicRule?P.fromJSON(t):null}get fieldsIndex(){return this.fields?new u(this.fields):null}set format(e){e&&wr.has(e.toLowerCase())&&this._set(`format`,e.toLowerCase())}readFormat(e,t){return t.serviceDataType===`esriImageServiceDataTypeVector-UV`||t.serviceDataType===`esriImageServiceDataTypeVector-MagDir`||this.pixelFilter!=null?`lerc`:`jpgpng`}readMinScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}readMaxScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=P.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set(`mosaicRule`,t)}readMosaicRule(e,t){let n=e||t.mosaicRule;return n?P.fromJSON(n):this._isMosaicRuleSupported(t)?P.fromJSON(t):null}writeMosaicRule(e,t,n){let{mosaicRule:r}=this;this._isValidCustomizedMosaicRule(r)&&(t[n]=r.toJSON())}writeNoData(e,t,n){e!=null&&typeof e==`number`&&(t[n]=Tr(e))}readObjectIdField(e,t){return e||=t.fields.find(e=>e.type===`esriFieldTypeOID`||e.type===`oid`)?.name,e}get parsedUrl(){return ve(this.url)}readSourceType(e,t){return this._isMosaicDataset(t)?`mosaic-dataset`:`raster-dataset`}get renderer(){let{activePresetRendererName:e,presetRenderers:t}=this;return e?(t?.find(({name:t})=>t===e))?.renderer.clone():this.internalRenderer}set renderer(e){this.activePresetRendererName=null,this.internalRenderer=e}set internalRenderer(e){this.loaded&&(e=this._configRenderer(e)),this._set(`internalRenderer`,e)}readRenderer(e,t,n){let r=t?.layerDefinition?.drawingInfo?.renderer,i=yt(r,n);return i==null?null:(i.type===`vector-field`&&t.symbolTileSize&&!r.symbolTileSize&&(i.symbolTileSize=t.symbolTileSize),Kt(i)||Ee.getLogger(this).warn(`ArcGISImageService`,`Imagery layer doesn't support given renderer type.`),i)}writeRenderer(e,t,n){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),e.type===`vector-field`&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){let e=this.fields?.map(e=>e.clone())??[];e.push(Tt()),this.sourceType===`mosaic-dataset`&&this.fields?.length&&e.push(Ot()),this.version>=10.4&&this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.some(({name:e})=>e.toLowerCase()===`none`)&&e.push(Ct()),this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.filter(({name:e})=>e.toLowerCase()!==`none`).forEach(({name:t})=>e.push(Nt(t)));let{rasterInfo:t}=this;if(this._isVectorDataSet()){let n=t?.multidimensionalInfo?.variables[0].unit?.trim(),r=At(n),i=Pt();e.push(r,i)}if(t?.multidimensionalInfo&&this.sourceType===`raster-dataset`){let n=Et(t.multidimensionalInfo);e.push(...n)}let n=t?.attributeTable;if(n!=null){let t=jt(n);e.push(...t)}return e}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=F.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set(`rasterFunction`,t)}readRasterFunction(e,t){let n=t.rasterFunctionInfos;return t.renderingRule||n?.length&&n[0].name!==`None`?this._isRFTJson(t.renderingRule)?F.fromJSON({rasterFunctionDefinition:t.renderingRule}):F.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}readSpatialReference(e,t){let n=e||t.extent.spatialReference;return n?N.fromJSON(n):null}writePixelType(e,t,n){this.serviceRasterInfo!=null&&this.pixelType===this.serviceRasterInfo.pixelType||(t[n]=nt.toJSON(e))}readVersion(e,t){let n=t.currentVersion;return n||=t.hasOwnProperty(`fields`)||t.hasOwnProperty(`timeInfo`)?10:9.3,n}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let n=e,{renderer:r,symbolizer:i,pixelFilter:a}=this,{isRawData:o}=e;if(o&&this.format!==`lerc`&&(r??=gt(this.rasterInfo,{bandIds:this.bandIds,variableName:this.rasterFunction?null:this.mosaicRule?.multidimensionalDefinition?.[0].variableName}),i||=(this.symbolizer=new it({rendererJSON:r.toJSON(),rasterInfo:this.rasterInfo}),this.symbolizer)),(o||!this._isPicture())&&r&&i&&!a){await this._updateSymbolizer(i,r);let{bandIds:a}=this;n=await this._symbolize({pixelData:e,bandIds:a,symbolizer:i},t)}return n}async highlightPixels(e,t){let n=e.highlightOptions.map(e=>{let t={...e},n=`bandId`in t?[t.bandId??0]:[t.xBandId,t.yBandId];for(let e=0;e<n.length;e++){let t=n[e];if(t==null)return;let r=this.bandIds?.length?this.bandIds.indexOf(t):t;if(r<0||r>2)return;n[e]=r}return`bandId`in t?t.bandId=n[0]:(t.xBandId=n[0],t.yBandId=n[1]),t}).filter(e=>e!=null);if(n.length===0)return;let r=this._rasterJobHandler;r?await r.highlightPixels({...e,highlightOptions:n},t):ct({...e,highlightOptions:n})}destroy(){this._shutdownJobHandler()}async calculateVolume(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsCalculateVolume)throw new a(`imagery-layer:compute-pixel-space-locations`,`this operation is not supported on the input image service`);return e=S(e),this.mosaicRule&&e.mosaicRule==null&&(e.mosaicRule=this.mosaicRule),$n(this.url,e,this._getRequestOptions(t))}async computeAngles(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeAngles)throw new a(`imagery-layer:compute-angles`,`this operation is not supported on the input image service`);return er(this.url,e,this._getRequestOptions(t))}async computePixelSpaceLocations(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputePixelLocation)throw new a(`imagery-layer:compute-pixel-space-locations`,`this operation is not supported on the input image service`);return tr(this.url,e,this._getRequestOptions(t))}async computeHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeHistograms)throw new a(`imagery-layer:compute-histograms`,`this operation is not supported on the input image service`);return e=S(e),this._applyMosaicAndRenderingRules(e),rr(this.url,e,this._getRequestOptions(t))}async computeStatisticsHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeStatisticsHistograms)throw new a(`imagery-layer:compute-statistics-histograms`,`this operation is not supported on the input image service`);return e=S(e),this._applyMosaicAndRenderingRules(e),nr(this.url,e,this._getRequestOptions(t))}async measureHeight(e,t){let n=await this._fetchCapabilities(t?.signal);if(!(e.operationType===`base-and-top`?n.mensuration.supportsHeightFromBaseAndTop:e.operationType===`base-and-top-shadow`?n.mensuration.supportsHeightFromBaseAndTopShadow:n.mensuration.supportsHeightFromTopAndTopShadow))throw new a(`imagery-layer:measure-height`,`this operation is not supported on the input image service`);return e=S(e),this._applyMosaicRule(e),or(this.url,e,this._getRequestOptions(t))}async measureAreaAndPerimeter(e,t){let n=await this._fetchCapabilities(t?.signal);if(!(n.mensuration.supportsAreaAndPerimeter&&(!e.is3D||n.mensuration.supports3D)))throw new a(`imagery-layer:measure-area-and-perimeter`,`this operation is not supported on the input image service`);return e=S(e),this._applyMosaicRule(e),sr(this.url,e,this._getRequestOptions(t))}async measureDistanceAndAngle(e,t){let n=await this._fetchCapabilities(t?.signal);if(!(n.mensuration.supportsDistanceAndAngle&&(!e.is3D||n.mensuration.supports3D)))throw new a(`imagery-layer:measure-distance-and-angle`,`this operation is not supported on the input image service`);return e=S(e),this._applyMosaicRule(e),lr(this.url,e,this._getRequestOptions(t))}async measurePointOrCentroid(e,t){let n=await this._fetchCapabilities(t?.signal);if(!(n.mensuration.supportsPointOrCentroid&&(!e.is3D||n.mensuration.supports3D)))throw new a(`imagery-layer:measure-point-or-centroid`,`this operation is not supported on the input image service`);return e=S(e),this._applyMosaicRule(e),cr(this.url,e,this._getRequestOptions(t))}async measureLengthFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new a(`imagery-layer:measure-length-from-image`,`this operation is not supported on the input image service`);if(e.geometry.type!==`polyline`)throw new a(`imagery-layer:measure-length-from-image`,`this input geometry must be a polyline`);return dr(this.url,e,this._getRequestOptions(t))}async measureAreaFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new a(`imagery-layer:measure-area-from-image`,`this operation is not supported on the input image service`);if(e.geometry.type!==`polygon`)throw new a(`imagery-layer:measure-area-from-image`,`this input geometry must be a polygon`);return fr(this.url,e,this._getRequestOptions(t))}getField(e){let{fieldsIndex:t}=this;return t?.get(e)}getFieldDomain(e,t){let n=this.getField(e);return n?n.domain:null}async internalFetchImage(e,t,n,r={}){await this._updateCurrentRasterInfo();let{exportImageServiceParameters:a}=this,o=!1;r.requestRawData&&(await this._initJobHandler(),a.requestRawData||this.format===`lerc`||(o=!0,a.requestRawData=!0));let s=this.getExportImageServiceParameters(e,t,n,r.timeExtent);if(o&&(a.requestRawData=!1),s==null){if(r.requestAsImageElement&&this._canRequestImageElement(this.format)){let e=document.createElement(`canvas`);return e.width=t,e.height=n,r.returnImageBitmap?{imageBitmap:await Ne(e,`${i(this.parsedUrl)}/exportImage`,r.signal)}:{imageOrCanvasElement:e}}let{bandIds:a,rasterInfo:o}=this,s=(a?.length||o.bandCount)??0,c=t*n,l=o.pixelType,u=[];for(let e=0;e<s;e++)u.push(st.createEmptyBand(l,c));return{pixelData:{pixelBlock:new st({width:t,height:n,pixels:u,mask:new Uint8Array(c),pixelType:l}),extent:e}}}let c=!!r.requestAsImageElement&&!this.pixelFilter,l=c&&!!r.returnImageBitmap,u={imageServiceParameters:s,imageProps:{extent:e,width:t,height:n,format:this.format},requestAsImageElement:c,returnImageBitmap:l,signal:r.signal};return this._requestArrayBuffer(u)}async fetchPixels(e,t,n,r={}){await this._initJobHandler(),r.applyRendering&&this._updateCurrentRasterInfo();let i=r.applyRendering?void 0:new L({layer:this,requestRawData:!0,interpolation:r.interpolation??`nearest`,bandIds:r.bandIds??[]}),a=this.getExportImageServiceParameters(e,t,n,r.timeExtent,i);if(a==null)return{extent:e,pixelBlock:null};delete a.pixelType,r.bandIds||delete a.bandIds,delete a.compressionQuality;let o={imageServiceParameters:a,imageProps:{extent:e,width:t,height:n,format:this.format},requestAsImageElement:!1,returnImageBitmap:!1,signal:r.signal},{pixelData:s}=await this._requestArrayBuffer(o);return s??{extent:e,pixelBlock:null}}fetchKeyProperties(e){return x(i(this.parsedUrl)+`/keyProperties`,{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then(e=>e.data)}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new a(`#fetchRasterAttributeTable()`,`Failed to get rasterAttributeTable`)):x(i(this.parsedUrl)+`/rasterAttributeTable`,{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then(e=>ye.fromJSON(e.data))}getCatalogItemRasterInfo(e,t){let n={...t,query:this._getQueryParams()};return Cr(i(this.parsedUrl),e,n)}async getCatalogItemICSInfo(e,t){let{data:n}=await x(i(this.parsedUrl)+`/`+e+`/info/ics`,{query:this._getQueryParams(),...t}),r=n?.ics;if(!r)return;let a=null;try{a=(await x(i(this.parsedUrl)+`/`+e+`/info`,{query:this._getQueryParams(),...t})).data.extent}catch{}if(!a?.spatialReference)return{ics:r,icsToPixelTransform:null,icsExtent:null,northDirection:null};let o=this.version>=10.7?x(i(this.parsedUrl)+`/`+e+`/info/icstopixel`,{query:this._getQueryParams(),...t}).then(e=>e.data).catch(()=>({})):{},s=a.spatialReference,c={geometries:JSON.stringify({geometryType:`esriGeometryEnvelope`,geometries:[a]}),inSR:_e(s),outSR:`0:`+e},l=x(i(this.parsedUrl)+`/project`,{query:this._getQueryParams(c),...t}).then(e=>e.data).catch(()=>({})),u=(a.xmin+a.xmax)/2,d=(a.ymax-a.ymin)/6,f=a.ymin+d,p=[];for(let e=0;e<5;e++)p.push({x:u,y:f+d*e});let m={geometries:JSON.stringify({geometryType:`esriGeometryPoint`,geometries:p}),inSR:_e(s),outSR:`0:`+e},h=x(i(this.parsedUrl)+`/project`,{query:this._getQueryParams(m),...t}).then(e=>e.data).catch(()=>({})),g=await Promise.all([o,l,h]),_=g[0].ipxf;if(_==null){let e=r.geodataXform?.xf_0;e?.name?.toLowerCase()===`topup`&&e?.coefficients?.length===6&&(_={affine:{name:`ics [sensor: Frame] to pixel (column, row) transformation`,coefficients:e.coefficients,cellsizeRatio:0,type:`GeometricXform`}})}let ee=de.fromJSON(g[1]?.geometries?.[0]);ee&&(ee.spatialReference=new N({wkid:0,imageCoordinateSystem:r}));let v=g[2].geometries?g[2].geometries.filter(e=>e?.x!=null&&e.y!=null&&e.x!==`NaN`&&e.y!==`NaN`):[],te=v.length;if(te<3)return{ics:r,icsToPixelTransform:_,icsExtent:ee,northDirection:null};let ne=0,re=0,ie=0,y=0;for(let e=0;e<te;e++)ne+=v[e].x,re+=v[e].y,ie+=v[e].x*v[e].x,y+=v[e].x*v[e].y;let b=(te*y-ne*re)/(te*ie-ne*ne),ae=0,oe=v[4].x>v[0].x,S=v[4].y>v[0].y;return b===1/0?ae=S?90:270:b===0?ae=oe?0:180:b>0?ae=oe?180*Math.atan(b)/Math.PI:180*Math.atan(b)/Math.PI+180:b<0&&(ae=S?180+180*Math.atan(b)/Math.PI:360+180*Math.atan(b)/Math.PI),{ics:r,icsToPixelTransform:_,icsExtent:ee,northDirection:ae}}async generateRasterInfo(e,t){e=j(F,e);let n={...t,query:this._getQueryParams()};if(!e||e.functionName?.toLowerCase()===`none`||this._isVectorFieldResampleFunction(e))return this.serviceRasterInfo??Rt(i(this.parsedUrl),this.sourceJSON,n);let r=Er(e);if(!r)throw new a(`imagery-layer:generate-raster-info`,`the rendering rule is not supported`);if(this._functionRasterInfos[r])return this._functionRasterInfos[r];let o=It(i(this.parsedUrl),e,n);this._functionRasterInfos[r]=o;try{return await o}catch(e){throw this._functionRasterInfos[r]=null,e}}getExportImageServiceParameters(e,t,n,r,a){e=e.clone().shiftCentralMeridian();let o=hr(e.spatialReference,i(this.parsedUrl));a??=this.exportImageServiceParameters;let s=a.toJSON(),{bandIds:c,noData:l}=s,{renderingRule:u}=s,d=this.rasterFunction?.rasterFunctionDefinition,f=this.renderer?.type,p=!f||f===`raster-stretch`||f===`raster-colormap`||f===`unique-value`||f===`class-breaks`||f===`raster-shaded-relief`;if(c?.length&&this._hasRasterFunction(this.rasterFunction)&&!d&&p){let e={rasterFunction:`ExtractBand`,rasterFunctionArguments:{BandIds:c}};if(u.rasterFunction===`Stretch`)e.rasterFunctionArguments.Raster=u.rasterFunctionArguments.Raster,u.rasterFunctionArguments.Raster=e;else if(u.rasterFunction===`Colormap`){let t=u.rasterFunctionArguments.Raster;t?.rasterFunction===`Stretch`?(e.rasterFunctionArguments.Raster=t.rasterFunctionArguments.Raster,t.rasterFunctionArguments.Raster=e):(e.rasterFunctionArguments.Raster=t,u.rasterFunctionArguments.Raster=e)}else e.rasterFunctionArguments.Raster=u,u=e;s.bandIds=void 0}else s.bandIds=c?.join(`,`);Array.isArray(l)&&l.length>0&&(s.noData=l.join(`,`));let m=this._processMultidimensionalIntersection(null,r,a.mosaicRule);if(m.isOutSide)return null;s.mosaicRule=m.mosaicRule==null?null:JSON.stringify(m.mosaicRule),r=m.timeExtent,s.renderingRule=this._getRenderingRuleString(F.fromJSON(u));let h={};if(r!=null){let{start:e,end:t}=r.toJSON();e&&t&&e===t?h.time=``+e:e==null&&t==null||(h.time=`${e??`null`},${t??`null`}`)}return{bbox:e.xmin+`,`+e.ymin+`,`+e.xmax+`,`+e.ymax,bboxSR:o,imageSR:o,size:t+`,`+n,...s,...h}}async getSamples(e,t){if(!(await this._fetchCapabilities(t?.signal))?.operations.supportsGetSamples)throw new a(`imagery-layer:get-samples`,`getSamples operation is not supported on the input image service`);e=S(e);let{raster:n}=this;return n&&e.raster==null&&(e.raster=n),ir(this.url,e,this._getRequestOptions(t))}async identify(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsIdentify)throw new a(`imagery-layer:identify`,`identify operation is not supported on the input image service`);e=S(e),this.version<10.91&&e.geometry?.type===`extent`&&(e.geometry=Se.fromExtent(e.geometry));let n=this._processMultidimensionalIntersection(e.geometry,e.timeExtent,e.mosaicRule||this.mosaicRule);if(n.isOutSide)throw new a(`imagery-layer:identify`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);e.timeExtent=n.timeExtent,e.mosaicRule=n.mosaicRule;let{raster:r,rasterFunction:i}=this;return i&&e.rasterFunction==null&&(e.rasterFunction=i),r&&e.raster==null&&(e.raster=r),ar(this.url,e,this._getRequestOptions(t))}async imageToMap(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMap)throw new a(`imagery-layer:image-to-map`,`imageToMap operation is not supported on the input image service`);return vr(i(this.parsedUrl),e,this._getRequestOptions(t))}async imageToMapMultiray(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMapMultiray)throw new a(`imagery-layer:image-to-map-multiray`,`imageToMapMultiray operation is not supported on the input image service`);return yr(i(this.parsedUrl),e,this._getRequestOptions(t))}async mapToImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMapToImage)throw new a(`imagery-layer:map-to-image`,`mapToImage operation is not supported on the input image service`);return br(i(this.parsedUrl),e,this._getRequestOptions(t))}async findImages(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsFindImages)throw new a(`imagery-layer:find-images`,`findImages operation is not supported on the input image service`);return Sr(i(this.parsedUrl),e,this._getRequestOptions(t))}async getImageUrl(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsGetImageUrl)throw new a(`imagery-layer:get-image-url`,`getImageUrl operation is not supported on the input image service`);return xr(i(this.parsedUrl),e,this._getRequestOptions(t))}createQuery(){return new Te({outFields:[`*`],returnGeometry:!0,where:this.definitionExpression||`1=1`})}async queryBoundary(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryBoundary)throw new a(`imagery-layer:query-boundary`,`queryBoundary operation is not supported on the input image service`);return e??={outSpatialReference:this.spatialReference},gr(i(this.parsedUrl),e,this._getRequestOptions(t))}async queryExtent(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Le(this.url,e,t)}async queryRasters(e,t){({query:e,requestOptions:t}=await this._prepareForQuery(e,t));let n=await Be(this.url,e,t),r=this.graphicOrigin;return n.features.forEach(e=>{e.layer=this,e.origin=r}),n}async queryObjectIds(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),ze(this.url,e,t)}async queryGPSInfo(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryGPSInfo)throw new a(`imagery-layer:query-gps-info`,`queryGPSInfo operation is not supported on the input image service`);return e??={where:`1=1`},_r(i(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasterCount(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Re(this.url,e,t)}async queryVisibleRasters(e,t){if(!e)throw new a(`imagery-layer: query-visible-rasters`,`missing query parameter`);await this.load();let{pixelSize:n,returnDomainValues:r,returnTopmostRaster:i,showNoDataRecords:o}=t||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1},s=!1,c=null,l=null,u=wt.servicePixelValue.toLowerCase(),d=this._rasterFunctionNamesIndex;if(e.outFields!=null&&(s=e.outFields.some(e=>!e.toLowerCase().startsWith(u)),this.version>=10.4)){let t=e.outFields.filter(e=>e.toLowerCase().startsWith(u)&&e.length>u.length).map(e=>{let t=e.slice(u.length+1);return[this._updateRenderingRulesFunctionName(t,d),t]});c=t.map(e=>new F({functionName:e[0]})),l=t.map(e=>e[1]);let{rasterFunction:n}=this;c.length===0?n?.functionName?(c.push(n),l.push(n.functionName)):c=null:n?.functionName&&!c.some(e=>e.functionName===n.functionName)&&(c.push(n),l.push(n.functionName))}let f=e.outSpatialReference==null||e.outSpatialReference.equals(this.spatialReference),{multidimensionalSubset:p}=this,m=e.timeExtent||this.timeExtent;if(p){let{isOutside:t,intersection:n}=He(p,{geometry:e.geometry,timeExtent:e.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(t)throw new a(`imagery-layer:query-visible-rasters`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);n?.timeExtent!=null&&(m=n.timeExtent)}let h=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,m),g=e.geometry;this.version<10.91&&g?.type===`extent`&&(g=Se.fromExtent(g));let _=this._getQueryParams({geometry:g,timeExtent:m,mosaicRule:h,rasterFunction:this.version<10.4?this.rasterFunction:null,rasterFunctions:c,pixelSize:n,returnCatalogItems:s,returnGeometry:f,raster:this.raster,maxItemCount:i?1:null});delete _.f;let ee=new q(_);try{await this._generateRasterInfo(this.rasterFunction);let n=await ar(this.url,ee,{signal:t?.signal,query:{...this.customParameters}}),i=e.outFields,a=n.value!=null&&n.value.toLowerCase().includes(`nodata`),c=s&&!f&&n?.catalogItems?.features.length&&(o||!a),u=this.multidimensionalInfo&&this.sourceType===`raster-dataset`?We({rasterInfo:this.rasterInfo,multidimensionalDefinition:h?.multidimensionalDefinition,timeExtent:m,multidimensionalSubset:this.multidimensionalSubset}):null;if(!c)return this._processVisibleRastersResponse(n,{returnDomainValues:r,templateRRFunctionNames:l,showNoDataRecords:o,templateFields:i,effectiveMultidimensionalDefinition:u});let d=this.objectIdField||`ObjectId`,p=n.catalogItems?.features??[],g=p.map(e=>e.attributes?.[d]),_=new Te({objectIds:g,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[d]}),v=await this.queryRasters(_);return v?.features?.length&&v.features.forEach(t=>{p.forEach(n=>{n.attributes[d]===t.attributes[d]&&t.geometry&&(n.geometry=t.geometry.clone(),e.outSpatialReference!=null&&(n.geometry.spatialReference=e.outSpatialReference))})}),this._processVisibleRastersResponse(n,{returnDomainValues:r,templateRRFunctionNames:l,showNoDataRecords:o,templateFields:i,effectiveMultidimensionalDefinition:u})}catch{throw new a(`imagery-layer:query-visible-rasters`,`encountered error when querying visible rasters`)}}async fetchVariableStatisticsHistograms(e,t){let n=x(i(this.parsedUrl)+`/statistics`,{query:this._getQueryParams({variable:e}),signal:t}).then(e=>e.data?.statistics),r=x(i(this.parsedUrl)+`/histograms`,{query:this._getQueryParams({variable:e}),signal:t}).then(e=>e.data?.histograms),a=await Promise.all([n,r]);return a[0]&&a[0].forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),{statistics:a[0]||null,histograms:a[1]||null}}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo.multidimensionalInfo;return Ue(this.multidimensionalSubset,t)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||=this.serviceRasterInfo;let t=this.sourceJSON,n=this.serviceRasterInfo==null?Rt(i(this.parsedUrl),t,{signal:e,query:this._getQueryParams()}).then(e=>(this._set(`serviceRasterInfo`,e),this._set(`multidimensionalInfo`,e.multidimensionalInfo),Lt(e,t),e)):Promise.resolve(this.serviceRasterInfo),r=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:e}):null,a=this._getRasterFunctionInfos();return Promise.all([n,r,a]).then(e=>{e[1]?this._set(`rasterInfo`,e[1]):this._set(`rasterInfo`,e[0]),e[2]&&this._set(`rasterFunctionInfos`,e[2]),this.internalRenderer&&!this._isSupportedRenderer(this.internalRenderer)&&(this._set(`internalRenderer`,null),Ee.getLogger(this).warn(`ArcGISImageService`,`Switching to the default renderer. Renderer applied is not valid for this Imagery Layer`)),this._set(`internalRenderer`,this._configRenderer(this.renderer)),this.addHandles([Ce(()=>this.rasterFunction,e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then(e=>{e&&(this.rasterInfo=e)})})]);let{serviceRasterInfo:t}=this;t.multidimensionalInfo!=null&&this._updateMultidimensionalDefinition(t)})}_combineMosaicRuleWithTimeExtent(e,t){let n=this.timeInfo,{multidimensionalInfo:r}=this.serviceRasterInfo;if(e==null||r==null||t==null||n?.startField==null)return e;let{startField:i}=n,a=r.variables.some(e=>e.dimensions.some(e=>e.name===i))?i:`StdTime`;if(e=e.clone(),this.sourceType===`mosaic-dataset`)return e.multidimensionalDefinition=e.multidimensionalDefinition?.filter(e=>e.dimensionName!==a),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];let o=e.multidimensionalDefinition.filter(e=>e.dimensionName===a),s=t.start==null?null:t.start.getTime(),c=t.end==null?null:t.end.getTime(),l=s==null||c==null||s===c,u=l?[s||c]:[[s,c]],d=this.version>=10.8;if(o.length)o.forEach(e=>{e.dimensionName===a&&(d?(e.dimensionName=null,e.isSlice=!1,e.values=[]):(e.isSlice=l,e.values=u))});else if(!d){let t=e.multidimensionalDefinition.filter(e=>e.variableName!=null&&e.dimensionName==null);t.length?t.forEach(e=>{e.dimensionName=a,e.isSlice=l,e.values=u}):e.multidimensionalDefinition.push(new Ge({variableName:``,dimensionName:a,isSlice:l,values:u}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return e==null?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter(e=>!(!e.variableName&&!e.dimensionName)),e.multidimensionalDefinition.length===0&&(e.multidimensionalDefinition=null)),this.sourceType!==`mosaic-dataset`&&e.multidimensionalDefinition==null?null:e)}async _prepareForQuery(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQuery)throw new a(`imagery-layer:query-rasters`,`query operation is not supported on the input image service`);let n=e==null?this.createQuery():j(Te,e);return t=this._getRequestOptions(t),this.raster&&(t.query={...t.query,raster:this.raster}),{query:n,requestOptions:t}}_isSupportedRenderer(e){let{rasterInfo:t,rasterFunction:n}=this;return e.type===`unique-value`&&this._hasRasterFunction(n)&&t?.bandCount===1&&[`u8`,`s8`].includes(t.pixelType)||t!=null&&e!=null&&pt(t).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){let t=this.sourceJSON;if(!t){let{data:n,ssl:r}=await x(i(this.parsedUrl),{query:this._getQueryParams(),signal:e});t=n,this.sourceJSON=t,r&&(this.url=this.url.replace(/^http:/i,`https:`))}if(t.capabilities?.toLowerCase().split(`,`).map(e=>e.trim()).indexOf(`tilesonly`)>-1)throw new a(`imagery-layer:fetch-service-info`,`use ImageryTileLayer to open tiles-only image services`);this.read(t,{origin:`service`,url:this.parsedUrl})}_isMosaicDataset(e){return e.serviceSourceType?e.serviceSourceType===`esriImageServiceSourceTypeMosaicDataset`:e.fields?.length>0}_isMosaicRuleSupported(e){if(!e)return!1;let t=this._isMosaicDataset(e),n=e.currentVersion>=10.71&&e.hasMultidimensions&&!(e.fields?.length>1);return t||n}_isVectorFieldResampleFunction(e){if(e==null)return!1;let{functionName:t,functionArguments:n}=e,r=t?.toLowerCase()===`resample`,i=n?.ResampleType||n?.resampleType;return r&&(i===7||i===10)}_isPicture(){return!this.format||this.format.includes(`jpg`)||this.format.includes(`png`)}_configRenderer(e){let t=this._isPicture(),{rasterInfo:n}=this;if(!t&&!this.pixelFilter||this._isVectorDataSet()){let t=this.mosaicRule?.multidimensionalDefinition?.[0].variableName,r=mt({variableName:t,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>=3){let e=r?.bandIds??St(n);!e||n.bandCount===3&&e[0]===0&&e[1]===1&&e[2]===2||(this.bandIds=e)}e||=r?.renderer??gt(n,{bandIds:this.bandIds,variableName:this.rasterFunction?null:t});let i=_t(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=i,this.symbolizer.rasterInfo=n):this.symbolizer=new it({rendererJSON:i,rasterInfo:n}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return e==null?e:{extent:e.extent&&e.extent.clone(),pixelBlock:e.pixelBlock==null?null:e.pixelBlock.clone()}}_getQueryParams(e){e?.renderingRule!=null&&typeof e.renderingRule!=`string`&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));let{raster:t,viewId:n}=this;return{raster:t,viewId:n,f:`json`,...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e?.query,...this.customParameters}}}_decodePixelBlock(e,t,n){return this._rasterJobHandler?this._rasterJobHandler.decode({data:e,options:t}):tt(e,t,n)}async _getRasterFunctionInfos(e){let t=this.sourceJSON.rasterFunctionInfos;return this.loaded?t:t&&this.version>=10.3?t.length===1&&t[0].name.toLowerCase()===`none`?t:(await x(i(this.parsedUrl)+`/rasterFunctionInfos`,{query:this._getQueryParams(),signal:e})).data?.rasterFunctionInfos:null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes(`png`))}async _requestArrayBuffer(e){let{imageProps:t,requestAsImageElement:n,returnImageBitmap:r,signal:o}=e;if(n&&this._canRequestImageElement(t.format)){let n=`${i(this.parsedUrl)}/exportImage`,{data:a}=await x(n,{responseType:r?`blob`:`image`,query:this._getQueryParams({f:`image`,...this.refreshParameters,...e.imageServiceParameters}),signal:o});return a instanceof Blob?{imageBitmap:await Ne(a,n,o),params:t}:{imageOrCanvasElement:a,params:t}}let s=this._initJobHandler(),c=x(i(this.parsedUrl)+`/exportImage`,{responseType:`array-buffer`,query:this._getQueryParams({f:`image`,...e.imageServiceParameters}),signal:o}),l=(await Promise.all([c,s]))[0].data,u=t.format||`jpgpng`,d=u;if(d!==`bsq`&&d!==`bip`&&(d=Ye(l)),!d)throw new a(`imagery-layer:fetch-image`,`unsupported format signature `+String.fromCharCode.apply(null,new Uint8Array(l)));let f={signal:o};return{pixelData:{pixelBlock:await(u===`gif`||u===`bmp`||u.includes(`png`)&&(d===`png`||d===`jpg`)?tt(l,{useCanvas:!0,...t},f):this._decodePixelBlock(l,{width:t.width,height:t.height,planes:null,pixelType:null,noDataValue:null,format:u},f)),extent:t.extent},params:t}}_generateRasterInfo(e,t){return this.generateRasterInfo(e,t).catch(()=>null)}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;let t=Ke(e,{multidimensionalSubset:this.multidimensionalSubset});if(t!=null&&t.length>0){this.mosaicRule=this.mosaicRule||new P;let e=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&this.rasterFunction.functionName?.toLowerCase()!==`none`&&t.forEach(e=>e.variableName=``),t=t.filter(({variableName:e,dimensionName:t})=>e&&e!==`*`||t),!e?.length&&t.length&&(this.mosaicRule.multidimensionalDefinition=t)}}_processVisibleRastersResponse(e,t){t||={};let n=e.value,{templateRRFunctionNames:r,showNoDataRecords:i,returnDomainValues:a,templateFields:o}=t,s=e.processedValues,c=e.catalogItems?.features,l=e.properties?.Values?.map(e=>e.replaceAll(/ /gi,`, `))||[],u=this.objectIdField||`ObjectId`,d=typeof n==`string`&&n.toLowerCase().includes(`nodata`),f=[];if(n&&!c&&(!d||i)){let e={};e[u]=0,l=[n],c=[new ke({geometry:this.fullExtent,attributes:e})],this.multidimensionalInfo&&this.sourceType===`raster-dataset`&&kt(this.rasterFields,e,t.effectiveMultidimensionalDefinition)}if(!c)return[];this._updateResponseFieldNames(c,o),d&&!i&&(c=[]);let{itemPixelValue:p,servicePixelValue:m}=wt,h=this.rasterFields.some(e=>e.name===p),g=this.graphicOrigin;for(let e=0;e<c.length;e++){let t=c[e];if(n!=null){let a=l[e],o=this.rasterFunction&&s&&s.length>0&&r&&r.length>0&&r.includes(this.rasterFunction.functionName)?s[r.indexOf(this.rasterFunction.functionName)]:n;if(a.toLowerCase()===`nodata`&&!i)continue;h&&(t.attributes[p]=a),t.attributes[m]=o,this._updateFeatureWithMagDirValues(t,a);let c=this.fields&&this.fields.length>0,u=this.rasterFunction&&this.serviceRasterInfo.attributeTable!=null?c?a:n:o;this.rasterFunction||(u=c?a:n),this._updateFeatureWithRasterAttributeTableValues(t,u)}if(t.sourceLayer=t.layer=this,t.origin=g,a&&this._updateFeatureWithDomainValues(t),r&&s&&r.length===s.length)for(let e=0;e<r.length;e++){let n=`${wt.servicePixelValue}.${r[e]}`;t.attributes[n]=s[e]}f.push(c[e])}return f}_processMultidimensionalIntersection(e,t,n){let{multidimensionalSubset:r}=this;if(!r)return{isOutSide:!1,timeExtent:t,mosaicRule:n=this._combineMosaicRuleWithTimeExtent(n,t)};if(r){let{isOutside:n,intersection:i}=He(r,{geometry:e,timeExtent:t});if(n)return{isOutSide:!0,timeExtent:null,mosaicRule:null};i?.timeExtent!=null&&(t=i.timeExtent)}if(n=this._combineMosaicRuleWithTimeExtent(n,t),n?.multidimensionalDefinition){let{isOutside:e}=He(r,{multidimensionalDefinition:n.multidimensionalDefinition});if(e)return{isOutSide:!0,timeExtent:null,mosaicRule:null}}return{isOutSide:!1,timeExtent:t,mosaicRule:n}}_updateFeatureWithRasterAttributeTableValues(e,t){let n=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(n==null)return;let{features:r,fields:i}=n,a=i.map(e=>e.name).find(e=>e.toLowerCase()===`value`);if(!a)return;let o=r.filter(e=>e.attributes[a]===(t==null?null:parseInt(t,10)));o&&o[0]&&i.forEach(t=>{let n=`Raster.`+t.name;e.attributes[n]=o[0].attributes[t.name]})}_updateFeatureWithMagDirValues(e,t){if(!this._isVectorDataSet())return;let n=t.split(/,\s*/).map(e=>parseFloat(e)),r=n.map(e=>[e]),i=n.map(e=>({minValue:e,maxValue:e,noDataValue:null})),a=new st({height:1,width:1,pixelType:`f32`,pixels:r,statistics:i});this.pixelFilter!=null&&this.pixelFilter({pixelBlock:a,extent:new de(0,0,0,0,this.spatialReference)});let o=this.serviceDataType===`esriImageServiceDataTypeVector-MagDir`?[a.pixels[0][0],a.pixels[1][0]]:lt([a.pixels[0][0],a.pixels[1][0]]);e.attributes[wt.magnitude]=o[0],e.attributes[wt.direction]=o[1]}_updateFeatureWithDomainValues(e){(this.fields&&this.fields.filter(e=>e.domain?.type===`coded-value`))?.forEach(t=>{let n=e.attributes[t.name];if(n!=null){let r=t.domain.codedValues.find(e=>e.code===n);r&&(e.attributes[t.name]=r.name)}})}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;let n=this.fieldsIndex;n!=null&&e.forEach(e=>{if(e?.attributes)for(let r of t){let t=n.get(r)?.name;t&&t!==r&&(e.attributes[r]=e.attributes[t],delete e.attributes[t])}})}_getRenderingRuleString(e){if(e){let t=e.toJSON();return t=t.rasterFunctionDefinition??t,(t.thumbnail||t.thumbnailEx)&&(t.thumbnail=t.thumbnailEx=null),JSON.stringify(t)}return null}_hasRasterFunction(e){return e?.functionName!=null&&e.functionName.toLowerCase()!==`none`}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if(e===`Raw`)return e.replace(`Raw`,`None`);let n=e.toLowerCase().replaceAll(/ /gi,`_`);return t.has(n)?t.get(n):e}_isRFTJson(e){return e?.name&&e.arguments&&e.function&&e.hasOwnProperty(`functionType`)}_isVectorDataSet(){return this.serviceDataType===`esriImageServiceDataTypeVector-UV`||this.serviceDataType===`esriImageServiceDataTypeVector-MagDir`}_applyMosaicAndRenderingRules(e){let{raster:t,mosaicRule:n,rasterFunction:r}=this;r&&e.rasterFunction==null&&(e.rasterFunction=r),n&&e.mosaicRule==null&&(e.mosaicRule=n),t&&e.raster==null&&(e.raster=t)}async _updateCurrentRasterInfo(e){if(this.renderer||this.symbolizer){let t=await this._generateRasterInfo(this.rasterFunction,{signal:e});t&&(this.rasterInfo=t)}}_applyMosaicRule(e){let{raster:t,mosaicRule:n}=this;n&&e.mosaicRule==null&&(e.mosaicRule=n),t&&e.raster==null&&(e.raster=t)}_readCapabilities(e){let t=e.capabilities?e.capabilities.toLowerCase().split(`,`).map(e=>e.trim()):[`image`,`catalog`],{currentVersion:n,maxRecordCount:r}=e,i=t.includes(`image`),a=e.serviceDataType===`esriImageServiceDataTypeElevation`,o=!(!e.spatialReference&&!e.extent?.spatialReference),s=t.includes(`edit`),c=t.includes(`mensuration`)&&o,l=e.mensurationCapabilities==null?[]:e.mensurationCapabilities.toLowerCase().split(`,`).map(e=>e.trim()),u=c&&l.includes(`basic`),d=this._isMosaicDataset(e)&&t.includes(`catalog`),f=t.includes(`download`),p=n>=10.7&&a||n>=11.4&&(a||c&&l.includes(`3d`)),m=d&&e.fields&&e.fields.length>0,h=m&&e.supportsAdvancedQueries?e.advancedQueryCapabilities:void 0;return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:i,supportsExportImage:i,supportsIdentify:i,supportsImageToMap:n>=11.2&&d,supportsImageToMapMultiray:n>=11.2&&d,supportsMapToImage:n>=11.2&&d,supportsFindImages:n>=11.2&&d,supportsGetImageUrl:n>=11.3&&f,supportsMeasure:c,supportsMeasureFromImage:n>=11.2,supportsDownload:f,supportsQuery:m,supportsGetSamples:n>=10.2&&i,supportsProject:n>=10.3&&i,supportsComputeStatisticsHistograms:n>=10.4&&i,supportsQueryBoundary:n>=10.6&&i,supportsCalculateVolume:p,supportsComputePixelLocation:n>=10.7&&d,supportsComputeAngles:n>=10.91,supportsQueryGPSInfo:n>=11.2&&d,supportsAdd:s,supportsDelete:s,supportsEditing:s,supportsUpdate:s,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryBins:!1,supportsQueryPivot:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:r,maxRecordCountFactor:void 0,maxUniqueIDCount:void 0,supportsStatistics:!!h?.supportsStatistics,supportsOrderBy:!!h?.supportsOrderBy,supportsDistinct:!!h?.supportsDistinct,supportsPagination:!!h?.supportsPagination,supportsPaginationOnAggregatedQueries:!!h?.supportsPaginationOnAggregatedQueries,supportsStandardizedQueriesOnly:!!h?.useStandardizedQueries,supportsPercentileStatistics:!!h?.supportsPercentileStatistics,supportsCentroid:!!h?.supportsReturningGeometryCentroid,supportsCentroidOnDegeneratedQuantizedGeometry:!1,supportsCurrentUser:!1,supportsDegeneratedQuantizedGeometry:!1,supportsDistance:!!h?.supportsQueryWithDistance,supportsExtent:!!h?.supportsReturningQueryExtent,supportsGeometryProperties:!!h?.supportsReturningGeometryProperties,supportsHavingClause:!!h?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsReturnMesh:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:h?.supportsSqlExpression??!!h,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!h?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0,supportsTrueCurve:!1},mensuration:{supportsDistanceAndAngle:u,supportsAreaAndPerimeter:u,supportsPointOrCentroid:u,supportsHeightFromBaseAndTop:c&&l.includes(`base-top height`),supportsHeightFromBaseAndTopShadow:c&&l.includes(`base-top shadow height`),supportsHeightFromTopAndTopShadow:c&&l.includes(`top-top shadow height`),supports3D:c&&l.includes(`3d`)}}}};function i(e){return e?.path??``}return w([o({clonable:!1})],r.prototype,`_functionRasterInfos`,void 0),w([o({readOnly:!0})],r.prototype,`_serviceSupportsMosaicRule`,void 0),w([O(`_serviceSupportsMosaicRule`,[`currentVersion`,`fields`])],r.prototype,`readServiceSupportsMosaicRule`,null),w([o({readOnly:!0})],r.prototype,`_rasterFunctionNamesIndex`,null),w([o()],r.prototype,`adjustAspectRatio`,void 0),w([o({type:[be],json:{write:!0}})],r.prototype,`bandIds`,void 0),w([O(`bandIds`)],r.prototype,`readBandIds`,null),w([o({readOnly:!0,json:{read:!1}})],r.prototype,`capabilities`,void 0),w([O(`service`,`capabilities`,[`capabilities`,`currentVersion`,`serviceDataType`])],r.prototype,`readCapabilities`,null),w([o({type:Number})],r.prototype,`compressionQuality`,void 0),w([n(`compressionQuality`)],r.prototype,`writeCompressionQuality`,null),w([o({type:Number})],r.prototype,`compressionTolerance`,void 0),w([n(`compressionTolerance`)],r.prototype,`writeCompressionTolerance`,null),w([o({json:{read:{source:`copyrightText`}}})],r.prototype,`copyright`,void 0),w([o({readOnly:!0,dependsOn:[`_serviceSupportsMosaicRule`]})],r.prototype,`defaultMosaicRule`,void 0),w([O(`defaultMosaicRule`,[`defaultMosaicMethod`])],r.prototype,`readDefaultMosaicRule`,null),w([o({type:String,json:{name:`layerDefinition.definitionExpression`,write:{enabled:!0,allowNull:!0}}})],r.prototype,`definitionExpression`,void 0),w([o({readOnly:!0,constructOnly:!0})],r.prototype,`exportImageServiceParameters`,void 0),w([o()],r.prototype,`rasterInfo`,void 0),w([o({readOnly:!0,type:[Oe]})],r.prototype,`fields`,void 0),w([o({readOnly:!0})],r.prototype,`fieldsIndex`,null),w([o({type:[`png`,`png8`,`png24`,`png32`,`jpg`,`bmp`,`gif`,`jpgpng`,`lerc`,`tiff`,`bip`,`bsq`],json:{write:!0}})],r.prototype,`format`,null),w([O(`service`,`format`,[`serviceDataType`])],r.prototype,`readFormat`,null),w([o({type:de})],r.prototype,`fullExtent`,void 0),w([o({readOnly:!0})],r.prototype,`hasMultidimensions`,void 0),w([o({json:{read:{source:`maxImageHeight`}}})],r.prototype,`imageMaxHeight`,void 0),w([o({json:{read:{source:`maxImageWidth`}}})],r.prototype,`imageMaxWidth`,void 0),w([o({type:String,json:{type:at.jsonValues,read:at.read,write:at.write}})],r.prototype,`interpolation`,void 0),w([o()],r.prototype,`minScale`,void 0),w([O(`service`,`minScale`)],r.prototype,`readMinScale`,null),w([o()],r.prototype,`maxScale`,void 0),w([O(`service`,`maxScale`)],r.prototype,`readMaxScale`,null),w([o({type:P})],r.prototype,`mosaicRule`,null),w([O(`mosaicRule`,[`mosaicRule`,`defaultMosaicMethod`])],r.prototype,`readMosaicRule`,null),w([n(`mosaicRule`)],r.prototype,`writeMosaicRule`,null),w([o()],r.prototype,`multidimensionalInfo`,void 0),w([o({type:ut,json:{write:!0}})],r.prototype,`multidimensionalSubset`,void 0),w([o({json:{type:be}})],r.prototype,`noData`,void 0),w([n(`noData`)],r.prototype,`writeNoData`,null),w([o({type:String,json:{type:qe.jsonValues,read:qe.read,write:qe.write}})],r.prototype,`noDataInterpretation`,void 0),w([o({type:String,readOnly:!0,json:{read:{source:[`fields`]}}})],r.prototype,`objectIdField`,void 0),w([O(`objectIdField`)],r.prototype,`readObjectIdField`,null),w([o({readOnly:!0})],r.prototype,`geometryType`,void 0),w([o({})],r.prototype,`typeIdField`,void 0),w([o({})],r.prototype,`types`,void 0),w([o({readOnly:!0})],r.prototype,`parsedUrl`,null),w([o({type:Function})],r.prototype,`pixelFilter`,void 0),w([o()],r.prototype,`raster`,void 0),w([o({readOnly:!0})],r.prototype,`sourceType`,void 0),w([O(`sourceType`,[`serviceSourceType`,`fields`])],r.prototype,`readSourceType`,null),w([o()],r.prototype,`viewId`,void 0),w([o({types:bt})],r.prototype,`renderer`,null),w([o({types:bt,json:{name:`layerDefinition.drawingInfo.renderer`,origins:{"web-scene":{types:ft,name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy:e=>({enabled:e&&e.type!==`vector-field`})}}}}})],r.prototype,`internalRenderer`,null),w([O(`internalRenderer`)],r.prototype,`readRenderer`,null),w([n(`internalRenderer`)],r.prototype,`writeRenderer`,null),w([o({clonable:!1})],r.prototype,`symbolizer`,void 0),w([o(h)],r.prototype,`opacity`,void 0),w([o({readOnly:!0})],r.prototype,`rasterFields`,null),w([o({constructOnly:!0})],r.prototype,`rasterFunctionInfos`,void 0),w([o({type:F,json:{name:`renderingRule`}})],r.prototype,`rasterFunction`,null),w([O(`rasterFunction`,[`renderingRule`,`rasterFunctionInfos`])],r.prototype,`readRasterFunction`,null),w([o({readOnly:!0})],r.prototype,`serviceDataType`,void 0),w([o({readOnly:!0,type:N})],r.prototype,`spatialReference`,void 0),w([O(`spatialReference`,[`spatialReference`,`extent`])],r.prototype,`readSpatialReference`,null),w([o({type:nt.apiValues,json:{read:nt.read,type:nt.jsonValues}})],r.prototype,`pixelType`,void 0),w([n(`pixelType`)],r.prototype,`writePixelType`,null),w([o({constructOnly:!0,type:et})],r.prototype,`serviceRasterInfo`,void 0),w([o()],r.prototype,`sourceJSON`,void 0),w([o(v)],r.prototype,`url`,void 0),w([o({readOnly:!0})],r.prototype,`version`,void 0),w([O(`version`,[`currentVersion`,`fields`,`timeInfo`])],r.prototype,`readVersion`,null),r=w([y(`esri.layers.mixins.ArcGISImageService`)],r),r},$=class extends De(ie(t(ee(te(zt(Dr(xt(xe(pe(we(p(E(s))))))))))))){constructor(...e){super(...e),this.graphicOrigin=new Vt(this),this.isReference=null,this.operationalLayerType=`ArcGISImageServiceLayer`,this.popupEnabled=!0,this.popupTemplate=null,this.screenSizePerspectiveEnabled=!0,this.type=`imagery`,this._debouncedSaveOperations=m(async(e,t,n)=>{let{save:r,saveAs:a}=await i(async()=>{let{save:e,saveAs:t}=await import(`./imageryUtils-jsOtpBJ2.js`);return{save:e,saveAs:t}},__vite__mapDeps([0,1,2,3,4,5,6]));switch(e){case 0:return r(this,t);case 1:return a(this,n,t)}})}normalizeCtorArgs(e,t){return typeof e==`string`?{url:e,...t}:e}load(e){let t=e==null?null:e.signal;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:[`Image Service`]},e).catch(g).then(()=>this._fetchService(t))),Promise.resolve(this)}set elevationInfo(e){e?.mode!==`relative-to-scene`&&this._set(`elevationInfo`,e),this._validateElevationInfo(e)}get legendEnabled(){return!this._isPreviewLayer&&(this._get(`legendEnabled`)??!0)}set legendEnabled(e){this._set(`legendEnabled`,e)}get listMode(){return this._isPreviewLayer?`hide`:this._get(`listMode`)}set listMode(e){this._set(`listMode`,e)}writeOperationalLayerType(e,t,n){t[n]=this.renderer?.type===`vector-field`?`ArcGISImageServiceVectorLayer`:`ArcGISImageServiceLayer`}get defaultPopupTemplate(){return this.createPopupTemplate()}get _isPreviewLayer(){return!(!this.raster||!this.url?.toLowerCase().includes(`/rasterrendering/imageserver`))}createPopupTemplate(e){let{rasterFields:t}=this,n=new Set,r=wt.itemPixelValue.toLowerCase(),i=this.sourceType===`raster-dataset`,a=Ft.toLowerCase(),o=`${wt.servicePixelValue.toLowerCase()}.`;for(let e of t){let t=e.name.toLowerCase();t===r||t.startsWith(o)||i&&t.startsWith(a)||n.add(e.name)}let s=ce({fields:t,title:this.title},{...e,visibleFieldNames:n}),{rasterInfo:c}=this;return s?.fieldInfos&&c&&Dt(s.fieldInfos,c),s}queryFeatures(e,t){return this.queryRasters(e,t).then(e=>{if(e?.features)for(let t of e.features)t.layer=t.sourceLayer=this,t.origin=this.graphicOrigin;return e})}queryFeatureCount(e,t){return this.queryRasterCount(e,t)}redraw(){this.emit(`redraw`)}async save(e){return this._debouncedSaveOperations(0,e)}async saveAs(e,t){return this._debouncedSaveOperations(1,t,e)}serviceSupportsSpatialReference(e){return je(this,e)}write(e,t){if(!this._isPreviewLayer)return super.write(e,t);if(t?.messages){let e=`${t.origin}/${t.layerContainerType||`operational-layers`}`;t.messages.push(new a(`layer:unsupported`,`Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e}'`,{layer:this}))}return null}_validateElevationInfo(e){Fe(Ee.getLogger(this),Ie(`Imagery layers`,`relative-to-scene`,e)),Fe(Ee.getLogger(this),Pe(`Imagery layers`,e))}};w([o({type:Me,value:null,json:{name:`layerDefinition.elevationInfo`,write:!0,origins:{"portal-item":{read:!1,write:!1},"web-map":{read:!1,write:!1}}}})],$.prototype,`elevationInfo`,null),w([o({readOnly:!0,clonable:!1})],$.prototype,`graphicOrigin`,void 0),w([o(c)],$.prototype,`legendEnabled`,null),w([o({type:[`show`,`hide`]})],$.prototype,`listMode`,null),w([o({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],$.prototype,`isReference`,void 0),w([o({type:[`ArcGISImageServiceLayer`],json:{origins:{"web-map":{type:[`ArcGISImageServiceLayer`,`ArcGISImageServiceVectorLayer`],read:!1,write:{target:`layerType`,ignoreOrigin:!0}}}}})],$.prototype,`operationalLayerType`,void 0),w([n(`web-map`,`operationalLayerType`)],$.prototype,`writeOperationalLayerType`,null),w([o(r)],$.prototype,`popupEnabled`,void 0),w([o({type:oe,json:{read:{source:`popupInfo`},write:{target:`popupInfo`}}})],$.prototype,`popupTemplate`,void 0),w([o({readOnly:!0})],$.prototype,`defaultPopupTemplate`,null),w([o(re)],$.prototype,`screenSizePerspectiveEnabled`,void 0),w([o({readOnly:!0,json:{read:!1}})],$.prototype,`type`,void 0),w([o({readOnly:!0})],$.prototype,`_isPreviewLayer`,null),$=w([y(`esri.layers.ImageryLayer`)],$);var Or=$;export{Or as default};