import{Bw as e,Lw as t,aE as n,tT as r}from"./index-CzMixifc.js";import{n as i}from"./QueueProcessor-CbN5H2eO.js";function a(e,t,n,r){return new s(e,t,n,r)}var o=class{constructor(e,n,r){this._executor=e,this._data=n,this._impl=r,this._closed=!1,this._resolver=t(),this._impl.open(this)}assertOpen(){if(this._closed)throw Error(`Batch closed.`)}get data(){return this.assertOpen(),this._data}get results(){return this._resolver.promise}send(){try{this.assertOpen(),this._closed=!0,this._executor.resume(this),this._impl.close(this),e(this._resolver,this._impl.execute(this._data))}catch(e){this._resolver.reject(e)}}},s=class{constructor(n,r,a,o){if(this._runJob=r,this._maxRunning=a,this._abortSignal=o,this._jobIdSeq=0,this._running=new Set,this._blocked=new Set,this._openBatches=new Map,this._state=`ready`,this._runResolver=null,a<1)throw Error(`_maxRunning=${a} but cannot be < 1`);this._todo=n[Symbol.iterator](),this._queue=new i({concurrency:1,process:async n=>{if(n.type===`start`){let{id:r,args:i}=n,a=t(),o=t(),s={id:r,interrupt:a,finished:o.promise};e(o,this._runJob(i,{id:r,yieldFor:e=>this.yieldFor(s,e)}).then(()=>{this._blocked.has(r)&&this._fail(Error(`job ${r} completed before resuming`)),this._running.delete(r)||this._fail(Error(`job ${r} not running?`))})),await Promise.race([a.promise,s.finished]),this._tryQueue();return}if(n.type===`continue`)return n.job.interrupt=t(),n.data.status===`fulfilled`?n.continuation.resolve(n.data.value):n.continuation.reject(n.data.reason),await Promise.race([n.job.interrupt.promise,n.job.finished]),void this._tryQueue()}})}openBatch(e,t){return new o(this,e,t)}_fail(e,t=!1){if(this._runResolver?.reject(e),this._state=`stopped`,!t)throw e}_schedule(e){this._queue.push(e).catch(e=>this._fail(e,!0))}_tryQueue(){if(this._state===`running`)if(this._abortSignal?.aborted)this._fail(r(),!0);else{if(this._running.size<this._maxRunning){let e=this._todo.next();if(!e.done){let t=this._jobIdSeq++;this._running.add(t),this._schedule({type:`start`,id:t,args:e.value});return}}if(this._running.size===0)return this._runResolver?.resolve(),this._runResolver=null,void(this._state=`stopped`);if(this._blocked.size===this._running.size){let e=null,t=-1/0;for(let[n,r]of this._openBatches)r.size>t&&(e=n,t=r.size);e??this._fail(Error(`deadlock`)),e.send();return}}}resume(e){let t=this._openBatches.get(e);if(this._openBatches.delete(e),t!=null)for(let e of t)this._blocked.delete(e)||this._fail(Error(`job ${e} not suspended`))}async yieldFor(e,r){r.assertOpen(),this._running.has(e.id)||this._fail(Error(`job ${e.id} not running`)),this._blocked.has(e.id)&&this._fail(Error(`job ${e.id} already suspended`)),this._blocked.add(e.id),n(this._openBatches,r,()=>new Set).add(e.id),e.interrupt??this._fail(Error(`job ${e.id} hasn't resumed yet`)),e.interrupt.resolve(),e.interrupt=null;let i=t(),a;try{a={status:`fulfilled`,value:await r.results}}catch(e){a={status:`rejected`,reason:e}}return this._schedule({type:`continue`,continuation:i,data:a,job:e}),i.promise}run(){this._state!==`ready`&&this._fail(Error(`executor not ready to start. state=${this._state}`));let e=t();return this._state=`running`,this._runResolver=e,this._tryQueue(),e.promise}};export{a as createBatchExecutor};