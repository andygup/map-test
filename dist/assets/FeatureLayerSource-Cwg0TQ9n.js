const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/uploadAssets-Bf-58_Yq.js","assets/index-BN8X5Ryz.js","assets/index-CWJhHB6-.css","assets/quatf64-D37SEdPg.js","assets/quat-C8PgLo31.js","assets/MeshTransform-BaPjlQwH.js","assets/axisAngleDegrees-DzAS4tF-.js","assets/External-C55iwtd6.js","assets/meshSpatialReferenceScaleUtils-wsPB6tEL.js","assets/meshFeatureAttributes-DdbGwu_X.js","assets/convertMeshVertexSpace-C2wJssTC.js","assets/vec3-B5yu4INg.js","assets/vec4-BLZ_ZPtE.js","assets/computeTranslationToOriginAndRotation-0WDVmpJG.js","assets/projectPointToVector-BkRdoTqD.js","assets/spatialReferenceEllipsoidUtils-qw9wv8RL.js","assets/MeshLocalVertexSpace-vomIk0sx.js","assets/MeshVertexAttributes-CBsb_nVo.js","assets/meshProperties-CbjLwdbT.js","assets/BufferView-BW77W5ev.js","assets/Util-BQgFCZvD.js","assets/meshCloneUtils-BXMzy817.js","assets/vertexSpaceConversion-Dz87RqR7.js","assets/meshVertexSpaceUtils-s2jLb8qI.js"])))=>i.map(i=>d[i]);
import{$S as e,$T as t,$i as n,AE as r,BT as i,CE as a,ED as o,FC as s,Kn as c,Lx as l,Qh as u,Qi as d,VT as f,Xi as p,ZS as m,Zi as h,aC as g,aD as _,iT as v,jE as y,kD as b,pd as x,pv as S,qT as C,sD as w,sT as T,tT as E,uh as D,ur as O,va as k,vx as A,zh as j}from"./index-BN8X5Ryz.js";import{n as M}from"./MeshLocalVertexSpace-vomIk0sx.js";import{a as N}from"./meshVertexSpaceUtils-s2jLb8qI.js";import{s as P}from"./External-C55iwtd6.js";import{r as F}from"./clientSideDefaults-Iizf0eUh.js";import{a as I,i as L,n as R,o as z,r as B,s as V,t as H}from"./applyEditsUtils-CPVhCOou.js";import{n as U}from"./executeQueryJSON-DJO3NDvM.js";import{t as W}from"./QueryTask-6dVRoJFW.js";var G=new C({originalAndCurrentFeatures:`original-and-current-features`,none:`none`}),K=new C({Started:`published`,Publishing:`publishing`,Stopped:`unavailable`}),q=class extends u{constructor(e){super(e),this.type=`feature-layer`,this.supportedSourceTypes=new Set([`Feature Layer`,`Oriented Imagery Layer`,`Table`,`Catalog Layer`]),this.refresh=E(async()=>{await this.load();let e=this.sourceJSON.editingInfo?.lastEditDate;if(e==null)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}let t=e!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}}),this._ongoingAssetUploads=new Map}load(e){let t=this.layer.sourceJSON,n=this._fetchService(t,{...e}).then(()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e)).then(()=>this._ensureLatestMetadata(e));return this.addResolvingPromise(n),Promise.resolve(this)}initialize(){this.addHandles([S(()=>{let e=this.layer;return e&&`lastEditsEventDate`in e?e.lastEditsEventDate:null},e=>this._handleLastEditsEventChange(e))])}destroy(){this._removeEditInterceptor()}get queryTask(){let{capabilities:e,parsedUrl:t,gdbVersion:n,spatialReference:r,fieldsIndex:i,uniqueIdFields:a}=this.layer,s=`infoFor3D`in this.layer?this.layer.infoFor3D:null,c=`dynamicDataSource`in this.layer?this.layer.dynamicDataSource:null,l=o(`featurelayer-pbf`)&&e?.query.supportsFormatPBF&&s==null;return new W({dynamicDataSource:c,fieldsIndex:i,gdbVersion:n,infoFor3D:s,pbfSupported:l,queryAttachmentsSupported:e?.operations?.supportsQueryAttachments??!1,sourceSpatialReference:r,uniqueIdFields:a,url:t.path})}async addAttachment(e,t){await this.load();let{layer:n}=this;await O(n,`editing`);let r=e.attributes[n.objectIdField],i=n.parsedUrl.path+`/`+r+`/addAttachment`,a=this._getLayerRequestOptions(),o=this._getFormDataForAttachment(t,a.query);try{let e=await m(i,{body:o});return R(e.data.addAttachmentResult)}catch(e){throw this._createAttachmentErrorResult(r,e)}}async updateAttachment(e,t,n){await this.load();let{layer:r}=this;await O(r,`editing`);let i=e.attributes[r.objectIdField],a=r.parsedUrl.path+`/`+i+`/updateAttachment`,o=this._getLayerRequestOptions({query:{attachmentId:t}}),s=this._getFormDataForAttachment(n,o.query);try{let e=await m(a,{body:s});return R(e.data.updateAttachmentResult)}catch(e){throw this._createAttachmentErrorResult(i,e)}}async applyEdits(e,r){await this.load();let{layer:i}=this;await O(i,`editing`);let a=`infoFor3D`in i?i.infoFor3D:null,o=a!=null,s=o||(r?.globalIdUsed??!1),c=o?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,l=e.addFeatures?.map(e=>z(this.layer,e,a))??[],u=(await Promise.all(l)).filter(w),f=e.updateFeatures?.map(e=>z(this.layer,e,a))??[],g=(await Promise.all(f)).filter(w),_=B(this.layer,e.deleteFeatures,s);k(u,g,i.spatialReference);let v=await L(this.layer,e),y=i.capabilities.editing.supportsAsyncApplyEdits&&o,b=r?.gdbVersion||i.gdbVersion,x={gdbVersion:b,rollbackOnFailure:r?.rollbackOnFailureEnabled,useGlobalIds:s,returnEditMoment:r?.returnEditMoment,usePreviousEditMoment:r?.usePreviousEditMoment,async:y};await h(this.layer.url,b,!0);let S=p(this.layer.url,b||null);if(await d(i.url,b,i.historicMoment))throw new t(`feature-layer-source:historic-version`,`Editing a historic version is not allowed`);r?.returnServiceEditsOption?(x.edits=JSON.stringify([{id:i.layerId,adds:u.length?u:null,updates:g.length?g:null,deletes:_.length?_:null,attachments:v,assetMaps:c}]),x.returnServiceEditsOption=G.toJSON(r?.returnServiceEditsOption),x.returnServiceEditsInSourceSR=r?.returnServiceEditsInSourceSR):(x.adds=u.length?JSON.stringify(u):null,x.updates=g.length?JSON.stringify(g):null,x.deletes=_.length?s?JSON.stringify(_):_.join(`,`):null,x.attachments=v&&JSON.stringify(v),x.assetMaps=c==null?void 0:JSON.stringify(c));let C=this._getLayerRequestOptions({method:`post`,query:x});S&&(C.authMode=`immediate`,C.query.returnEditMoment=!0,C.query.sessionId=n);let T=r?.returnServiceEditsOption?i.url:i.parsedUrl.path,E;try{E=y?await this._asyncApplyEdits(T+`/applyEdits`,C):await m(T+`/applyEdits`,C)}catch(e){if(!I(e))throw e;C.authMode=`immediate`,E=y?await this._asyncApplyEdits(T+`/applyEdits`,C):await m(T+`/applyEdits`,C)}return this._createEditsResult(E)}async deleteAttachments(e,t){await this.load();let{layer:n}=this;await O(n,`editing`);let r=e.attributes[n.objectIdField],i=n.parsedUrl.path+`/`+r+`/deleteAttachments`;try{return(await m(i,this._getLayerRequestOptions({query:{attachmentIds:t.join(`,`)},method:`post`}))).data.deleteAttachmentResults.map(R)}catch(e){throw this._createAttachmentErrorResult(r,e)}}fetchRecomputedExtents(e={}){let t=e.signal;return this.load({signal:t}).then(async()=>{let t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:n,url:r}=this.layer,{data:i}=await m(`${r}/${n}`,t),{id:a,extent:o,fullExtent:s,timeExtent:c}=i,l=o||s;return{id:a,fullExtent:l&&A.fromJSON(l),timeExtent:c&&j.fromJSON({start:c[0],end:c[1]})}})}async queryAttachments(e,t={}){await this.load();let n=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,n)}async queryFeatures(e,t){await this.load();let n=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});if(e.outStatistics?.length&&n.features.length){let t=new Map;if(n.features.forEach(n=>{let r=n.attributes;e.outStatistics?.forEach(({outStatisticFieldName:e})=>{if(e){let n=e.toLowerCase();n&&n in r&&e!==n&&(r[e]=r[n],delete r[n],t.set(n,e))}})}),n.fields!=null)for(let e of n.fields){let n=t.get(e.name.toLowerCase());n!=null&&(e.name=n)}}return n}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryPivot(e,t){return await this.load(),this.queryTask.executePivotQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryAttributeBins(e,t){return await this.load(),this.queryTask.executeAttributeBinsQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!g(this.layer.url))return`unavailable`;let e=s(this.layer.url,`status`),t=await m(e,{query:{f:`json`}});return K.fromJSON(t.data.status)}async uploadAssets(t,n){let{uploadAssets:r}=await e(async()=>{let{uploadAssets:e}=await import(`./uploadAssets-Bf-58_Yq.js`);return{uploadAssets:e}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]));return r(t,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},n)}_handleLastEditsEventChange(e){let t=this.layer;if(e==null||!(`capabilities`in t)||!(`effectiveCapabilities`in t)||!(!t.capabilities?.operations?.supportsEditing&&t.effectiveCapabilities?.operations?.supportsEditing))return;let n=t.url;n!=null&&(`layerId`in t&&s(n,t.layerId.toString()),this._getOrCreateEditInterceptor(n).before=t=>{let n=t.requestOptions.method??`auto`;if(n===`auto`||n===`head`){let n=t.requestOptions.query??{};n._ts=e.getTime(),t.requestOptions.query=n}})}_getOrCreateEditInterceptor(e){return this._editInterceptor??(this._editInterceptor={urls:e},r.request.internalInterceptors.push(this._editInterceptor)),this._editInterceptor}_removeEditInterceptor(){this._editInterceptor!=null&&(_(r.request.internalInterceptors,this._editInterceptor),this._editInterceptor=null)}async _asyncApplyEdits(e,n){let r=(await m(e,n)).data.statusUrl;for(;;){let e=(await m(r,{query:{f:`json`},responseType:`json`})).data;switch(e.status){case`Completed`:return m(e.resultUrl,{query:{f:`json`},responseType:`json`});case`CompletedWithErrors`:throw new t(`async-applyEdits-failed`,`asynchronous applyEdits call failed.`);case`Failed ImportChanges`:case`InProgress`:case`Pending`:case`ExportAttachments`:case`ExportChanges`:case`ExportingData`:case`ExportingSnapshot`:case`ImportAttachments`:case`ProvisioningReplica`:case`UnRegisteringReplica`:break;default:throw new t(`async-applyEdits-failed`,`asynchronous applyEdits call failed (undefined response status)`)}await v(J)}}_createRequestQueryOptions(e){let t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,n){if(!e){let t={};o(`featurelayer-advanced-symbols`)&&(t.returnAdvancedSymbols=!0),n?.cacheBust&&(t._ts=Date.now());let{data:r}=await m(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:t,signal:n?.signal}));e=r}this.layer.applyPreferredHost(e),this.sourceJSON=await this._patchServiceJSON(e,n?.signal);let r=e.type;if(!this.supportedSourceTypes.has(r))throw new t(`feature-layer-source:unsupported-type`,`Source type "${r}" is not supported`)}async _patchServiceJSON(e,t){if(e.type!==`Table`&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){let t=F(e.geometryType).renderer;y(`drawingInfo.renderer`,t,e)}if(e.geometryType===`esriGeometryMultiPatch`&&e.infoFor3D&&(e.geometryType=`mesh`),e.extent==null)try{let{data:n}=await m(this.layer.url,this._getLayerRequestOptions({signal:t}));n.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:n.spatialReference})}catch(e){T(e)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(n){let{addAssetFeatures:r}=n;if(!r?.length||await this._areAllAssetsAlreadyMapped(r))return null;let i=n.addFeatures.filter(e=>e.geometry);if(r.length!==i.length+n.updateFeatures.length)throw new t(`feature-layer-source:unsupported-mesh-edits`,`Mixing attribute only edits with mesh geometry edits is not currently supported`);let a=[],o=new Map;for(let t of r){let{geometry:n}=t,{vertexSpace:r}=n;if(N(r))a.push(n);else{let r=n.origin,{convertMeshVertexSpace:i}=await e(async()=>{let{convertMeshVertexSpace:e}=await import(`./convertMeshVertexSpace-C2wJssTC.js`);return{convertMeshVertexSpace:e}},__vite__mapDeps([10,1,2,11,12,13,14,15,16,17,18,19,20,21,22,23])),s=await i(n,new M({origin:[r.x,r.y,r.z??0]}));o.set(s,n),t.geometry=s,a.push(s)}}await this.uploadAssets(a);for(let[e,t]of o)t.addExternalSources(e.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(r),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){let t=[],n=this.layer.globalIdField,r=this.layer.parsedUrl;for(let i of e){let e=i.geometry,{metadata:o}=e,s=o.getExternalSourcesOnService(r),c=i.getAttribute(n);if(s.length===0){a.getLogger(this).error(`Skipping feature ${c}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}let{source:l}=s.find(P)??s[0];for(let e of l.assets)e.parts.length===1?t.push({globalId:D(),parentGlobalId:c,assetName:e.assetName,assetHash:e.parts[0].partHash,flags:[]}):a.getLogger(this).error(`Skipping asset ${e.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){let t=e.data,{layerId:n}=this.layer,r=[],i=null;if(Array.isArray(t))for(let e of t)r.push({id:e.id,editedFeatures:e.editedFeatures}),e.id===n&&(i={addResults:e.addResults??[],updateResults:e.updateResults??[],deleteResults:e.deleteResults??[],attachments:e.attachments,editMoment:e.editMoment});else i=t;let a=V(i);if(r.length>0){a.editedFeatureResults=[];for(let e of r){let{editedFeatures:t}=e,n=t?.spatialReference?new l(t.spatialReference):null;a.editedFeatureResults.push({layerId:e.id,editedFeatures:H(t,n)})}}return a}_createAttachmentErrorResult(e,n){let r=n.details.messages?.[0]||n.message,i=n.details.httpStatus||n.details.messageCode;return{objectId:e,globalId:null,error:new t(`feature-layer-source:attachment-failure`,r,{code:i})}}_getFormDataForAttachment(e,t){let n=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(n)for(let e in t){let r=t[e];r!=null&&(n.set?n.set(e,r):n.append(e,r))}return n}_getLayerRequestOptions(e={}){let{layer:t,layer:{parsedUrl:n,gdbVersion:r}}=this;return{...e,query:{gdbVersion:r,layer:`dynamicDataSource`in t&&t.dynamicDataSource?JSON.stringify({source:t.dynamicDataSource}):void 0,...n.query,f:`json`,...this._createRequestQueryOptions(e)},responseType:`json`}}async _areAllAssetsAlreadyMapped(e){let{layer:t}=this,{globalIdField:n,parsedUrl:r}=t,i=`infoFor3D`in t?t.infoFor3D:null;if(i==null||n==null)return!1;let a=c(i);if(a==null)return!1;let o=s(r.path,`../${a.id}`),l=[];for(let t of e){if(!(t.geometry.metadata.getExternalSourcesOnService(r).length>0))return!1;l.push(t)}let u=l.map(e=>e.getAttribute(n)).filter(w);if(u.length===0)return!1;let{assetMapFieldRoles:{parentGlobalId:d,assetHash:f}}=i,p=new x({where:`${d} IN (${u.map(e=>`'${e}'`)})`,outFields:[f,d],returnGeometry:!1}),m=await U(o,p),{features:h}=m;return h.length!==0&&!l.some(e=>{let t=e.getAttribute(n);if(!t)return!0;let{metadata:i}=e.geometry,a=h.filter(e=>e.getAttribute(d)===t);if(a.length===0)return!0;let o=a.map(e=>e.getAttribute(f));return i.getExternalSourcesOnService(r).flatMap(({source:e})=>e.assets.flatMap(e=>e.parts.map(e=>e.partHash))).some(e=>o.every(t=>e!==t))})}};b([i()],q.prototype,`type`,void 0),b([i({constructOnly:!0})],q.prototype,`layer`,void 0),b([i({constructOnly:!0})],q.prototype,`supportedSourceTypes`,void 0),b([i({readOnly:!0})],q.prototype,`queryTask`,null),q=b([f(`esri.layers.graphics.sources.FeatureLayerSource`)],q);var J=1e3;export{q as t};