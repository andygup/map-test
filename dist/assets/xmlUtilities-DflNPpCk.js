const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-vVX87Mmx.js","assets/SpatialReference-CfUjvF_j.js","assets/index-BN8X5Ryz.js","assets/index-CWJhHB6-.css","assets/Envelope2D-B7gkUj4e.js","assets/Point2D-DJueHbCy.js","assets/OperatorDefinitions-C5Pat-Jx.js","assets/SimpleGeometryCursor-BILtMaQf.js","assets/Transformation2D-D07KwcEj.js","assets/densifyOperator-BwflTlW-.js","assets/apiConverter-Dsm0pxcs.js","assets/jsonConverter-CoA5-zxu.js","assets/FlatGeometry-BsPiiSVP.js","assets/memoryEstimations-D_IbKyOk.js","assets/OptimizedGeometry-BQJ7w5VU.js","assets/differenceOperator-qQi88B6s.js","assets/differenceOperator-C1U0kPrJ.js","assets/lengthOperator-BUhW82a8.js","assets/lengthOperator-DdV6vMS2.js"])))=>i.map(i=>d[i]);
import{$S as e,$T as t,Ag as n,BT as r,Bv as i,CE as a,Ex as o,GT as s,Li as c,Lx as l,Mg as u,NS as d,VT as f,WT as p,ZS as m,_E as h,hT as g,ha as _,iw as v,kD as y,mE as b,nC as x,vx as S}from"./index-BN8X5Ryz.js";import{n as C}from"./QueueProcessor-D6ozkjY6.js";import{c as w,f as T,l as E,n as D,o as O,p as k,r as A,s as j,t as M,u as N}from"./multidimensionalUtils-CoDZYrcG.js";import{E as P,U as F,d as I,t as L,z as R}from"./RasterSymbolizer-C04g1f48.js";import{a as z}from"./PixelBlock-D0vUlFM9.js";import{D as ee,M as B,_ as te,o as ne,u as re,v as V}from"./vectorFieldUtils-BkGOIhR4.js";import{_ as ie,a as ae,c as oe,f as se,g as ce,h as le,i as ue,l as de,m as fe,n as pe,o as me,p as he,r as ge,s as _e,u as ve,y as ye}from"./RasterJobHandlerMixin-v7ic83Yl.js";import{r as H,t as be}from"./datasetUtils-QzMOwZxx.js";import{a as xe,c as Se,i as Ce,o as we,r as Te}from"./RawBlockCache-BzmVyUjy.js";import{a as U,c as Ee,f as W,l as De,n as Oe,o as ke,p as Ae,r as G,s as je,t as K,u as q}from"./rasterProjectionHelper-BpX32CQ6.js";import{i as J,r as Me}from"./clipUtils-D_rTuWN2.js";import{t as Ne}from"./rasterFunctionHelper-CEhF_KcG.js";var Pe=8,Fe=256,Ie=0,Y=class extends v{constructor(){super(...arguments),this._tileFetchQueue=new C({concurrency:32,process:(e,t)=>this.fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:`closest`}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:`closest`,tileInfo:n.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){let{rasterInfo:e}=this,t=K(e.spatialReference);return t!=null&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){let{transform:e}=this.rasterInfo;return e==null||e.type===`gcs-shift`}set rasterJobHandler(e){this._set(`rasterJobHandler`,e),H(this)&&this.primaryRasters?.rasters?.forEach(t=>t.rasterJobHandler=e)}get rasterId(){return this.url||`rasterId-`+ Ie++}set url(e){this._set(`url`,x(e,a.getLogger(this)))}async open(e){return this._openPromise??=q().then(()=>this._open(e)),this._openPromise}async fetchTile(e,n,r,i={}){let a=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(e,n,r,a);if(!o)throw new t(`imagery-tile:out-of-bounds`,`Level for fetch tile out of range`);return i={noClip:!0,...i},this.fetchPixels(o,a.size[0],a.size[1],i)}async identify(e,t={}){e=b(o,e).clone().normalize();let{multidimensionalDefinition:n,timeExtent:r}=t,{rasterInfo:i}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:s}=i,{transposedVariableName:c}=t,l=s!=null&&a&&(r!=null||T(n));l&&!c&&(c=n!=null&&n.length>0?n[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:c}),t=this._getRequestOptionsWithSliceId(t);let{spatialReference:u,extent:d}=i,{datumTransformation:f}=t,p=ke(e,u,f);if(!d.intersects(p))return{location:p,value:null};if(i.transform!=null){let e=i.transform.inverseTransform(p);if(!i.nativeExtent.intersects(e))return{location:e,value:null};p=e}let m=0,h=c!=null&&s!=null&&i.hasMultidimensionalTranspose;if(H(this)){let e=this.primaryRasters.rasters[0];if(h)return e.identify(p,t);let{pixelSize:r}=i,a=r.x*3/2,o=r.y*3/2,s=new S({xmin:p.x-a,xmax:p.x+a,ymin:p.y-o,ymax:p.y+o,spatialReference:u}),c={interpolation:`nearest`,multidimensionalDefinition:n,sliceId:t.sliceId,bandIds:t.bandIds},{pixelBlock:l}=await e.fetchPixels(s,3,3,c),{pixelBlock:d}=await this.fetchPixels(s,3,3,c);if(l==null)return{location:p,value:null};let f=!l.mask||l.mask[4]?l.pixels.map(e=>e[4]):null,m;return d!=null&&(m=!d.mask||d.mask[4]?d.pixels.map(e=>e[4]):void 0),{location:p,value:f,processedValue:m,pyramidLevel:0}}if(!h){if(t.srcResolution)m=Ee(t.srcResolution,i,this.ioConfig.sampling).pyramidLevel;else if(m=await this.computeBestPyramidLevelForLocation(e,t),m==null)return{location:p,value:null}}let g=this.identifyPixelLocation(p,m,null,h);if(g===null)return{location:p,value:null};let{row:_,col:v,rowOffset:y,colOffset:x,blockWidth:C}=g,w=await this._fetchRawTile(m,_,v,t);if(!w?.pixels?.length)return{location:p,value:null};let E=y*C+x;return this._processIdentifyResult(w,{srcLocation:p,position:E,pyramidLevel:m,useTransposedTile:!!h,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(e,t,n,r={}){e=je(e),r=this._getRequestOptionsWithSliceId(r);let{_hasNoneOrGCSShiftTransform:i}=this;if(r.requestRawData&&i)return this._fetchPixels(e,t,n,r);let a=K(e.spatialReference),o=W(e);if(a==null||o===0||o===1&&this._isGlobalWrappableSource&&i)return this._fetchPixels(e,t,n,r);if(o>=3)return{extent:e,pixelBlock:null};let s=[],{xmin:c,xmax:l}=e,u=Math.round(a/(l-c)*t),d=u-Math.round((a/2-c)/(l-c)*t),f=0,p=[];for(let i=0;i<=o;i++){let m=new S({xmin:i===0?c:-a/2,xmax:i===o?l-a*i:a/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),h=i===0?u-d:i===o?t-f:u;f+=h,p.push(h);let g=r.disableWrapAround&&i>0?null:this._fetchPixels(m,h,n,r);s.push(g)}let m=(await Promise.all(s)).map(e=>e?.pixelBlock),h=null,g={width:t,height:n};return h=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:g,destDimension:null,coefs:null,sampleSpacing:null,interpolation:`nearest`,alignmentInfo:null,blockWidths:p},r)).pixelBlock:V(m,g,{blockWidths:p}),{extent:e,srcExtent:G(e,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:h}}async fetchRawPixels(e,t,n,r={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};let i=await this._fetchRawTiles(e,t,n,r),{nativeExtent:a,nativePixelSize:o,storageInfo:s}=this.rasterInfo,c=2**e,l=o.x*c,u=o.y*c,d=new S({xmin:a.xmin+l*t.x,xmax:a.xmin+l*(t.x+n.width-1),ymin:a.ymax-u*(t.y+n.height-1),ymax:a.ymax-u*t.y,spatialReference:a.spatialReference});if(!i)return{extent:d,srcExtent:d,pixelBlock:null};let{pixelBlocks:f,mosaicSize:p}=i;if(f.length===1&&f[0]!=null&&f[0].width===n.width&&f[0].height===n.height)return{extent:d,srcExtent:d,pixelBlock:i.pixelBlocks[0]};let m=e>0?s.pyramidBlockWidth:s.blockWidth,h=e>0?s.pyramidBlockHeight:s.blockHeight,g={x:t.x%m,y:t.y%h},_;return _=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:p,destDimension:n,clipOffset:g,clipSize:n,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:V(f,p,{clipOffset:g,clipSize:n}),{extent:d,srcExtent:d,pixelBlock:_}}fetchRawTile(e,n,r,i){throw new t(`BaseRaster:read-not-implemented`,`fetchRawTile() is not implemented`)}computeExtent(e){return G(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?F(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,n=0){let{customFetchParameters:r}=this.ioConfig,{range:i,query:a,headers:o}=t;n=n??t.retryCount??this.ioConfig.retryCount;let s=i?{Range:`bytes=${i.from}-${i.to}`}:null;try{return await m(e,{...t,query:{...a,...r},headers:{...o,...s}})}catch(r){if(n>0)return n--,this.request(e,t,n);throw r}}getSliceIndex(e){let{multidimensionalInfo:t}=this.rasterInfo;return t==null||e==null||e.length===0?null:M(e,t)}getTileExtentFromTileInfo(e,t,n,r){let i=r.lodAt(e);return i?this.getTileExtent({x:i.resolution,y:i.resolution},t,n,r.origin,r.spatialReference,r.size):null}updateTileInfo(){let{storageInfo:e,spatialReference:t,extent:r,pixelSize:i}=this.rasterInfo,{pyramidResolutions:a}=e;if(!e.tileInfo){let s=[],c=e.maximumPyramidLevel||0,l=(i.x+i.y)/2,d=1/.0254*96*l;for(let e=0;e<=c&&(s.unshift(new u({level:c-e,resolution:l,scale:d})),e!==c);e++)if(a){let t=(a[e].x+a[e].y)/2;d*=t/l,l=t}else l*=2,d*=2;let f=new o({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new n({origin:f,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:s}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,n=512,r){let{width:i,height:a,nativeExtent:s,pixelSize:c,spatialReference:l}=e,u=new o({x:s.xmin,y:s.ymax,spatialReference:l});r??=Math.max(0,Math.round(Math.log(Math.max(i,a))/Math.LN2-8));let d=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[c],r);e.storageInfo=new P({blockWidth:t,blockHeight:n,pyramidBlockWidth:t,pyramidBlockHeight:n,origin:u,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:d})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,n,r,i,a=0,o=2){if(i.length===1&&a>0){i=[...i];let{x:e,y:t}=i[0];for(let n=0;n<a;n++)e*=o,t*=o,i.push({x:e,y:t})}let s=[],{x:c,y:l}=r;for(let r=0;r<i.length;r++){let{x:a,y:o}=i[r];s.push({minCol:Math.floor((e.xmin-c+.1*a)/t/a),maxCol:Math.floor((e.xmax-c-.1*a)/t/a),minRow:Math.floor((l-e.ymax+.1*o)/n/o),maxRow:Math.floor((l-e.ymin-.1*o)/n/o)})}return s}getPyramidPixelSize(e){let{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:n,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(e===0)return t;if(n!=null&&n.length)return n[e-1];let i=r**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,n,r){let{spatialReference:i,nativeExtent:a,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:s,origin:c,transposeInfo:l}=o,u=r&&l!=null?l.tileSize[0]:o.blockWidth,d=r&&l!=null?l.tileSize[1]:o.blockHeight,f=ke(e,i,n);if(!a.intersects(f)||t<0||t>s)return null;let p=this.getPyramidPixelSize(t),{x:m,y:h}=p,g=(c.y-f.y)/h/d,_=(f.x-c.x)/m/u,v=Math.min(d-1,Math.floor((g-Math.floor(g))*d)),y=Math.min(u-1,Math.floor((_-Math.floor(_))*u));return{pyramidLevel:t,row:Math.floor(g),col:Math.floor(_),rowOffset:v,colOffset:y,blockWidth:u,srcLocation:f}}getTileExtent(e,t,n,r,i,a){let[o,s]=a,c=r.x+n*o*e.x,l=c+o*e.x,u=r.y-t*s*e.y,d=u-s*e.y;return new S({xmin:c,xmax:l,ymin:d,ymax:u,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,n){let r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<n||r.minRow>t||r.minCol>n}updateImageSpaceRasterInfo(e){let{pixelSize:t}=e,{width:n,height:r}=e,i=l.WebMercator;e.spatialReference=i,e.extent=e.nativeExtent=new S({xmin:-.5,ymax:.5,xmax:n-.5,ymin:.5-r,spatialReference:i}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new o({x:1,y:1,spatialReference:i});let{extent:a,storageInfo:s}=e;if(s){s.origin=new o({x:a.xmin,y:a.ymax,spatialReference:i});let{pyramidResolutions:n,tileInfo:r}=s;if(n&&n.forEach(e=>{e.x/=t.x,e.y/=t.y}),r){r.origin=s.origin;let t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;r.lods.forEach((e,n)=>{e.resolution=t*2**n,e.scale=96*e.resolution/.0254})}}}async _fetchPixels(e,t,n,r={}){let i=W(e);if(i>=2)return{extent:e,pixelBlock:null};let a=this._getSourceDataInfo(e,t,n,r),{pyramidLevel:s,srcResolution:c,srcExtent:l,srcWidth:u,srcHeight:d,ul:f}=a;if(u===0||d===0)return{extent:e,srcExtent:l,pixelBlock:null};let{rasterInfo:p}=this,m=p.transform,h=m?.type===`gcs-shift`,g=K(e.spatialReference)!=null;!h&&g||(i=W(a.srcExtent,h));let _=await this._fetchRawTiles(s,f,{width:u,height:d,wrapCount:i},r);if(!_)return{extent:e,srcExtent:l,pixelBlock:null};let v=p.storageInfo,y=s>0?v.pyramidBlockWidth:v.blockWidth,b=s>0?v.pyramidBlockHeight:v.blockHeight,{x,y:S}=p.pixelSize;if(s>0){let{pyramidResolutions:e,pyramidScalingFactor:t}=v;if(e!=null&&e[s-1])({x,y:S}=e[s-1]);else{let e=t**s;x*=e,S*=e}}let C=p.spatialReference,w=new o({x,y:S,spatialReference:C}),T=y===u&&b===d&&f.x%y===0&&f.y%b===0,E=new o({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/n,spatialReference:e.spatialReference}),D=!e.spatialReference.equals(C),O=C.isGeographic?1e-9:1e-4,{datumTransformation:k}=r;if(!D&&T&&_.pixelBlocks.length===1&&y===t&&b===n&&Le(c,E,O))return{extent:e,srcExtent:l,srcTilePixelSize:w,pixelBlock:_.pixelBlocks[0]};let A=g&&K(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,j=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith(`vector`);j&&!this.rasterJobHandler&&await q();let M=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:_.extent,pixelSize:E.toJSON(),datumTransformation:k,rasterTransform:m,hasWrapAround:i>0||A,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:j},r):Ae({projectedExtent:e,srcBufferExtent:_.extent,pixelSize:E,datumTransformation:k,rasterTransform:m,hasWrapAround:i>0||A,isAdaptive:!1,includeGCSGrid:j}),N,P=!r.requestRawData,F={rows:M.spacing[0],cols:M.spacing[1]},I=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,_.extent.xmin):void 0,{pixelBlocks:L,mosaicSize:R,isPartiallyFilled:z}=_,B=null;if(this.rasterJobHandler){let e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:L,srcMosaicSize:R,destDimension:P?{width:t,height:n}:null,coefs:P?M.coefficients:null,sampleSpacing:P?F:null,projectDirections:j,gcsGrid:j?M.gcsGrid:null,isUV:this.rasterInfo.dataType===`vector-uv`,interpolation:r.interpolation,alignmentInfo:I,blockWidths:null},r);({pixelBlock:N,localNorthDirections:B}=e)}else{let e=V(L,R,{alignmentInfo:I});N=P?te(e,{width:t,height:n},M.coefficients,F,r.interpolation):e,j&&M.gcsGrid&&(B=ee({width:t,height:n},M.gcsGrid),N=re(N,this.rasterInfo.dataType,B))}return r.requestRawData||j?{extent:e,srcExtent:l,srcTilePixelSize:w,pixelBlock:N,transformGrid:M,localNorthDirections:B,isPartiallyFilled:z}:{extent:e,srcExtent:l,srcTilePixelSize:w,pixelBlock:N}}async _fetchRawTiles(e,t,n,r){let{origin:i,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:s}=this.getBlockWidthHeight(e),{x:c,y:l}=t,{width:u,height:d,wrapCount:f}=n,p=this._getRasterTileAlignmentInfo(e,0);r.buffer&&(c-=r.buffer.cols,l-=r.buffer.rows,u+=2*r.buffer.cols,d+=2*r.buffer.rows);let m=0,h=0,g=0;f&&p!=null&&({worldColumnCountFromOrigin:h,originColumnOffset:g,rightPadding:m}=p,h*p.blockWidth-m>=c+u&&(m=0));let _=Math.floor(c/o),v=Math.floor(l/s),y=Math.floor((c+u+m-1)/o),b=Math.floor((l+d+m-1)/s),x=a[e];if(!x)return null;let{minRow:C,minCol:w,maxCol:T,maxRow:E}=x;if(f===0&&(b<C||y<w||v>E||_>T))return null;let D=[],O=!1,k=this.ioConfig.allowPartialFill==null?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=v;t<=b;t++)for(let n=_;n<=y;n++){let i=n;if(!r.disableWrapAround&&f&&p!=null&&h<=n&&(i=n-h-g),t>=C&&i>=w&&E>=t&&T>=i){let n=this._fetchRawTile(e,t,i,r);k?D.push(new Promise(e=>{n.then(t=>e(t)).catch(()=>{O=!0,e(null)})})):D.push(n)}else D.push(Promise.resolve(null))}if(D.length===0)return null;let A=await Promise.all(D),j={height:(b-v+1)*s,width:(y-_+1)*o},{spatialReference:M}=this.rasterInfo,N=this.getPyramidPixelSize(e),{x:P,y:F}=N;return{extent:new S({xmin:i.x+_*o*P,xmax:i.x+(y+1)*o*P,ymin:i.y-(b+1)*s*F,ymax:i.y-v*s*F,spatialReference:M}),pixelBlocks:A,mosaicSize:j,isPartiallyFilled:O}}_fetchRawTile(e,t,n,r){let{storageInfo:i}=this.rasterInfo,a=i.transposeInfo!=null&&!!r.transposedVariableName;if(!a){let r=i.blockBoundary[e];if(!r)return Promise.resolve(null);let{minRow:a,minCol:o,maxCol:s,maxRow:c}=r;if(t<a||n<o||t>c||n>s)return Promise.resolve(null)}let o=a?r.transposeVariableName:r.sliceId,s=i.isBsqTile?r.bandIds:null,c=Ce(this.rasterId,o,s),l=`${e}/${t}/${n}`,u=xe(c,r.registryId,l);if(u==null){let a=new AbortController,o=r.bandIds?.slice();if(o?.length&&i.isBsqTile){let i=new Set(o),s=[],c=Array.from(i);for(let i of c)s.push(this._tileFetchQueue.push({pyramidLevel:e,row:t,col:n,options:{...r,bandIds:[i]}},{signal:a.signal}));u=Promise.all(s).then(e=>{if(e.some(e=>e==null))return null;if(c.length!==o.length){let t=[];for(let n of o){let r=e[c.indexOf(n)];t.includes(r)&&(r=r.clone()),t.push(r)}e=t}return this.rasterJobHandler?this.rasterJobHandler.compositeBands({pixelBlocks:e},{signal:a.signal,transferPixelsToWorker:!0}):B(e)})}else u=this._tileFetchQueue.push({pyramidLevel:e,row:t,col:n,options:r},{signal:a.signal});Te(c,r.registryId,l,u,a),u.catch(()=>Se(c,r.registryId,l))}return r.signal&&g(r,()=>{we(c,r.registryId,l)}),u}_computeMagDirValues(e){let{bandCount:t,dataType:n}=this.rasterInfo;if(!(t===2&&n===`vector-magdir`||n===`vector-uv`)||e?.length!==2||!e[0]?.length)return null;let r=e[0].length;if(n===`vector-magdir`){let t=e[1].map(e=>(e+360)%360);return[e[0],t]}let[i,a]=e,o=[],s=[];for(let e=0;e<r;e++){let[t,n]=ne([i[e],a[e]]);o.push(t),s.push(n)}return[o,s]}_getRasterTileAlignmentInfo(e,t){return this._rasterTileAlignmentInfo??=De(this.rasterInfo),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,n,r={}){let i={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(i.srcResolution=r.srcResolution,this._updateSourceDataInfo(e,i));let a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:c,pyramidLevel:l}=i,u=s/t,d=c/n,f=l<a&&u*d>=16,p=l===a&&this._requireTooManySrcTiles(s,c,t,n);if(f||p||s===0||c===0){let s=new o({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/n,spatialReference:e.spatialReference}),c=Oe(s,this.rasterInfo.spatialReference,e,i.datumTransformation),p=!c||r.srcResolution&&c.x+c.y<r.srcResolution.x+r.srcResolution.y;if(f&&r.srcResolution&&p){let e=Math.round(Math.log(Math.max(u,d))/Math.LN2)-1;if(a-l+3>=e){let t=2**e;c={x:r.srcResolution.x*t,y:r.srcResolution.y*t}}}c&&(i.srcResolution=c,this._updateSourceDataInfo(e,i))}return this._requireTooManySrcTiles(i.srcWidth,i.srcHeight,t,n)&&(i.srcWidth=0,i.srcHeight=0),i}_requireTooManySrcTiles(e,t,n,r){let{tileInfo:i}=this.rasterInfo.storageInfo,a=Math.ceil(e/i.size[0])*Math.ceil(t/i.size[1]),o=e/n,s=t/r,c=Math.max(1,(n+r)/1024);return a>=Fe*c||o>Pe||s>Pe}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;let{rasterInfo:n}=this,r=n.spatialReference,{srcResolution:i,datumTransformation:a}=t,{pyramidLevel:o,pyramidResolution:s,excessiveReading:c}=Ee(i,n,this.ioConfig.sampling);if(c)return;let l=t.srcExtent||G(e,r,a);if(l==null)return;let u=n.transform;u&&(l=u.inverseTransform(l)),t.srcExtent=l;let{origin:d}=n.storageInfo,{width:f,height:p,ul:m}=be(l,d,s,o);t.pyramidLevel=o,t.pyramidResolution=s,t.srcWidth=f,t.srcHeight=p,t.ul=m}_getRequestOptionsWithSliceId(e){return this.rasterInfo.multidimensionalInfo!=null&&e.sliceId==null&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){let{srcLocation:n,position:r,pyramidLevel:i,useTransposedTile:a}=t,o=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[r]))return{location:n,value:null};let{multidimensionalInfo:s}=this.rasterInfo;if(s==null||!a){let t=e.pixels.map(e=>e[r]),a={location:n,value:t,pyramidLevel:i},o=this._computeMagDirValues(t.map(e=>[e]));return o?.length&&(a.magdirValue=o.map(e=>e[0])),a}let c=e.pixels.map(e=>e.slice(r*o,r*o+o)),l=this._computeMagDirValues(c),{requestSomeSlices:u,identifyOptions:d}=t,f=E(s,d.transposedVariableName);if(u){let e=w(f,d.multidimensionalDefinition,d.timeExtent);c=c.map(t=>e.map(e=>t[e])),l=l?.map(t=>e.map(e=>t[e])),f=e.map(e=>f[e])}let p=e.noDataValues||this.rasterInfo.noDataValue,m={pixels:c,pixelType:e.pixelType},h;return p!=null&&(z(m,p),h=m.mask),{location:n,value:null,dataSeries:f.map((e,t)=>{let n={value:h?.[t]===0?null:c.map(e=>e[t]),multidimensionalDefinition:e.multidimensionalDefinition.map(e=>new k({...e,isSlice:!0}))};return l?.length&&(n.magdirValue=[l[0][t],l[1][t]]),n}),pyramidLevel:i}}};function Le(e,t,n){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n}y([r()],Y.prototype,`_rasterTileAlignmentInfo`,void 0),y([r()],Y.prototype,`_tileFetchQueue`,void 0),y([r({readOnly:!0})],Y.prototype,`_isGlobalWrappableSource`,null),y([r({readOnly:!0})],Y.prototype,`_hasNoneOrGCSShiftTransform`,null),y([r()],Y.prototype,`_openPromise`,void 0),y([r()],Y.prototype,`rasterJobHandler`,null),y([r({readOnly:!0})],Y.prototype,`rasterId`,null),y([r(c)],Y.prototype,`url`,null),y([r({type:String,json:{write:!0}})],Y.prototype,`datasetName`,void 0),y([r({type:String,json:{write:!0}})],Y.prototype,`datasetFormat`,void 0),y([r()],Y.prototype,`hasUniqueSourceStorageInfo`,void 0),y([r()],Y.prototype,`rasterInfo`,void 0),y([r()],Y.prototype,`ioConfig`,void 0),y([r()],Y.prototype,`sourceJSON`,void 0),Y=y([f(`esri.layers.raster.datasets.BaseRaster`)],Y);var Re=40,X=class extends Y{constructor(){super(...arguments),this.datasetFormat=`Function`,this.tileType=`Raster`,this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,n,r={}){let{rasters:i,rasterIds:a}=this.primaryRasters,o=!1,{interpolation:s}=r,c=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&c&&(o=i.length===1&&!r.skipRasterFunction,r={...r,interpolation:`bilinear`,requestRawData:o}),r.requestRawData&&i.length>1&&!this.hasUniqueSourceStorageInfo&&(o=!1,r={...r,requestRawData:!1});let l=i.map(i=>i.fetchPixels(e,t,n,r)),u=await Promise.all(l),d=u.map(e=>e.pixelBlock),f=o||r.requestRawData?u.map(e=>e.srcTilePixelSize):null;if(r.skipRasterFunction||d.every(e=>e==null))return u[0];let p=u.find(e=>e.pixelBlock!=null)?.extent??e,m=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:a}):this.rasterFunction.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:a}),{transformGrid:h}=u[0];if(!o||m==null||h==null){let e=r.noClip?null:this.getClippingGeometry(p.spatialReference);return!r.noClip&&m!=null&&e&&(m=await J(m,p,e)),{...u[0],pixelBlock:m}}let g={rows:h.spacing[0],cols:h.spacing[1]},_;_=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[m],srcMosaicSize:{width:m.width,height:m.height},destDimension:{width:t,height:n},coefs:h.coefficients,sampleSpacing:g,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:s,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:te(m,{width:t,height:n},h.coefficients,g,s);let v=r.noClip?null:this.getClippingGeometry(e.spatialReference);return r.noClip||_==null||v==null||(_=await J(_,e,v)),{extent:e,srcExtent:u[0].srcExtent,pixelBlock:_}}getClippingGeometry(e){let t=this._clippingGeometry.get(`0`);if(!e||!t)return t;let n=Be(e),r=this._clippingGeometry.get(n);return r??(r=e.equals(t.spatialReference)?t:U(t,e),this._clippingGeometry.set(n,r)),r}async _open(e){let{rasterFunction:n}=this;n.isRoot=!0,this.primaryRasters?.rasters?.length?n.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=n.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(e=>e.rasterJobHandler=this.rasterJobHandler));let{rasters:r,rasterIds:i}=this.primaryRasters,a=r.map(t=>t.rasterInfo?void 0:t.open(e));await Promise.all(a);let o=r.map(({rasterInfo:e})=>e),s=n.bind({rasterInfos:o,rasterIds:i});if(n.rawSourceRasterInfos=o,!s.success||o.length===0)throw new t(`raster-function:open`,`cannot bind the function: ${s.error??``}`);let c=n.functionName===`Table`?n:n.functionArguments?.raster;c?.functionName===`Table`&&(n.rasterInfo.attributeTable=_.fromJSON(c.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();let l=o[0];this.hasUniqueSourceStorageInfo=o.length===1||o.slice(1).every(e=>ze(e,l)),this.set(`sourceJSON`,r[0].sourceJSON),this.set(`rasterInfo`,n.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){let t=this.rasterFunction.getClippingGeometries()[0],n=t?.clippingGeometry;if(n&&t.clippingType===`inside`){let{extent:t}=this.rasterInfo,r=await e(()=>import(`./densifyOperator-vVX87Mmx.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14])),a=await e(()=>import(`./differenceOperator-qQi88B6s.js`),__vite__mapDeps([15,1,2,3,4,5,6,7,8,16,10,11,12,13,14])),o=r.execute(i.fromExtent(t),2*(t.width+t.height)/Re);o=U(o,n.spatialReference),n=a.execute(o,n)}this._clippingGeometry.clear(),n&&this._clippingGeometry.set(`0`,n)}};function ze(e,t){let{storageInfo:n,pixelSize:r,spatialReference:i,extent:a}=e,{storageInfo:o,pixelSize:s,spatialReference:c,extent:l}=t;return r.x===s.x&&r.y===s.y&&i.equals(c)&&a.equals(l)&&n.blockHeight===o.blockHeight&&n.blockWidth===o.blockWidth&&n.maximumPyramidLevel===o.maximumPyramidLevel&&n.firstPyramidLevel===o.firstPyramidLevel&&n.pyramidBlockWidth===o.pyramidBlockWidth&&n.pyramidBlockHeight===o.pyramidBlockHeight&&n.pyramidScalingFactor===o.pyramidScalingFactor}function Be(e){return String(e.wkid??e.wkt??e.wkt2)}y([r({type:String,json:{write:!0}})],X.prototype,`datasetFormat`,void 0),y([r()],X.prototype,`tileType`,void 0),y([r()],X.prototype,`rasterFunction`,void 0),y([r()],X.prototype,`primaryRasters`,void 0),X=y([f(`esri.layers.raster.datasets.FunctionRaster`)],X);var Ve=1e3,He=i=>{let u=i,g=class extends u{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=H(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set(`multidimensionalDefinition`,e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()===`none`&&(e=void 0),this._set(`rasterFunction`,e),this.updateRasterFunction()}set url(e){this._set(`url`,x(e,a.getLogger(this)))}get renderer(){if(this.type!==`imagery-tile`)return this.internalRenderer;let{activePresetRendererName:e,presetRenderers:t}=this;return e?(t?.find(({name:t})=>t===e))?.renderer.clone():this.internalRenderer}set renderer(e){this.type===`imagery-tile`&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer(`override`):(this._set(`internalRenderer`,e),this.updateRenderer())}readRenderer(e,t,n){let r=t?.layerDefinition?.drawingInfo?.renderer;return me(r,n)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=b(ae,e).clone();let{serviceRasterInfo:r}=this;if(r==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`serviceRasterInfo must be specified`);let{geometry:i}=e;if(i==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`geometry must be specified`);let a=i,{spatialReference:s}=r;if(!i.spatialReference.equals(s)){await q();let e=i.type===`extent`?G(i,s):U(i,s);if(e==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`geometry cannot be projected to the data source`);a=e}let c=e.pixelSize??new o({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:s}),{extent:l,width:u,height:d}=Me(r,a,c),f=await this.fetchPixels(l,u,d,{...n,interpolation:`nearest`});if(f.pixelBlock==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`failed to fetch pixels`);let p=await J(f.pixelBlock,l,a),m=this._rasterJobHandler;return m?m.computeStatisticsHistograms({pixelBlock:p},n):I(p)}normalizeRasterFetchOptions(e){let{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(t==null)return e;let n=O({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:n,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type===`imagery-tile`&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){let{loaded:e,symbolizer:t,renderer:n}=this;if(!e||!t||!n)return;let{rasterInfo:r}=this.raster,i=N(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=i?.name,o=he(r,a);return this._updateSymbolizer(t,n,a,o)}async applyRenderer(e,t,n){let r=e?.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();let i=this.bandIds??[],{pixelBlock:a}=await this._symbolize({pixelData:e,simpleStretchParams:t,bandIds:i,symbolizer:this.symbolizer},n);return a}getRawDisplayBandIds(){let{bandIds:e,raster:t}=this;if(this.rasterFunction&&H(t)){let n=t.rasterFunction.rawInputBandIds;e=e?.length&&n?.length&&t.rasterInfo.bandCount!==1?e.map(e=>n[Math.min(e,n.length-1)]):n}return e&&e.length>3&&e.every((e,t)=>e===t)?null:e}getTileUrl(e,t,n){return this.raster.datasetFormat===`RasterTileServer`?`${this.url}/tile/${e}/${t}/${n}`:``}getCompatibleTileInfo(e,t,r=!1){if(!this.loaded||t==null)return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;let i=d(e);return n.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,n,r={}){if(_(this),r.requestAsImageElement){let i=this.getTileUrl(e,t,n);return m(i,{responseType:`image`,query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(e=>e.data)}let{serviceRasterInfo:i}=this;if(i.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){let a=r.tileInfo||i.storageInfo.tileInfo,o=this.raster.getTileExtentFromTileInfo(e,t,n,a);if(o)return{extent:o,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type===`raster-shaded-relief`&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,n,r)}async fetchPixels(e,t,n,r={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),n=Math.round(n);let i=await this.raster.fetchPixels(e,t,n,r);return r.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(i.pixelBlock=i.pixelBlock?.extractBands(r.bandIds)),i}async getSamples(e,n){if(await this.load(),(e=b(ue,e).clone()).interpolation&&e.interpolation!==`nearest`)throw new t(`imagery-tile-mixin:get-samples`,`only nearest interpolation is currently supported`);let r=e.mosaicRule?.multidimensionalDefinition,i={...n,multidimensionalDefinition:r},a=(await this._getSampleLocations(e)).map(e=>this.identify(e,i).then(t=>(t.location=e,t))),o=(await Promise.all(a)).flatMap((e,t)=>this._convertRasterIdentifyResultToSample(e,t));return new pe({samples:o})}async identify(e,n={}){await this.load(),e=b(o,e).clone().normalize();let{raster:r,serviceRasterInfo:i}=this;if(i?.multidimensionalInfo!=null&&!(i.hasMultidimensionalTranspose&&!(!T(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};let a=this.multidimensionalSubset?.areaOfInterest;if(a&&!a.contains(e))throw new t(`imagery-tile-mixin:identify`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);let s;if(this.serviceRasterInfo?.storageInfo.isBsqTile){let e=H(r)?this.getRawDisplayBandIds():this.bandIds;s=e?.length?e:void 0}return r.identify(e,{...n,bandIds:s})}hasStandardTime(){let e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!==`standard-time`)return!1;let t=this.multidimensionalDefinition,n=t?.[0]?.variableName;return e.variables.some(e=>e.name===n&&(!t?.[0].dimensionName||e.dimensions.some(e=>e.name===`StdTime`)))}getStandardTimeValue(e){return new Date(j(e)).toISOString()}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo?.multidimensionalInfo;return D(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||=A(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}),this.rasterFunction&&H(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;_(this);let{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,H(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){let{geometry:n}=t;if(n.type===`point`)return[n];let{spatialReference:r,type:i}=n;if(i===`multipoint`)return n.points.map(e=>new o({x:e[0],y:e[1],spatialReference:r}));if(i===`polyline`){let i=n;if(t.sampleCount||t.sampleDistance){let r=await e(()=>import(`./densifyOperator-vVX87Mmx.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14])),a=(await e(async()=>{let{execute:e}=await import(`./lengthOperator-BUhW82a8.js`);return{execute:e}},__vite__mapDeps([17,1,2,3,4,5,6,7,8,18,10,11,12,13,14]))).execute(n,{unit:`meters`}),o=Math.min(t.sampleCount||100,Ve),s=t.sampleDistance;s||=a/(o+(i.paths[0].length===2?1:0)),i=r.execute(n,s,{unit:`meters`})}return i.paths.flatMap(e=>e.map(e=>new o({x:e[0],y:e[1],spatialReference:r})))}let a=Math.min(t.sampleCount||100,Ve),s=n.type===`extent`,c=s?n:n.extent,l=Math.sqrt(c.width*c.height/a),u=c.height/l,d=c.width/l,{xmin:f,ymax:p}=c,m=[];for(let e=0;e<u;e++)for(let t=0;t<d;t++){let i=new o({x:f+(t+.5)*l,y:p-(e+.5)*l,spatialReference:r});(s||n.contains(i))&&m.push(i)}return m}_configDefaultInterpolation(){if(this.interpolation==null){_(this);let{raster:e}=this,t=se(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set(`interpolation`,t)}}_configDefaultRenderer(e=`no`){_(this);let{rasterInfo:t}=this.raster,n=N(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=n?.name,i=le({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=i?.bandIds??ve(t)),!this.renderer||e===`override`){let e=ce(this.raster),n=i?.renderer??de(t,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:e}),a=t.statistics,o=a&&a.length>0?a[0]:null,s=o?.max??0,c=o?.min??0;this.raster.datasetFormat===`WCSServer`&&n.type===`raster-stretch`&&(s>1e24||c<-1e24)&&(n.dynamicRangeAdjustment=!0,n.customStatistics=null,n.stretchType===`none`&&(n.stretchType=`min-max`)),this.renderer=n}let o=fe({...this.renderer.toJSON(),variableName:r}),s=he(t,r);this.symbolizer?(this.symbolizer.rendererJSON=o,this.symbolizer.rasterInfo=s):this.symbolizer=new L({rendererJSON:o,rasterInfo:s});let c=this.symbolizer.bind();if(c.success){if(e===`auto`){let{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(e!=null&&t.type===`raster-colormap`){let e=de(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer(`override`)}else if(t.type===`raster-stretch`){let e=this.bandIds?.length,n=t.customStatistics?.length;!t.dynamicRangeAdjustment&&n&&e&&n!==e&&this._configDefaultRenderer(`override`)}}}else a.getLogger(this).warn(`imagery-tile-mixin`,c.error||`The given renderer is not supported by the layer.`),e===`auto`&&this._configDefaultRenderer(`override`)}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&H(this.raster)){let e=this.raster.rasterFunction.toJSON();!this.rasterFunction&&e&&this._set(`rasterFunction`,ye.fromJSON(e));return}let e,t=this.raster,n=!1;H(t)?(e=t.primaryRasters.rasters,t=e[0],n=!0):e=[t];let{rasterFunction:r}=this;if(r){let n={raster:t};e.length>1&&e.forEach(e=>n[e.url]=e);let i=Ne(r.functionDefinition?.toJSON()??r.toJSON(),n),a=new X({rasterFunction:i});a.rasterJobHandler=this._rasterJobHandler,await a.open(),this.raster=a}else this.raster=t,await t.open();if(this._cachedRendererJson=void 0,!n&&!r)return;let{bandIds:i}=this,{bandCount:a}=this.raster.rasterInfo,o=i?.length?i.some(e=>e>=a):a>=3;i&&(o||this.renderer&&this.renderer.type!==`raster-stretch`)&&this._set(`bandIds`,null),this._configDefaultRenderer(`auto`)}_convertRasterIdentifyResultToSample(e,t){let{rasterInfo:n}=this.raster,r=n.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),i=(n.pixelSize.x+n.pixelSize.y)/2*r;if(!e.dataSeries?.length)return[new ge({location:e.location,pixelValue:e.value,locationId:t,resolution:i})];let a=[];return e.dataSeries.forEach(({value:n,multidimensionalDefinition:r},o)=>{let s={Variables:r[0].variableName,Dimensions:r.flatMap(({dimensionName:e})=>e).join(`,`)};for(let{dimensionName:e,values:t}of r){s[e]=Array.isArray(t[0])?t[0][0]:t[0];let n=t[t.length-1];s[`${e}_Max`]=Array.isArray(n)?n[n.length-1]:n}let c=new ge({location:e.location,pixelValue:n,rasterId:o,locationId:t,resolution:i,attributes:s});a.push(c)}),a}};function _(e){if(!e.raster||!e.serviceRasterInfo)throw new t(`imagery-tile`,`no raster`)}return y([r({clonable:!1})],g.prototype,`_cachedRasterFunctionJson`,void 0),y([r({clonable:!1})],g.prototype,`_compatibleFullExtent`,void 0),y([r({clonable:!1})],g.prototype,`_isConstructedFromFunctionRaster`,void 0),y([r({clonable:!1})],g.prototype,`_rasterFunctionUpdatePromise`,void 0),y([r({type:[h],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType===`Raster`||this.bandIds?.join(`,`)!==`0,1,2`}}}}})],g.prototype,`bandIds`,void 0),y([r({json:{origins:{service:{read:{source:`copyrightText`}}}}})],g.prototype,`copyright`,void 0),y([r({json:{read:!1}})],g.prototype,`fullExtent`,null),y([r({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType===`Raster`||this.interpolation!==`bilinear`}}}}}),s(R)],g.prototype,`interpolation`,void 0),y([r()],g.prototype,`ioConfig`,void 0),y([r({type:[k],json:{write:!0}})],g.prototype,`multidimensionalDefinition`,null),y([r({type:ie,json:{write:!0}})],g.prototype,`multidimensionalSubset`,void 0),y([r()],g.prototype,`raster`,void 0),y([r({type:ye})],g.prototype,`rasterFunction`,null),y([r()],g.prototype,`serviceRasterInfo`,void 0),y([r()],g.prototype,`sourceJSON`,void 0),y([r({readOnly:!0,type:l,json:{read:!1}})],g.prototype,`spatialReference`,void 0),y([r({type:n})],g.prototype,`tileInfo`,void 0),y([r(c)],g.prototype,`url`,null),y([r({types:_e})],g.prototype,`renderer`,null),y([r({types:_e,json:{name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy(){let e=this.renderer?.type===`raster-stretch`&&this.renderer.stretchType===`none`&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType===`Raster`||!e}}},origins:{"web-scene":{types:oe,name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy:e=>({enabled:e&&e.type!==`vector-field`})}}}}})],g.prototype,`internalRenderer`,null),y([p(`internalRenderer`)],g.prototype,`readRenderer`,null),y([r({clonable:!1})],g.prototype,`symbolizer`,void 0),g=y([f(`esri.layers.mixins.ImageryTileMixin`)],g),g};function Z(e,t){if(!e||!t)return[];let n=t;t.includes(`/`)?(n=t.slice(0,t.indexOf(`/`)),t=t.slice(t.indexOf(`/`)+1)):t=``;let r=[];if(t){let i=Z(e,n);for(let e=0;e<i.length;e++)Z(i[e],t).forEach(e=>r.push(e));return r}let i=e.getElementsByTagNameNS(`*`,n);if(!i||i.length===0)return[];for(let e=0;e<i.length;e++)r.push(i[e]||i.item(e));return r}function Q(e,t){if(!e||!t)return null;let n=t;t.includes(`/`)?(n=t.slice(0,t.indexOf(`/`)),t=t.slice(t.indexOf(`/`)+1)):t=``;let r=Z(e,n);return r.length>0?t?Q(r[0],t):r[0]:null}function $(e,t=null){let n=t?Q(e,t):e,r;return n?(r=n.textContent||n.nodeValue,r?r.trim():null):null}function Ue(e,t){let n=Z(e,t),r=[],i;for(let e=0;e<n.length;e++)i=n[e].textContent||n[e].nodeValue,i&&(i=i.trim(),i!==``&&r.push(i));return r}function We(e,t=null){return $(e,t)?.split(` `).map(e=>Number(e))??[]}function Ge(e,t){return Ue(e,t).map(e=>Number(e))}function Ke(e,t){let n=$(e,t);return Number(n)}function qe(e,t){let n=e?.nodeName?.toLowerCase(),r=t.toLowerCase();return n.slice(n.lastIndexOf(`:`)+1)===r}function Je(e){return e.nodeName.slice(e.nodeName.lastIndexOf(`:`)+1)}export{Z as a,$ as c,X as d,Y as f,Ue as i,Ge as l,Q as n,Ke as o,qe as r,We as s,Je as t,He as u};