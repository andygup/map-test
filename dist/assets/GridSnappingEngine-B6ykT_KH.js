import{Aw as e,BT as t,CE as n,Gl as r,Ig as i,Kg as a,Kx as o,Tw as s,VT as c,bu as l,kD as u,sa as d}from"./index-BN8X5Ryz.js";import"./quatf64-D37SEdPg.js";import"./plane-Da5EsY0J.js";import"./vectorStacks-Cuo89CNO.js";import"./dehydratedPoint-CWZQBefp.js";import"./memoize-Dl61_jt0.js";import"./elevationInfoUtils-uoMH3ofe.js";import"./ObjectStack-l5kM7JZu.js";import"./ray-LkJ58wpZ.js";import"./geodesicUtils-D99LxQ6q.js";import{d as f,m as p}from"./LineSnappingHint-CmFAetWF.js";import{t as m}from"./snappingUtils-D3oTIKrZ.js";import"./vec3-B94Y7ih2.js";import"./sphere-d9-4vNcj.js";import"./constraints-Ch5tsKD8.js";import"./SnappingCandidate-DueCLuvH.js";import"./IntersectionSnappingHint-CvQZ8eWi.js";import{t as h}from"./IntersectionSnappingCandidate-C2uVyhEk.js";import{t as g}from"./LineSnappingCandidate-BNbhbOGH.js";import{n as _,r as v,t as y}from"./gridUtils-951JUSRu.js";var b=class extends e{constructor(e){super(e),this.options=null}destroy(){this._set(`options`,null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:s(this.view.rotation??0)}get gridRotation(){return s(this.grid?.rotation??0)}get gridCenter(){let{spatialReference:e,grid:t}=this;if(!t||!e||!i(t.center.spatialReference,e))return null;try{let n=a(t.center,e),r=e.isWrappable&&this.view?.center!=null?l(n.x,this.view.center.x,e):n.x;return p(r,n.y,n.z)}catch(e){return n.getLogger(this).errorOnce(`Grid Snapping - Failed to project grid center.`,e),null}}get offsetScaleFactor(){let{pixelsPerStride:e,grid:t}=this;if(!t||!e)return 1;let{majorLineInterval:n,dynamicScaling:r}=t;return n<1?null:y(n,e,r)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){let{grid:e}=this;return e?o(e.spacing,e.units,`meters`):null}get viewMetersPerPixel(){let{viewMetersPerSRUnit:e}=this;return e==null?null:e*d(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){let{spatialReference:e}=this.view;return this.gridCenter?_(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){let{gridMetersPerStride:e,viewMetersPerPixel:t}=this;return t&&e?e/t:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,t,n){let{options:r,view:i}=this;if(!r?.effectiveGridEnabled||!i.grid||n.feature?.attributes&&m in n.feature.attributes)return[];let a=n.coordinateHelper.arrayToPoint(e),o=r.distance*(n.pointer===`touch`?r.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(a,o)}fetchCandidatesSync(e,t){let n=[],{grid:r,effectiveViewRotation:o,gridRotation:s,gridCenter:c,viewMetersPerPixel:l,viewMetersPerSRUnit:u,offsetScaleFactor:d,spatialReference:f,gridMetersPerStride:m,pixelsPerStride:_}=this;if(!(r&&l&&u&&c&&f&&d&&m&&_)||!r.dynamicScaling&&_<5||!i(e.spatialReference,f))return n;let v=a(e,f),y=p(v.x,v.y,v.z),b=x(y,-s,c,-o),T=m/u*d,E=S(b,T,c),{shouldSnapX:D,shouldSnapY:O}=C(E,b,t,l,u);if(!D&&!O)return[];let k=p((D?E:b)[0],(O?E:b)[1]),A=x(k,s,c,o),j=x(E,s,c,o);if(O){let e=w(E,b,T,`y`),t=x(e,s,c,o);n.push(new g({lineStart:j,lineEnd:t,targetPoint:A,isDraped:!1}))}if(D){let e=w(E,b,T,`x`),t=x(e,s,c,o);n.push(new g({lineStart:j,lineEnd:t,targetPoint:A,isDraped:!1}))}return D&&O&&n.push(new h(A,n[0],n[1],!1)),n}};u([t({constructOnly:!0})],b.prototype,`view`,void 0),u([t()],b.prototype,`options`,void 0),u([t()],b.prototype,`grid`,null),u([t()],b.prototype,`effectiveViewRotation`,null),u([t()],b.prototype,`gridRotation`,null),u([t()],b.prototype,`gridCenter`,null),u([t()],b.prototype,`offsetScaleFactor`,null),u([t()],b.prototype,`spatialReference`,null),u([t()],b.prototype,`gridMetersPerStride`,null),u([t()],b.prototype,`viewMetersPerPixel`,null),u([t()],b.prototype,`viewMetersPerSRUnit`,null),u([t()],b.prototype,`pixelsPerStride`,null),u([t()],b.prototype,`updating`,null),b=u([c(`esri.views.interactive.snapping.GridSnappingEngine`)],b);var x=(e,t,n,i)=>{let a=f(e[0],e[1],e[2]);return r(a,r(a,a,n,t),n,i)},S=(e,t,n)=>{let r=(e[0]-n[0])/t,i=(e[1]-n[1])/t,a=Math.trunc(r),o=Math.trunc(i),s=Math.round(r%1),c=Math.round(i%1),l=n[0]+(a+s)*t,u=n[1]+(o+c)*t;return p(l,u)},C=(e,t,n,r,i)=>{if(r<=0)return{shouldSnapX:!1,shouldSnapY:!1};let a=(e[0]-t[0])/r,o=(e[1]-t[1])/r;return{shouldSnapX:Math.abs(a*i)<n,shouldSnapY:Math.abs(o*i)<n}},w=(e,t,n,r)=>{if(r===`y`){let r=t[0]>e[0]?1:-1;return p(e[0]+n*r,e[1])}let i=t[1]>e[1]?1:-1;return p(e[0],e[1]+n*i)};export{b as GridSnappingEngine};