const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/meshFeatureSet-DWWbWAOC.js","assets/index-BN8X5Ryz.js","assets/index-CWJhHB6-.css","assets/earcut-CEMcWA4Z.js","assets/vec3-B5yu4INg.js","assets/vec4-BLZ_ZPtE.js","assets/vectorStacks-Cuo89CNO.js","assets/quatf64-D37SEdPg.js","assets/quat-C8PgLo31.js","assets/Mesh-CfQb5rZ2.js","assets/computeTranslationToOriginAndRotation-0WDVmpJG.js","assets/projectPointToVector-BkRdoTqD.js","assets/spatialReferenceEllipsoidUtils-qw9wv8RL.js","assets/MeshComponent-BFk18JiH.js","assets/MeshMaterialMetallicRoughness-Bdr2gXmV.js","assets/meshCloneUtils-BXMzy817.js","assets/meshProperties-CbjLwdbT.js","assets/MeshLocalVertexSpace-vomIk0sx.js","assets/MeshTransform-BaPjlQwH.js","assets/axisAngleDegrees-DzAS4tF-.js","assets/MeshVertexAttributes-CBsb_nVo.js","assets/External-C55iwtd6.js","assets/vertexSpaceConversion-Dz87RqR7.js","assets/BufferView-BW77W5ev.js","assets/Util-BQgFCZvD.js","assets/meshVertexSpaceUtils-s2jLb8qI.js","assets/triangulationUtils-DNxIB1ux.js","assets/Indices-tJiSUK6w.js","assets/deduplicate-D-tDe87s.js","assets/plane-Da5EsY0J.js","assets/meshFeatureAttributes-DdbGwu_X.js","assets/intersectionOperator-DBI5U2iq.js","assets/SpatialReference-CfUjvF_j.js","assets/Envelope2D-B7gkUj4e.js","assets/Point2D-DJueHbCy.js","assets/OperatorDefinitions-C5Pat-Jx.js","assets/SimpleGeometryCursor-BILtMaQf.js","assets/Transformation2D-D07KwcEj.js","assets/intersectionOperator-BMuFycv0.js","assets/operatorIntersection-CcDTCsPb.js","assets/apiConverter-Dsm0pxcs.js","assets/jsonConverter-CoA5-zxu.js","assets/FlatGeometry-BsPiiSVP.js","assets/memoryEstimations-D_IbKyOk.js","assets/OptimizedGeometry-BQJ7w5VU.js"])))=>i.map(i=>d[i]);
import{$S as e,$T as t,$p as n,BT as r,CE as i,Cd as a,DT as o,ED as s,Ep as c,GT as l,H as u,Hn as d,Od as f,Qh as p,Rp as m,Td as h,Tp as g,Tu as _,VT as v,Vp as y,Yp as ee,ZS as te,Zp as b,_d as ne,aC as re,bd as x,eT as ie,fT as ae,fv as oe,ha as se,iD as S,iw as ce,kD as C,md as w,pT as T,pd as le,pu as ue,qn as de,sD as fe,tl as pe,vd as me,xd as he,ya as ge,z_ as _e}from"./index-BN8X5Ryz.js";import"./memoryEstimations-D_IbKyOk.js";import"./OptimizedGeometry-BQJ7w5VU.js";import"./OptimizedFeatureSet-CLjmRHYn.js";import"./featureConversionUtils-o9-cJXzl.js";import"./urlUtils-CW4cnJ3W.js";import{n as ve,t as ye}from"./generateRendererUtils-DGV_dTnd.js";import{_ as be,h as xe,l as Se,p as Ce,r as E,s as we,t as D,u as Te}from"./utils-DCGMUq-q.js";import"./pbf-CO6WFbVS.js";import"./pbfQueryUtils-CmJPTrN7.js";import"./queryUtils-8f7b9mi_.js";import"./query-BXrgTHrc.js";import{t as Ee}from"./executeQueryJSON-DJO3NDvM.js";import{t as De}from"./executeQueryPBF-i-SuhVUp.js";import"./queryUtils-DGU5ISbw.js";import{a as Oe,i as O,n as ke,o as k,r as A,t as Ae}from"./utils-Bftaersa.js";import{a as je,i as j,n as Me,o as M,r as Ne,t as N}from"./utils-BizEctJo.js";import{a as Pe,n as Fe,r as Ie,t as Le}from"./FixedIntervalBinParameters-CMgMaWGN.js";import{t as Re}from"./AttributeBinsQuery-sRteDZ8D.js";import{n as ze,t as Be}from"./PivotQuery-BmAzsJNe.js";import{a as Ve,i as P,n as F,r as He,t as Ue}from"./statsWorker-BSyOBmdO.js";function We(e,n){if(!e.view)throw new t(`${n}:missing-parameters`,`'view' parameter is required for binning`);if(e.sqlExpression)throw new t(`${n}:invalid-parameters`,`'sqlExpression' parameter is not supported for binning`);if(e.view.type===`3d`)throw new t(`${n}:invalid-parameters`,`3d view is not supported for binning`)}var I=class e{constructor(){this.connection=null}async open(e){this.connection=await ge(`statsWorker`,{strategy:`distributed`,signal:e})}destroy(){this.connection?.close()}static getInstance(){return e.instance||=new e,e.instance}async summaryStatistics(e,n){if(!this.connection)throw new t(`worker-client:summary-statistics`,`connection is required`);return this.connection.invoke(`summaryStatistics`,{attribute:e,features:n})}async uniqueValues(e,n){if(!this.connection)throw new t(`worker-client:unique-values`,`connection is required`);return this.connection.invoke(`uniqueValues`,{attribute:e,features:n})}async classBreaks(e,n){if(!this.connection)throw new t(`worker-client:class-breaks`,`connection is required`);return this.connection.invoke(`classBreaks`,{attribute:e,features:n})}async histogram(e,n){if(!this.connection)throw new t(`worker-client:histogram`,`connection is required`);return this.connection.invoke(`histogram`,{attribute:e,features:n})}async heatmapStatistics(e,n){if(!this.connection)throw new t(`worker-client:heatmap-statistics`,`connection is required`);return this.connection.invoke(`heatmapStatistics`,{attribute:e,features:n})}};async function Ge(e,t,n,r,i){return Je(t,await Ke(e,t,n,r,i),n,r)}async function Ke(e,t,n,r,i){let a={...r},o=Ye(t,n),c=t.outStatistics?.[0]!=null,l=s(`featurelayer-pbf-statistics`),u=!c||l,d;if(n?.format===`pbf`&&u)try{d=await De(e,o,a,i)}catch(e){if(e.name!==`query:parsing-pbf`)throw e;n.format=`json`}return n?.format!==`json`&&u||(d=await Ee(e,o,a,i)),qe(n?.fieldsIndex,d.fields),d}function qe(e,t){if(e!=null&&t!=null)for(let n of t){let t=e.get(n.name);t&&Object.assign(n,t.toJSON())}}async function Je(t,n,r,i){let a=r?.infoFor3D;if(!Xe(t,a)||a==null||!n.assetMaps||!n.features?.length)return se.fromJSON(n);let{meshFeatureSetFromJSON:o}=await ae(e(()=>import(`./meshFeatureSet-DWWbWAOC.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])),i);return o(t,a,n)}function Ye(e,n){let r=le.from(e);r.sourceSpatialReference=r.sourceSpatialReference??n?.sourceSpatialReference??null,(n?.gdbVersion||n?.dynamicDataSource)&&(r=r===e?r.clone():r,r.gdbVersion=e.gdbVersion||n.gdbVersion,r.dynamicDataSource=e.dynamicDataSource?me.from(e.dynamicDataSource):n.dynamicDataSource);let i=n?.infoFor3D;if(i!=null&&Xe(e,i)){r=r===e?r.clone():r,r.formatOf3DObjects=null;let n=d(i),a=de(i);for(let e of i.queryFormats){if(e===n){r.formatOf3DObjects=e;break}e!==a||r.formatOf3DObjects||(r.formatOf3DObjects=e)}if(!r.formatOf3DObjects)throw new t(`query:unsupported-3d-query-formats`,`Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf`);if(r.outFields==null||!r.outFields.includes(`*`)){r=r===e?r.clone():r,r.outFields??=[];let{originX:t,originY:n,originZ:a,translationX:o,translationY:s,translationZ:c,scaleX:l,scaleY:u,scaleZ:d,rotationX:f,rotationY:p,rotationZ:m,rotationDeg:h}=i.transformFieldRoles;r.outFields.push(t,n,a,o,s,c,l,u,d,f,p,m,h)}}return r}function Xe(e,t){return t!=null&&!0===e.returnGeometry&&e.multipatchOption!==`xyFootprint`&&!e.outStatistics}async function Ze(e,t,n,r){let i=_(e),{source:a,checkValueRange:o}=t,{classificationDefinition:s}=n,c={...n.toJSON(),f:`json`},l=null;if(l=s?.type===`class-breaks-definition`?s.classificationField:s?.attributeField,a){let e={source:a?.toJSON()};c.layer=JSON.stringify(e)}c.classificationDef&&=JSON.stringify(c.classificationDef);let u={query:c};r&&(u={...r,...u});let d={url:i.path,field:l,checkValueRange:o},f=i.path+`/generateRenderer`;return te(f,u).then(e=>Qe(d,e))}function Qe(e,t){let{field:n,checkValueRange:r,url:i}=e,a=t?.data;if(!a)return;if(!r){let e=$e(a);return Promise.resolve(e)}let o=new w({statisticType:`min`,onStatisticField:n}),s=new w({statisticType:`max`,onStatisticField:n}),c=new le({outStatistics:[o,s]});return Ge(i,c).then(e=>{let t=e.features[0].attributes,n=null,r=null;for(let e in t)e.toLowerCase().startsWith(`min`)?n=t[e]:r=t[e];return $e(a,n,r)})}function $e(e,t,n){if(e.type===`classBreaks`){let r=u(e);return{classBreaks:r.classBreakInfos.map((e,i)=>(i===0&&t!=null&&(e.minValue=t),i===r.classBreakInfos.length-1&&n!=null&&(e.maxValue=n),{minValue:e.minValue,maxValue:e.maxValue,label:e.label})),normalizationTotal:r.normalizationTotal}}let{uniqueValueInfos:r}=e;return{uniqueValues:r?.map((e,i)=>(i===0&&t!=null&&(e.value=t),i===r.length-1&&n!=null&&(e.value=n),{count:e.count,value:e.value,label:e.label}))??[]}}var L=class extends ce{constructor(e){super(e),this.classificationDefinition=null,this.where=null}};C([r({json:{name:`classificationDef`,write:!0}})],L.prototype,`classificationDefinition`,void 0),C([r({type:String,json:{write:!0}})],L.prototype,`where`,void 0),L=C([v(`esri.rest.support.GenerateRendererParameters`)],L);var R=class extends ce{constructor(e){super(e),this.type=`unique-value-definition`,this.attributeField=null,this.attributeField2=null,this.attributeField3=null,this.fieldDelimiter=null}get uniqueValueFields(){let e=[];return this.attributeField&&e.push(this.attributeField),this.attributeField2&&e.push(this.attributeField2),this.attributeField3&&e.push(this.attributeField3),e}};C([l({uniqueValueDef:`unique-value-definition`})],R.prototype,`type`,void 0),C([r()],R.prototype,`attributeField`,void 0),C([r()],R.prototype,`attributeField2`,void 0),C([r()],R.prototype,`attributeField3`,void 0),C([r({json:{write:!0}})],R.prototype,`fieldDelimiter`,void 0),C([r({json:{write:!0}})],R.prototype,`uniqueValueFields`,null),R=C([v(`esri.rest.support.UniqueValueDefinition`)],R);var et=`no_dominant_category`;function tt(e){return{expression:nt(e,{returnFieldName:!0,defaultValue:`'${et}'`})}}function nt(e,t){let{returnFieldName:n,defaultValue:r,layer:i}=t,a=[];if(n&&r){let t=e.map(e=>`${e} <= 0`).join(` AND `);a.push(`WHEN ${t} THEN ${r}`)}for(let t of e){let r=e.reduce((e,n)=>(t!==n&&e.push(`${t} > ${n}`),e),[]).join(` AND `),o=i&&ke(i,t),s=n&&`'${t}'`?`'${t}'`:o?A(t):t;a.push(`WHEN ${r} THEN ${s}`)}return`CASE ${a.join(` `)} ELSE ${r||`0`} END`}function rt(e){return e&&e.map(e=>`$feature["${e}"];`).join(`
`)+`
`||``}function it(e,t=!1){let n=e.map(e=>`"${e}"`);return`\n  var fieldNames = [ ${n.join(`, `)} ];\n  var numFields = ${n.length};\n  var maxValueField = null;\n  var maxValue = -Infinity;\n  var value, i, totalValue = null;\n\n  for(i = 0; i < numFields; i++) {\n    value = $feature[fieldNames[i]];\n\n    if(value > 0) {\n      if(value > maxValue) {\n        maxValue = value;\n        maxValueField = fieldNames[i];\n      }\n      else if (value == maxValue) {\n        maxValueField = null;\n      }\n    }\n    ${t?`
  if(value != null && value >= 0) {
    if (totalValue == null) { totalValue = 0; }
    totalValue = totalValue + value;
  }
  `:``}\n  }\n  `}function at(e){let t=it(e);return`\n  ${rt(e)}\n  ${t}\n  return maxValueField;\n  `}var z=class extends p{constructor(e){super(e),this.adapterName=`layer-adapter`}};C([r({readOnly:!0})],z.prototype,`adapterName`,void 0),C([r({constructOnly:!0})],z.prototype,`layer`,void 0),C([r()],z.prototype,`geometryType`,void 0),C([r()],z.prototype,`objectIdField`,void 0),C([r()],z.prototype,`supportsSQLExpression`,void 0),C([r()],z.prototype,`hasQueryEngine`,void 0),C([r()],z.prototype,`minScale`,void 0),C([r()],z.prototype,`maxScale`,void 0),C([r()],z.prototype,`fullExtent`,void 0),z=C([v(`esri.smartMapping.support.adapters.LayerAdapter`)],z);var ot=/_value$/i,st=Math.LOG10E,ct={SECOND:1e3,MINUTE:6e4,HOUR:36e5};function B(e){return e.map(e=>e.toJSON())}function lt(e,t){let n=[],r=e.layer,i=`featureReduction`in r?r.featureReduction:null,a=i?.type===`binning`,o=i!=null&&`fields`in i?i.fields?.map(e=>e.name?.toLowerCase()).filter(Boolean):[];if(!a||!t)return n;for(let e of t)o.includes(e.toLowerCase())||n.push(e);return n}function V(e,t,n){let r=[];if(t)for(let i of t){let t=e.getField(i);t&&n&&`availableFields`in n&&!n.availableFields?.includes(t.name)&&r.push(t.name)}return r}function H(e,t){let n=e&&e.features;if(n?.length===0)return{avg:null,count:0,max:null,median:null,min:null,nullcount:0,stddev:null,sum:null,variance:null};let r=n?.[0]?.attributes,i={};for(let e in r)i[e.replace(ot,``).toLowerCase()]=r[e];return i.totalcount!=null&&i.totalcount>=i.count&&(i.nullcount=i.totalcount-i.count),delete i.totalcount,i.min===i.max&&i.min!=null&&i.stddev==null&&(i.stddev=i.variance=0),t&&([`min`,`max`,`avg`,`stddev`,`sum`,`variance`].forEach(e=>{i[e]!=null&&(i[e]=Math.ceil(i[e]))}),i.min===i.max&&i.min!=null&&(i.avg=i.min,i.stddev=i.variance=0)),i}function ut(e){let t=[],n=e.classBreaks,r=n[0].minValue,i=n[n.length-1].maxValue;n.forEach(e=>{t.push([e.minValue,e.maxValue])});let a={field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,layer:e.layer};return{min:r,max:i,intervals:t,sqlExpr:U(a),excludeZerosExpr:e.where,normTotal:e.normalizationTotal}}function U(e){let{field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,layer:a}=e,o=ke(a,t),s=t;return n===`percent-of-total`?s=`((${o?A(t):t} / ${i}) * 100)`:n===`log`?s=`(log(${t}) * ${st})`:n===`field`?s=`(${o?A(t):t} / ${r})`:n===`natural-log`?s=`(log(${o?A(t):t}))`:n===`square-root`&&(s=`(power(${o?A(t):t}, 0.5))`),s}function dt(e,t){let n;if(t=t.toLowerCase(),e){for(let r in e)if(r.toLowerCase()!==t){n=e[r];break}}return n}function W(e,t){let n;if(t=t.toLowerCase(),e){for(let r in e)if(r.toLowerCase()===t){n=e[r];break}}return n}function ft(e,t,n,r,i){let a={},o=`countOFExpr`;e&&e.features&&e.features.forEach(e=>{let t=e.attributes,n=dt(t,o),r=W(t,o);n!=null&&r!=null&&n!==0&&(a[n]=r)});let s=[];return Ce(t,n,r).forEach((e,t)=>{let n=(t+1).toString();s.push({minValue:e[0],maxValue:e[1],count:a.hasOwnProperty(n)?a[n]:0})}),{bins:s,minValue:t,maxValue:n,normalizationTotal:i}}async function pt(e,t){let n=e&&e.features,{field:r,field2:i,field3:a,fieldDelimiter:o,layer:s,view:c,signal:l,labels:u}=t,d=`countOF${(!r||!i)&&r||`Expr`}`,f={},p=!1;for(let e of n){let t=e.attributes,n=W(t,d),s=r?W(t,r):dt(t,d),c=i?W(t,i):null,l=a?W(t,a):null;s===null&&n===0&&(p=!0),(s==null||typeof s==`string`&&s.trim()===``)&&(s=null),i&&(c==null||typeof c==`string`&&c.trim()===``)&&(c=null),a&&(l==null||typeof l==`string`&&l.trim()===``)&&(l=null);let u=s;i&&(u=`${xe(u)}${o}${xe(c)}`,a&&(u=`${u}${o}${xe(l)}`)),f[u]==null?f[u]={count:n,data:u}:f[u].count=f[u].count+n}if(r&&p){let e=r+` is NULL`;try{let t=await s.queryFeatureCount({whereClause:e,view:c,signal:l});return f.null.count=f.null.count+t,mt(f,u)}catch{return T(l),mt(f,u)}}return mt(f,u)}function mt(e,t){if(t)for(let n in e)e[n].label=t[n];return{count:e}}async function ht(e,t,n){let r=e?n.getField(e):null,i=r?n.getFieldDomain(r.name):null;if(i)return i;let{uniqueValueInfos:o}=await n.uniqueValues({field:e,sqlWhere:t.sqlWhere,features:t.features,useFeaturesInView:t.useFeaturesInView,view:t.view,signal:t.signal}),s=o.map(e=>new h({code:e.value}));return new a({codedValues:s})}async function G(e,t){if(!e.returnAllCodedValues)return[];let{field:n,field2:r,field3:i}=e;if(n&&!r){let e=n?t.getField(n):null,r=e?t.getFieldDomain(e.name):null;return r?[r]:[]}let a=[];return n&&(a.push(ht(n,e,t)),r&&(a.push(ht(r,e,t)),i&&a.push(ht(i,e,t)))),Promise.all(a)}function gt(e,t){return Ae(e,new Date(0),t,`milliseconds`).sqlExpression}function _t(e,t){return`EXTRACT(${t} FROM ${e}) * ${ct[t]}`}function vt(e){return e?A([`HOUR`,`MINUTE`,`SECOND`].map(t=>`(${_t(e,t)})`).join(` + `)):null}function K(e){return{viewingMode:e.type===`2d`?`map`:e.viewingMode,scale:e.scale,spatialReference:e.spatialReference?.toJSON()}}function yt(e,t){let n=new Set(e.map(e=>e.value)),r=t.filter(e=>!n.has(e));for(let t of r)e.push({value:t,count:0});e.sort((e,n)=>t.indexOf(e.value)-t.indexOf(n.value));for(let t of e)t.value===`no_dominant_category`&&(t.value=null);return{predominantCategoryInfos:e}}function bt(e){let t=`featureReduction`in e?e.featureReduction:null;return((t!=null&&`fields`in t?t.fields:null)??[]).map(t=>{let n=xt(t,e.fieldsIndex);return n?new x({type:n,name:t.name,alias:t.alias}):null}).filter(fe)}function xt(e,t){switch(e.statisticType){case`avg`:case`avg_angle`:return`double`;case`count`:return`integer`;case`min`:case`max`:case`sum`:return e.onStatisticField?t.get(e.onStatisticField)?.type??null:e.onStatisticExpression?e.onStatisticExpression.returnType===`string`?null:`double`:null;case`mode`:return e.onStatisticField?t.get(e.onStatisticField)?.type??null:e.onStatisticExpression?e.onStatisticExpression.returnType===`string`?`string`:`double`:null;default:return null}}function St(e,t){return O(t)?gt(e,t?.name):b(t)?vt(t?.name):null}function Ct(e,t,n){let r=null;for(let i of n){let n=i?e.getField(i):null,a=q(e,{...t,field:i,outStatisticTypes:{include:[`min`,`max`,`sum`,`count`]}},n,!0,!0);r?r.outStatistics=r.outStatistics.concat(a.outStatistics):r=a}return r.where=e.createQuery()?.where,r}function wt(e,t,n,r){return t.map(t=>{let i=new w,a=null,o=null,s=`${t}_value${r?`_${r}`:``}`;if(t===`variance`)a=`var`,o=n;else if(t===`nullcount`){let t=e.objectIdField;a=`count`,o=t&&e.getField(t)?t:`1`,s=`totalcount_value`}else t===`median`?(a=`percentile-continuous`,o=n,i.statisticParameters={value:.5}):(a=t,o=n);return i.statisticType=a,i.onStatisticField=o,i.outStatisticFieldName=s,i})}function q(e,t,n,r=!0,i=!1){let{field:a,normalizationType:o,normalizationField:s,normalizationTotal:c,minValue:l,maxValue:u,filter:d}=t,f=e.supportsSQLExpression?St(e,n)||t.sqlExpression:null,p=U({field:a,normalizationType:o,normalizationField:s,normalizationTotal:c,layer:e}),m=f||p,h=m?j(m,l,u):null,_=N({field:a,normalizationField:s,normalizationType:o}),v=M(t.sqlWhere,_),y=M(v,h),ee=Te({normalizationField:s,normalizationType:o,sqlExpression:f,supportsSQLExpression:e.supportsSQLExpression,minValue:l,maxValue:u}),te=g(e.getField(a??void 0)),{include:b,exclude:ne}=t.outStatisticTypes||{},re=Se.filter(e=>(!b||b.includes(e))&&(!ne||!ne.includes(e))&&(e===`nullcount`?ee:!te||e===`count`)&&(e!==`median`||r)),x=e.createQuery();return x.where=M(x.where,y),x.sqlFormat=f?`standard`:null,x.outStatistics=wt(e,re,m,i?a:void 0),J(x,d),x}function Tt(e,t,n=!0){let{fields:r,filter:i}=t,{include:a,exclude:o}=t.outStatisticTypes||{},s=Se.filter(e=>(!a||a.includes(e))&&(!o||!o.includes(e))&&(e!==`median`||n)),c=new Be;c.where=M(e.createQuery()?.where,t.sqlWhere)??void 0;let l=`new_value`;return c.outPivots=[new ze({sourceFields:r,valueFieldName:l})],c.outStatistics=wt(e,s,l),J(c,i),c}function J(e,t){t&&(e.geometry=t.geometry,e.spatialRelationship=t.spatialRelationship,e.timeExtent=e.timeExtent?.intersection(t.timeExtent)??t.timeExtent,e.distance=t.distance,e.units=t.units)}function Et(e,t){let{field:n,field2:r,field3:i,sqlExpression:a}=t,o=!(!n||!r),s=e.createQuery();return s.where=M(s.where,t.sqlWhere),s.sqlFormat=a?`standard`:null,s.outStatistics=[Dt(o?null:n,o?`1`:a)].filter(Boolean),s.groupByFieldsForStatistics=[n||a,r,i].filter(Boolean),J(s,t.filter),s}function Dt(e,t){let n=`countOF`+(e||`Expr`),r=new w;return r.statisticType=`count`,r.onStatisticField=t?`1`:e,r.outStatisticFieldName=n,r}function Y(e,t,n,r=10,i,a,o){let{min:s,max:c,normTotal:l,excludeZerosExpr:u}=t,d=t.intervals||Ce(s,c,r),f=t.sqlExpr||n;return Ot(e,d,f,u,i,a,o).then(e=>({bins:e.map((e,t)=>({minValue:d[t][0],maxValue:d[t][1],count:e.status===`fulfilled`?e.value:0})),minValue:s,maxValue:c,normalizationTotal:l}))}function Ot(e,t,n,r,i,a,o){let s=[],c=t.length;for(let e=0;e<c;e++){let i=M(r,M(n+` >= `+t[e][0],t[e][1]===null?``:n+(e===c-1?` <= `:` < `)+t[e][1]));s.push(i)}return Promise.allSettled(s.map(t=>e.queryFeatureCount({whereClause:t,view:i,filter:a,signal:o})))}var kt=`countOFExpr`,At=`lowerBoundary`,jt=`upperBoundary`;function Mt(e,t,n){let r=e.valueExpression||e.sqlExpression,i=e.signal;if(!r){let{field:r,normalizationType:a,normalizationField:o}=e,s=r?t.getField(r):null,c=O(s)||b(s);return{sqlExpression:c?St(t,s):U({field:r,normalizationType:a,normalizationField:o,normalizationTotal:n,layer:t}),sqlWhere:c?null:e.sqlWhere||N({field:r,normalizationType:a,normalizationField:o}),filter:e.filter,signal:i}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,filter:e.filter,signal:i}}async function Nt(e,t,n){let{field:r,normalizationType:i,normalizationField:a,signal:o}=e,s=N({field:r,normalizationType:i,normalizationField:a}),c=new L({classificationDefinition:be({field:r,normalizationType:i,normalizationField:a,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numBins||10}),where:M(s,n)});return t.generateRenderer(c,o).then(e=>{let{normalizationTotal:n,classBreaks:o}=e;return ut({field:r,normalizationType:i,normalizationField:a,normalizationTotal:n,classBreaks:o,where:s,layer:t})})}async function Pt(e,n,r,i,a){let{field:o,sqlExpression:s,normalizationField:c,classificationMethod:l,normalizationType:u}=e,d=o?n.getField(o):null,f=b(d),p=m(d)||f,h=e.numBins||10;if(p){if(u||l)throw new t(`${n.adapterName}:not-supported`,`NormalizationType and classificationMethod are not supported for date-only and time-only fields`);let e=(i-r)/h/1e3,a=e/86400;return new Ie({field:o,expression:s,interval:{unit:f?`seconds`:`days`,value:Math.ceil(f?e:a)},start:r,end:i})}if(l===`defined-interval`)return new Le({field:o,expression:s,normalizationField:c,normalizationTotal:a,normalizationType:u,interval:e.definedInterval??Math.ceil((i-r)/h),start:u?null:r,end:u?null:i,normalizationMinValue:u?r:null,normalizationMaxValue:u?i:null});if(l===`manual`)throw new t(`${n.adapterName}:not-supported`,`Layer does not support manual classificationMethod`);if(l===`natural-breaks`||l===`quantile`||l===`standard-deviation`){let i=U({field:o,normalizationField:c,normalizationTotal:a,normalizationType:u,layer:n}),l=e.minValue!==null&&e.maxValue!==null?j(i,e.minValue,e.maxValue):void 0,d=await Nt(e,n,l);if(!d.intervals)throw new t(`${n.adapterName}:invalid`,`Invalid intervals returned from generate renderer`);let f=[r,...d.intervals.map(e=>e[1])];return new Fe({field:u?null:o,expression:u?i:s,boundaries:f})}return new Pe({field:o,normalizationField:c,normalizationTotal:a,normalizationType:u,expression:s,numBins:h,start:u?null:r,end:u?null:i,normalizationMinValue:u?r:null,normalizationMaxValue:u?i:null})}function Ft(e,t,n,r){return n!=null&&r!=null?Promise.resolve({min:n,max:r}):t.summaryStatistics({...e,outStatisticTypes:{include:[`min`,`max`]}}).then(e=>({min:e.min,max:e.max}))}async function It(e,t,n,r){let{field:i,minValue:a,maxValue:o,filter:s,view:l}=e,u=i?t.getField(i):null,d=c(u)||ee(u),f=Mt(e,t,n),{min:p,max:m}=await Ft(f,t,a,o);if(p==null||m==null)return{query:null,min:p,max:m};let h=new w({statisticType:`count`,outStatisticFieldName:kt,onStatisticField:`1`}),{where:g,timeExtent:_}=r||{},v=M(g,f.sqlWhere),y=new Re({binParameters:await Pt(e,t,p,m,n),outStatistics:[h],binOrder:e.sortOrder,where:v,timeExtent:_,lowerBoundaryAlias:`lowerBoundary`,upperBoundaryAlias:`upperBoundary`,outTimeZone:l?.timeZone&&d?_e(l.timeZone):null});return J(y,s),{query:y,min:p,max:m}}function Lt(e,t=!1){return typeof e==`string`?(t?new Date(`1970-01-01T${e}Z`):new Date(e)).getTime():e}function Rt(e,t,n){let r=b(t);return{...n,bins:e.features.map(e=>({minValue:Lt(e.attributes[At],r),maxValue:Lt(e.attributes[jt],r),count:e.attributes[kt]}))}}function zt(e,t,n){let{valueExpression:r,view:i}=e,{featuresJSON:a,graphics:o,fieldInfos:s}=t,c={field:e.field,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:n,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&i&&(a||o)&&(c.viewInfoParams=K(i),c.timeZone=i.timeZone,c.fieldInfos=s),c}var Bt=5,X=null,Z=class extends z{constructor(){super(...arguments),this._hasLocalSource=!1,this.adapterName=`in-memory-layer-adapter`}destroy(){this.workerClient?.destroy()}async _waitForLayerViewUpdate(e){if(!e)throw new t(`${this.adapterName}:insufficient-data`,`layerView is required to fetch the features`);let n=new AbortController,r=oe(()=>!e.updating,n.signal);await ie(r,5e3,n).catch(e=>{throw i.getLogger(this).warn(`LayerView is taking too long to update. Aborting fetch from layerView.`),e})}async _fetchFeatureSetFromMemory(e,n,r){let i=this.layer;if(this._hasLocalSource&&`queryFeatures`in i)return i.queryFeatures(e);if(!n)throw new t(`${this.adapterName}:insufficient-data`,`view is required to fetch the features from layerView`);let a=await n.whenLayerView(this.layer);return await this._waitForLayerViewUpdate(a),a.queryFeatures(e,{signal:r})}async _fetchFeaturesFromMemory(e,n,r,i){let a=this.layer,o=i===`json`;if(this._hasLocalSource&&`queryFeatures`in a){let e=await a.queryFeatures(n);return o?B(e.features):e.features}if(await this._waitForLayerViewUpdate(e),o&&`queryFeaturesJSON`in e&&e.queryFeaturesJSON){let{features:t}=await e.queryFeaturesJSON(n,{signal:r});return t}if(!(`queryFeatures`in e))throw new t(`${this.adapterName}:not-supported`,`'queryFeatures' is not supported on the layerView`);let s=await e.queryFeatures(n,{signal:r});return o?B(s.features):s.features}_fetchFeaturesForStats(e,t){return k({field:e.field,field2:e.field2,field3:e.field3,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then(n=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,filter:e.filter,requiredFields:n,signal:e.signal},t))}async _summaryStatsFromClientQuery(e,t){let{view:n,signal:r}=e,i=q(this,e,t),a=await this._fetchFeatureSetFromMemory(i,n,r),o=H(a,O(t)||b(t));return E(o,e.outStatisticTypes)}async _getNormalizationTotalFromMemory(e,n,r){let{featuresJSON:i,graphics:a,layerView:o,query:s}=n,c={include:[`sum`]},l=(!i&&!a&&o&&`querySummaryStatistics`in o?await o.querySummaryStatistics(s,{field:e},{signal:r}):i?await this.workerClient.summaryStatistics({field:e,outStatisticTypes:c},i):await F({attribute:{field:e,outStatisticTypes:c},features:a??[]})).sum;if(l==null)throw new t(`${this.adapterName}:invalid`,`invalid normalizationTotal`);return l}async _summaryStatsFromMemory(e,t){let{view:n,field:r,valueExpression:i,normalizationType:a,signal:o}=e,s={field:r,valueExpression:i,normalizationType:a,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes},{featuresJSON:c,graphics:l,layerView:u,query:d,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`querySummaryStatistics`});return i&&n&&(c||l)&&(s.fieldType=t?.type?he.toJSON(t.type):null,s.viewInfoParams=K(n),s.timeZone=n.timeZone,s.fieldInfos=f),a===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:c,graphics:l,layerView:u,query:d},o)),!c&&!l&&u&&`querySummaryStatistics`in u?u.querySummaryStatistics(d,s,{signal:o}):c?this.workerClient.summaryStatistics(s,c):F({attribute:s,features:l})}async _getFilteredFeatures(t,n){let r=t,i=n?.geometry;if(n?.spatialRelationship===`intersects`&&i){let n=await e(()=>import(`./intersectionOperator-DBI5U2iq.js`),__vite__mapDeps([31,32,1,2,33,34,35,36,37,38,39,40,41,42,43,44]));r=t.filter(({geometry:e})=>!(!e||!n.execute(e,i)))}return t.length&&`declaredClass`in t[0]&&t[0].declaredClass===`esri.Graphic`?{graphics:r}:{featuresJSON:r}}async _processStatsFromMemoryParams(e){let{features:t,filter:r}=e;if(t?.length)return this._getFilteredFeatures(t,r);let{view:i,field:a,field2:o,field3:s,normalizationField:c,valueExpression:l,layerViewFunc:u,signal:d}=e,f=e.returnGeometry;if(f==null&&l){if(!X){let{arcadeUtils:e}=await n();X=e}let e=X.hasGeometryOperations(l);e&&await X.enableGeometryOperations(),f=e}let p=null,m=null,h=null,g=null,_=null;if(i)try{let e=this.layer.type===`subtype-sublayer`?this.layer.parent:this.layer;p=await i.whenLayerView(e),m=u!=null&&p!=null&&u in p&&typeof p[u]==`function`}catch{m=!1}if(m)try{await this._waitForLayerViewUpdate(p);let e=await k({field:a,field2:o,field3:s,normalizationField:c,valueExpression:l});V(this,e,p).length?m=!1:(h=this.layer.createQuery(),h.outFields=e,h.returnGeometry=!1,J(h,r)),p.suspended&&(m=!1)}catch{m=!1}return m||(g=await this._fetchFeaturesForStats({field:a,field2:o,field3:s,valueExpression:l,normalizationField:c,returnGeometry:f,filter:r,view:i,signal:d},`json`),_=(await k({valueExpression:l})).map(e=>this.getField(e)?.toJSON()).filter(Boolean)),{layerView:p,query:h,featuresJSON:g,fieldInfos:_}}async _uvFromClientQuery(e,t){let{view:n,signal:r}=e,i=Et(this,e),a=await this._fetchFeatureSetFromMemory(i,n,r),o=await pt(a,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,view:e.view,signal:e.signal});return D(o,t,e.returnAllCodedValues,`,`)}async _uvFromMemory(e,t){let{view:n,field:r,valueExpression:i,returnAllCodedValues:a,signal:o}=e,{featuresJSON:s,graphics:c,layerView:l,query:u,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryUniqueValues`}),f={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,valueExpression:i,domains:t,returnAllCodedValues:a};return i&&n&&(s||c)&&(f.viewInfoParams=K(n),f.timeZone=n.timeZone,f.fieldInfos=d),!s&&!c&&l&&`queryUniqueValues`in l?l.queryUniqueValues(u,f,{signal:o}):s?this.workerClient.uniqueValues(f,s):He({attribute:f,features:c})}_histogramForField(e){let n=null;return n=e.minValue!=null&&e.maxValue!=null?Promise.resolve({min:e.minValue,max:e.maxValue}):this.summaryStatistics({...e,outStatisticTypes:{include:[`min`,`max`,`count`]}}).then(e=>{if(!e.count)throw new t(`${this.adapterName}:insufficient-data`,`Either the layer has no features or none of the features have data for the field`);return{min:e.min,max:e.max}}),n.then(t=>Y(this,{min:t.min,max:t.max},e.field,e.numBins??void 0,e.view,e.filter,e.signal))}async _histogramFromQueryAttributeBinsFromMemory(e){let{field:t,normalizationType:n,signal:r}=e,i=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAttributeBins`}),{featuresJSON:a,graphics:o,layerView:s,query:c}=i,l=n===`percent-of-total`?e.normalizationTotal??await this._getNormalizationTotalFromMemory(t,i,r):void 0;if(!s||!(`queryAttributeBins`in s)||a||o){let t=zt(e,i,l);return a?this.workerClient.histogram(t,a):P({attribute:t,features:o})}let{query:u,min:d,max:f}=await It(e,this,l,c);if(!u)return{bins:[],minValue:d,maxValue:f,normalizationTotal:l};let p=await s.queryAttributeBins(u,{signal:r});return Rt(p,t?this.getField(t):null,{minValue:d,maxValue:f,normalizationTotal:l})}async _histogramFromMemory(e){let{field:t,signal:n}=e,r=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryHistogram`}),{featuresJSON:i,graphics:a,layerView:o,query:s}=r,c=e.normalizationType===`percent-of-total`?e.normalizationTotal??await this._getNormalizationTotalFromMemory(t,r,n):void 0,l=zt(e,r,c);return!i&&!a&&o&&`queryHistogram`in o?o.queryHistogram(s,l,{signal:n}):i?this.workerClient.histogram(l,i):P({attribute:l,features:a})}_classBreaksFromInterpolation(e){let{minValue:t,maxValue:n}=e,r=e.numClasses||Bt,i=[],a=(n-t)/r;for(let e=0;e<r;e++){let n=t+e*a;i.push({minValue:n,maxValue:n+a})}i[r-1].maxValue=n;let o={classBreaks:i,normalizationTotal:e.normalizationTotal},s=we(o,e.classificationMethod);return Promise.resolve(s)}async _classBreaksFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryClassBreaks`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryClassBreaks`in s?s.queryClassBreaks(c,u,{signal:i}):a?this.workerClient.classBreaks(u,a):Ue({attribute:u,features:o})}async _heatmapStatsFromMemory(e){let{view:t,field:n,radius:r,signal:i}=e;o(t,`InMemoryLayerAdapter: must have a view`);try{let n=await t.whenLayerView(this.layer);if(`queryHeatmapStatistics`in n&&!n.updating&&!e.filter)return await n.queryHeatmapStatistics({field:e.field,radius:e.radius})}catch{T(i)}let{featuresJSON:a,graphics:s}=await this._processStatsFromMemoryParams({...e,returnGeometry:!0}),c=new ne({extent:t.extent,tolerance:t.type===`2d`?t.state.resolution:t.pixelSizeAt?.(t.center)}),l={field:n,radius:r,transform:pe(c),spatialReference:t.spatialReference?.toJSON(),size:t.size};return a?.length||s?.length?a?this.workerClient.heatmapStatistics(l,a):Ve({attribute:l,features:s}):{min:null,max:null}}getField(e=``){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}createQuery(){return this.layer.createQuery()}async summaryStatistics(e){let{field:n,valueExpression:r,sqlExpression:i,features:a,view:o}=e,s=n?this.getField(n):null,c=!!r,l=o?.type===`3d`;if(!r&&i&&!this.supportsSQLExpression)throw new t(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return c||a||l?this._summaryStatsFromMemory(e,s):this._summaryStatsFromClientQuery(e,s)}async uniqueValues(e){let{valueExpression:n,sqlExpression:r,features:i,view:a}=e,o=await G(e,this),s=!!n,c=a?.type===`3d`;if(!n&&r&&!this.supportsSQLExpression)throw new t(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return s||i||c?this._uvFromMemory(e,o):this._uvFromClientQuery(e,o)}async histogram(e){let{features:n,valueExpression:r,normalizationType:i,sqlExpression:a}=e,o=n||!!r;if(!r&&a&&!this.supportsSQLExpression)throw new t(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return o||i?this._histogramFromMemory(e):this._histogramForField(e)}async classBreaks(e){return!1===e.analyzeData?this._classBreaksFromInterpolation(e):this._classBreaksFromMemory(e)}async queryFeatureCount(e){let{whereClause:n,view:r,signal:i}=e;if(!r)throw new t(`${this.adapterName}:insufficient-data`,`view is required to fetch the features from layerView`);let a=this.layer.createQuery();a.where=M(a.where,n);let o=await r.whenLayerView(this.layer);return await oe(()=>!o.updating,i),o.queryFeatureCount(a,{signal:i})}async generateRenderer(e,n){throw new t(`${this.adapterName}:not-supported`,`Layer does not support generateRenderer operation`)}async predominantCategories(e){let{fields:t,view:n,signal:r,filter:i}=e,a=at(t),o=await this._uvFromMemory({valueExpression:a,view:n,signal:r,filter:i});return yt(o.uniqueValueInfos,t)}async heatmapStatistics(e){return this._heatmapStatsFromMemory(e)}async getSampleFeatures(e,n){let{view:r,sampleSize:i,requiredFields:a,returnGeometry:o,filter:s,signal:c}=e,l=this.layer.createQuery();if(l.outSpatialReference=r?.spatialReference,l.returnGeometry=!!o,l.outFields=a,J(l,s),!r)throw new t(`${this.adapterName}:not-supported`,`view is required to get sample features for Layer`);let u=await r.whenLayerView(this.layer);if(V(this,a,u).length)throw new t(`${this.adapterName}:not-supported`,`Required fields need to be passed in the outFields for Layer`);let d=await this._fetchFeaturesFromMemory(u,l,c,n),f=i!=null&&i>0&&i<=d.length?i:d.length;return S(d,f,1)}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.type===`stream`||!!t.capabilities?.query?.supportsSqlExpression,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=`fullExtent`in t?t.fullExtent:t.parent?.fullExtent,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};C([r({readOnly:!0})],Z.prototype,`adapterName`,void 0),C([r({constructOnly:!0})],Z.prototype,`layer`,void 0),Z=C([v(`esri.smartMapping.support.adapters.InMemoryLayerAdapter`)],Z);var Vt=5,Ht=2e4,Ut=4e5,Q=class extends Z{constructor(){super(...arguments),this.adapterName=`feature-layer-adapter`}_isStatsSupportedOnService(){let e=this.layer;if(!e.capabilities?.query?.supportsStatistics||this.geometryType===`multipatch`&&!re(e.url)&&e.version<10.5)throw new t(`${this.adapterName}:not-supported`,`Layer does not support statistics query`);return Promise.resolve()}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then(e=>e.features)}_fetchFeaturesJSONFromService(e,t){return this._fetchFeaturesFromService(e,t).then(B)}_summaryStatsFromGenRend(e){let t=e.normalizationType,n=e.normalizationField;return this.classBreaks({field:e.field,numClasses:Vt,classificationMethod:`standard-deviation`,standardDeviationInterval:.25,normalizationType:t,normalizationField:t===`field`?n:void 0,minValue:e.minValue,maxValue:e.maxValue,filter:e.filter,signal:e.signal}).then(t=>{let n,r,i;if(t.classBreakInfos?.some(e=>(e.hasAvg&&(n=e),!!n)),n){let e=n.maxValue-n.minValue;r=n.minValue+e/2,i=4*e}let a={min:t.minValue,max:t.maxValue,avg:r,stddev:i};return E(a,e.outStatisticTypes)})}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),e.normalizationType===`percent-of-total`&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType,e.filter));let n=O(t)||b(t),r=`capabilities`in this.layer?this.layer.capabilities:null,i=q(this,e,t,r?.query?.supportsPercentileStatistics??!1),a=await this.layer.queryFeatures(i,{signal:e.signal}),o=H(a,n);return E(o,e.outStatisticTypes)}async _summaryStatsForFieldsBasic(e){let{outStatisticTypes:t,fields:n}=e,r=[];for(let t=0;t<n.length;t+=50){let i=n.slice(t,t+50),a=Ct(this,e,i);r.push(this.layer.queryFeatures(a,{signal:e.signal}))}let i=(await Promise.all(r)).flatMap(e=>e.features).map(e=>e.attributes).reduce((e,t)=>Object.assign(e,t),{}),a={};for(let e in i){let t=e.match(/^(\w+)_value_/);if(i[e]==null||!t)continue;switch(t[1]){case`min`:a.min=a.min==null?i[e]:Math.min(a.min,i[e]);break;case`max`:a.max=a.max==null?i[e]:Math.max(a.max,i[e]);break;case`sum`:a.sum=(a.sum||0)+i[e];break;case`count`:a.count=(a.count||0)+i[e]}}return E(a,t)}async _summaryStatsForFieldsAdvanced(e,t){let{outStatisticTypes:n,fields:r}=e,i=n?.exclude?.includes(`variance`)||n?.include&&!n.include.includes(`variance`),a=n?.exclude?.includes(`stddev`)||n?.include&&!n.include.includes(`stddev`);if(t.sum==null||!t.count||i&&a)return t;t.avg=t.sum/t.count;let o=[];for(let n=0;n<r.length;n+=50){let i=r.slice(n,n+50),a=Ct(this,e,i);a.outStatistics=[];for(let e of i){let n=`sumOfSquares_${e}`,r=`(power(${ke(this.layer,e)?A(e):e} - ${t.avg}, 2))`,i=new w({statisticType:`sum`,onStatisticField:r,outStatisticFieldName:n});a.outStatistics.push(i)}o.push(this.layer.queryFeatures(a,{signal:e.signal}))}return t.variance=(await Promise.all(o)).reduce((e,t)=>e+Object.values(t.features[0].attributes).reduce((e,t)=>e+t,0),0)/(t.count-1),t.stddev=Math.sqrt(t.variance),E(t,n)}async _summaryStatsForFields(e){let t=await this._summaryStatsForFieldsBasic(e);return this._summaryStatsForFieldsAdvanced(e,t)}async _summaryStatsUsingQueryPivot(e){await this._isStatsSupportedOnService();let t=`capabilities`in this.layer?this.layer.capabilities:null,n=Tt(this,e,t?.query?.supportsPercentileStatistics??!1),r=await this.layer.queryPivot(n,{signal:e.signal}),i=H(r,!1);return E(i,e.outStatisticTypes)}_uvFromGenRenderer(e,t){let n=e.field??void 0,r=new R({attributeField:n}),i=new L({classificationDefinition:r});return this.generateRenderer(i,e.signal).then(e=>{let t={},r=this.getField(n);return e.uniqueValues.forEach(e=>{let n=e.value;n!=null&&n!==``&&(typeof n!=`string`||n.trim()!==``&&n.toLowerCase()!==`<null>`)||(n=null),t[n]==null?t[n]={count:e.count,data:y(r)&&n?Number(n):n}:t[n].count=t[n].count+e.count}),{count:t}}).then(n=>D(n,[t],e.returnAllCodedValues))}async _uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(Et(this,e),{signal:e.signal})).then(t=>pt(t,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,view:e.view,signal:e.signal})).then(n=>D(n,t,e.returnAllCodedValues,`,`))}_getNormalizationTotal(e,t,n,r){return e&&t===`percent-of-total`?this.summaryStatistics({field:e,outStatisticTypes:{include:[`sum`]},filter:n,signal:r}).then(e=>e.sum):Promise.resolve(null)}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.filter,e.signal).then(t=>{let n=Mt(e,this,t);return Ft(n,this,e.minValue,e.maxValue).then(r=>{let i=r.min,a=r.max;if(i==null||a==null)return{bins:[],minValue:i,maxValue:a,normalizationTotal:t};let o=e.numBins||10,s=Ce(i,a,o),c=Wt(n.sqlExpression,s,e.minValue!=null&&e.maxValue!=null),l=new w({statisticType:`count`,outStatisticFieldName:`countOFExpr`,onStatisticField:`1`}),u=this.layer.createQuery();return u.where=M(u.where,n.sqlWhere),u.sqlFormat=`standard`,u.outStatistics=[l],u.groupByFieldsForStatistics=[c],u.orderByFields=[c],J(u,e.filter),this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(u,{signal:n.signal})).then(e=>ft(e,i,a,o,t))})})}async _histogramForFields(e){let{min:t,max:n}=await Ft({fields:e.fields,sqlWhere:e.sqlWhere,filter:e.filter,signal:e.signal},this,e.minValue,e.maxValue);if(t==null||n==null)return{bins:[],minValue:t,maxValue:n};let r=`newField`,i=e.numBins||10,a=Wt(r,Ce(t,n,i),e.minValue!=null&&e.maxValue!=null),o=new w({statisticType:`count`,outStatisticFieldName:`countOFExpr`,onStatisticField:r}),s=new Be,{where:c,timeExtent:l}=this.createQuery();return s.where=M(c,e.sqlWhere),s.outPivots=[new ze({sourceFields:e.fields,valueFieldName:r})],s.outStatistics=[o],s.groupByFieldsForStatistics=[a],s.orderByFields=[a],s.timeExtent=l,J(s,e.filter),this._isStatsSupportedOnService().then(()=>this.layer.queryPivot(s,{signal:e.signal})).then(e=>ft(e,t,n,i))}async _histogramFromQueryAttributeBins(e){let{field:t,normalizationType:n,filter:r,signal:i}=e,a=await this._getNormalizationTotal(t,n,r,i),{query:o,min:s,max:c}=await It(e,this,a,this.createQuery());if(!o)return{bins:[],minValue:s,maxValue:c,normalizationTotal:a};let l=await this.layer.queryAttributeBins(o,{signal:i});return Rt(l,t?this.getField(t):null,{minValue:s,maxValue:c,normalizationTotal:a})}_classBreaksFromGenRend(e){let{field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,signal:a}=e,o=N({field:t,normalizationType:n,normalizationField:r}),s=U({field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,layer:this}),c=j(s,e.minValue,e.maxValue),l=be({field:t,normalizationType:n,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||Vt}),u=new L({classificationDefinition:l});return u.where=M(o,c),this.generateRenderer(u,a).then(t=>we(t,e.classificationMethod))}async summaryStatistics(e){let{field:n,fields:r,normalizationType:i,valueExpression:a,sqlExpression:o,view:s,features:c,useFeaturesInView:l}=e,u=n?this.getField(n):null,d=O(u)||b(u),f=a&&!(o&&this.supportsSQLExpression),p=this._hasLocalSource||c||l,m=s?.type===`3d`;if(r?.length){let t={...e,fields:r};if(!this.layer.capabilities?.operations?.supportsQueryPivot)return await this._summaryStatsForFields(t);try{return await this._summaryStatsUsingQueryPivot(t)}catch{return await this._summaryStatsForFields(t)}}if(p||f)return f||c||l||m||this._hasLocalSource&&!this.layer.capabilities.query.supportsStatistics?this._summaryStatsFromMemory(e,u):this._summaryStatsFromClientQuery(e,u);if(!this.supportsSQLExpression&&(d||o||i===`natural-log`||i===`square-root`))throw new t(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return(i&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,u)).catch(()=>(T(e.signal),this._summaryStatsFromMemory(e,u)))}async uniqueValues(e){let{valueExpression:t,sqlExpression:n,features:r,useFeaturesInView:i,signal:a}=e,o=t&&!(n&&this.supportsSQLExpression),s=this._hasLocalSource||r||i||o,c=e.view,l=c?.type===`3d`,u=await G(e,this);return s?o||r||i||l||this._hasLocalSource&&!this.layer.capabilities.query.supportsStatistics?this._uvFromMemory(e,u):this._uvFromClientQuery(e,u):this._uvFromServiceQuery(e,u).catch(t=>(T(a),!e.field||e.field2||e.field3||e.filter?t:this._uvFromGenRenderer(e,u[0]))).catch(()=>(T(a),l?this._uvFromMemory(e,u):this._uvFromClientQuery(e,u)))}async histogram(e){let{field:n,normalizationType:r,normalizationField:i,classificationMethod:a,view:o,filter:s,signal:c}=e,l=n?this.getField(n):null,u=O(l)||b(l),d=e.valueExpression||e.sqlExpression,f=e.valueExpression&&!(e.sqlExpression&&this.supportsSQLExpression),p=this._hasLocalSource||e.features||e.useFeaturesInView||f,m=this.supportsSQLExpression,h=!a||a===`equal-interval`,g=e.minValue,_=e.maxValue,v=g!=null&&_!=null,y=e.numBins||10;if(e.fields?.length){if(!m)throw new t(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);if(!this.layer.capabilities?.operations?.supportsQueryPivot)throw new t(`${this.adapterName}:not-supported`,`Layer does not support pivot queries`);return this._histogramForFields(e)}if(p)return this._histogramFromMemory(e);if(this.layer.capabilities?.operations?.supportsQueryBins&&e.useQueryAttributeBins)try{return await this._histogramFromQueryAttributeBins(e)}catch{return T(c),this._histogramFromQueryAttributeBinsFromMemory(e)}if((d||m)&&h){if(!m&&(d||r===`natural-log`||r===`square-root`))throw new t(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return this._histogramForExpr(e)}if(u&&h)throw new t(`${this.adapterName}:not-supported`,`Normalization and date field are not allowed when layer does not support standardized SQL expression for queries`);return r||!h?Nt(e,this).then(a=>{if(!v)return Y(this,a,n,y,o,s,c);if(g>a.max||_<a.min)throw new t(`${this.adapterName}:insufficient-data`,`Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field`);if(h)return Y(this,{min:g,max:_,sqlExpr:a.sqlExpr,excludeZerosExpr:a.excludeZerosExpr},n,y,o,s,c);{let t={field:n,normalizationType:r,normalizationField:i,normalizationTotal:a.normTotal,layer:this},l=U(t),u=j(l,g,_);return Nt(e,this,u).then(e=>Y(this,e,n,y,o,s,c))}}):this._histogramForField(e)}async classBreaks(e){let t=!1!==e.analyzeData,n=this._hasLocalSource||e.features||e.useFeaturesInView||e.valueExpression||e.filter;return t&&n?this._classBreaksFromMemory(e):(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch(()=>(T(e.signal),this._classBreaksFromMemory(e)))}async queryFeatureCount(e){if(this._hasLocalSource)throw new t(`${this.adapterName}:not-supported`,`Layer does not support count query`);let n=this.layer,r=n.createQuery();return r.where=M(r.where,e.whereClause),J(r,e.filter),n.queryFeatureCount(r,{signal:e.signal})}async generateRenderer(e,n){let r=this.layer;if(this._hasLocalSource||r.version<10.1)throw new t(`${this.adapterName}:not-supported`,`Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)`);let i=r.createQuery();return e.where=M(e.where,i.where),Ze(r.parsedUrl?.path??``,{source:r.dynamicDataSource??void 0,gdbVersion:r.gdbVersion??void 0},e,{signal:n})}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new t(`${this.adapterName}:not-supported`,`Layer does not support advanced SQL expressions and standardized queries`);let{fields:n,view:r,signal:i,filter:a}=e,o=at(n),s=tt(n),c=r&&this._hasLocalSource?await this._uvFromMemory({valueExpression:o,view:r,signal:i,filter:a}):await this._uvFromServiceQuery({sqlExpression:s.expression,valueExpression:o,signal:i,filter:a});return yt(c.uniqueValueInfos,n)}async getSampleFeatures(e,t){let{view:n,requiredFields:r,returnGeometry:i,filter:a,signal:o}=e,s=e.sampleSize;if(s==null||s===0)return[];let c=this.layer.createQuery(),l=t===`json`;c.outSpatialReference=n?.spatialReference,c.returnGeometry=!!i,c.outFields=r,J(c,a);let u=[],d=!1;if(n)try{let i=await n.whenLayerView(this.layer);if(d=!V(this,r,i).length,d){if(s>=1&&!e.filter&&`getSampleFeatures`in i){await this._waitForLayerViewUpdate(i);let e=await i.getSampleFeatures({minFeatureCount:s,sampleSize:s});if(e!=null)return l?e:e.map(e=>f.fromJSON(e))}if(u=await this._fetchFeaturesFromMemory(i,c,o,t),u.length>=s&&s>0)return S(u,s,1)}}catch{T(o)}try{if(this._hasLocalSource)return d?u:l?await this._fetchFeaturesJSONFromService(c,o):await this._fetchFeaturesFromService(c,o);let t=await this.queryFeatureCount({view:n,filter:a,signal:o}),r=this.layer.capabilities.query.maxRecordCount,i=s===-1?t:s;if(i=r&&i>r?r:i,t<=u.length||u.length>=r)return u;if(c.maxAllowableOffset=e.resolution||(n?n.extent.width/n.width/n.scale:ue(this.layer.spatialReference))*Ut,t<=i)return l?await this._fetchFeaturesJSONFromService(c,o):await this._fetchFeaturesFromService(c,o);if(t<=Ht){let e=this.layer.createQuery();J(e,a);let t=await this.layer.queryObjectIds();return c.objectIds=S(t,i,1),l?await this._fetchFeaturesJSONFromService(c,o):await this._fetchFeaturesFromService(c,o)}return this.layer.capabilities?.query?.supportsPagination&&(c.num=Math.min(i,Ht)),l?await this._fetchFeaturesJSONFromService(c,o):await this._fetchFeaturesFromService(c,o)}catch{return T(o),u}}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.capabilities?.query?.supportsSqlExpression,this._hasLocalSource=t.type===`parquet`||!t.url&&!!t.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};function Wt(e,t,n){let r=[],i=t.length;return t.forEach((t,a)=>{let[o,s]=t,c=null;c=a!==0||n?a!==i-1||n?M(`${e} >= ${o}`,`${e} ${a===i-1?` <= `:` < `} ${s}`):`${e} >= ${o}`:`${e} < ${s}`,r.push(`WHEN (`+c+`) THEN `+(a+1))}),[`CASE`,r.join(` `),`ELSE 0`,`END`].join(` `)}C([r({readOnly:!0})],Q.prototype,`adapterName`,void 0),C([r({constructOnly:!0})],Q.prototype,`layer`,void 0),Q=C([v(`esri.smartMapping.support.adapters.FeatureLayerAdapter`)],Q);var Gt=class extends Q{constructor(){super(...arguments),this.adapterName=`csv-layer-adapter`}async _createGenerateRendererResult(e,n,r,i,a){let o=e?.features;if(!o?.length)throw new t(`csv-layer-adapter:insufficient-data`,`No features are available to calculate statistics`);let s=B(o),c=null;if(i===`percent-of-total`&&(c=(await this.workerClient.summaryStatistics({field:n},s)).sum,c==null))throw new t(`csv-layer-adapter:invalid`,`invalid normalizationTotal`);if(a?.type===`class-breaks-definition`){let e=(await Me({field:n,normalizationType:i,normalizationField:r,normalizationTotal:c},s)).filter(e=>Number.isFinite(e));return ye({definition:a,values:e,normalizationTotal:c})}let l=(await Me({field:n},s)).filter(e=>e!=null&&typeof e==`string`&&e.trim()!==``);return ve(l)}generateRenderer(e,t){let n=e.classificationDefinition,r=null,i=null,a=null;n?.type===`class-breaks-definition`?(r=n.classificationField,i=n.normalizationField,a=n.normalizationType):r=n?.attributeField;let o=this.layer;return k({field:r,normalizationField:i}).then(s=>{let c=o.createQuery();return c.returnGeometry=!1,c.outFields=s,c.where=M(c.where,e.where),o.queryFeatures(c,{signal:t}).then(e=>this._createGenerateRendererResult(e,r,i,a,n))})}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};C([r({readOnly:!0})],Gt.prototype,`adapterName`,void 0),Gt=C([v(`esri.smartMapping.support.adapters.CSVLayerAdapter`)],Gt);var Kt=class extends Q{constructor(){super(...arguments),this.adapterName=`feature-layer-binning-adapter`}async _getNormalizationTotalFromMemory(e,n,r){let{featuresJSON:i,graphics:a,layerView:o,query:s}=n,c={include:[`sum`]},l=(!i&&!a&&o&&`queryAggregateSummaryStatistics`in o?await o.queryAggregateSummaryStatistics(s,{field:e,outStatisticTypes:c},{signal:r}):i?await this.workerClient.summaryStatistics({field:e},i):await F({attribute:{field:e,outStatisticTypes:c},features:a})).sum;if(l==null)throw new t(`${this.adapterName}:invalid`,`invalid normalizationTotal`);return l}async _processStatsFromMemoryParams(e){let{features:n,filter:r}=e;if(n?.length)return this._getFilteredFeatures(n,r);let{view:i,field:a,field2:s,field3:c,normalizationField:l,valueExpression:u,returnGeometry:d,layerViewFunc:f,signal:p}=e,m=null,h=null,g=null,_=null,v=null;if(i)try{if(m=await i.whenLayerView(this.layer),o(m),h=f!=null&&f in m&&typeof m[f]==`function`,h){await this._waitForLayerViewUpdate(m);let e=await k({field:a,field2:s,field3:c,normalizationField:l,valueExpression:u});lt(this,e).length?h=!1:(g=`createAggregateQuery`in m?m.createAggregateQuery():null,g?(g.outFields=e,g.returnGeometry=!1,J(g,r)):h=!1),m.suspended&&(h=!1)}}catch{h=!1}if(!h&&(v=bt(this.layer).map(e=>e.toJSON()),_=await this._fetchFeaturesForStats({field:a,field2:s,field3:c,valueExpression:u,normalizationField:l,returnGeometry:d,filter:r,view:i,signal:p},`json`),!_?.length))throw new t(`${this.adapterName}:insufficient-data`,`No features are available to calculate statistics`);return{layerView:m,query:g,featuresJSON:_,fieldInfos:v}}async _summaryStatsFromMemory(e,t){let{view:n,field:r,valueExpression:i,normalizationType:a,signal:o}=e,s={field:r,valueExpression:i,normalizationType:a,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes},{featuresJSON:c,graphics:l,layerView:u,query:d,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateSummaryStatistics`});return i&&n&&(c||l)&&(s.fieldType=t?.type?he.toJSON(t.type):null,s.viewInfoParams=K(n),s.timeZone=n.timeZone,s.fieldInfos=f),a===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:c,graphics:l,layerView:u,query:d},o)),!c&&!l&&u&&`queryAggregateSummaryStatistics`in u?u.queryAggregateSummaryStatistics(d,s,{signal:o}):c?this.workerClient.summaryStatistics(s,c):F({attribute:s,features:l})}async _uvFromMemory(e,t){let{view:n,field:r,valueExpression:i,returnAllCodedValues:a,signal:o}=e,{featuresJSON:s,graphics:c,layerView:l,query:u,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateUniqueValues`}),f={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,valueExpression:i,domains:t,returnAllCodedValues:a};return i&&n&&(s||c)&&(f.viewInfoParams=K(n),f.timeZone=n.timeZone,f.fieldInfos=d),!s&&!c&&l&&`queryAggregateUniqueValues`in l?l.queryAggregateUniqueValues(u,f,{signal:o}):s?this.workerClient.uniqueValues(f,s):He({attribute:f,features:c})}async _histogramFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateHistogram`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryAggregateHistogram`in s?s.queryAggregateHistogram(c,u,{signal:i}):a?this.workerClient.histogram(u,a):P({attribute:u,features:o})}async _classBreaksFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateClassBreaks`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryAggregateClassBreaks`in s?s.queryAggregateClassBreaks(c,u,{signal:i}):a?this.workerClient.classBreaks(u,a):Ue({attribute:u,features:o})}getField(e=``){return bt(this.layer)?.find(t=>t.name.toLowerCase()===e?.toLowerCase())}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(e,t){return null}async summaryStatistics(e){let{field:n}=e,r=n?this.getField(n):null,i=O(r)||b(r),a=e.sqlExpression&&!e.valueExpression&&!n;if(i||a)throw new t(`${this.adapterName}:not-supported`,`Date field and sqlExpression are not supported`);return this._summaryStatsFromMemory(e,r)}async uniqueValues(e){let t=await G(e,this);return this._uvFromMemory(e,t)}async histogram(e){let{field:n}=e,r=n?this.getField(n):null,i=O(r)||b(r),a=e.sqlExpression&&!e.valueExpression&&!n;if(i||a)throw new t(`${this.adapterName}:not-supported`,`Date field and sqlExpression are not supported`);return this._histogramFromMemory(e)}async classBreaks(e){return(!1===e.analyzeData?this._classBreaksFromInterpolation(e):this._classBreaksFromMemory(e)).catch(()=>(T(e.signal),this._classBreaksFromMemory(e)))}async queryFeatureCount(e){let n=await e.view?.whenLayerView(this.layer);if(!n||!(`queryAggregateCount`in n)||!n.queryAggregateCount)throw new t(`${this.adapterName}:not-supported`,`LayerView is not supported.`);await this._waitForLayerViewUpdate(n);let r=n.createAggregateQuery();return r.where=M(r.where,e.whereClause),J(r,e.filter),n.queryAggregateCount(r,{signal:e.signal})}generateRenderer(e,n){throw new t(`${this.adapterName}:not-supported`,`'generateRenderer' is not supported.`)}heatmapStatistics(e){throw new t(`${this.adapterName}:not-supported`,`'heatmapStatistics' is not supported.`)}async predominantCategories(e){let{fields:t,view:n,signal:r}=e,i=at(t),a=await this._uvFromMemory({valueExpression:i,view:n,signal:r});return yt(a.uniqueValueInfos,t)}async getSampleFeatures(e,n){let{view:r,sampleSize:i,requiredFields:a,returnGeometry:o,filter:s,signal:c}=e;if(!r)throw new t(`${this.adapterName}:not-supported`,`'view' is required to get sample features for binning.`);if(r.type===`3d`)throw new t(`${this.adapterName}:not-supported`,`3d 'view' is not supported to get sample features for binning.`);let l=await r.whenLayerView(this.layer);if(!(`queryAggregateJSON`in l&&l.queryAggregateJSON&&`queryAggregates`in l&&l.queryAggregates))throw new t(`${this.adapterName}:not-supported`,`LayerView is not supported.`);if(await this._waitForLayerViewUpdate(l),lt(this,a).length)throw new t(`${this.adapterName}:insufficient-data`,`Layer does not have required fields`);let u=n===`json`,d=l.createAggregateQuery();d.outSpatialReference=r?.spatialReference,d.returnGeometry=!!o,d.outFields=a,J(d,s);let{features:f}=u?await l.queryAggregateJSON(d,{signal:c}):await l.queryAggregates(d,{signal:c});return f.length&&i!=null&&i>0&&i<=f.length?S(f,i,1):f}load(e){let n=this.layer.load(e).then(async n=>{let r=`featureReduction`in n?n.featureReduction:null;if(r?.type!==`binning`&&r?.type!==`cluster`)throw new t(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${r?.type} is not supported`);this.geometryType=r?.type===`cluster`?`point`:`polygon`,this.objectIdField=null,this.supportsSQLExpression=!1,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.minScale=n.minScale,this.maxScale=n.maxScale,this.fullExtent=n.fullExtent,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(n),Promise.resolve(this)}};C([r({readOnly:!0})],Kt.prototype,`adapterName`,void 0),Kt=C([v(`esri.smartMapping.support.adapters.FeatureLayerBinningAdapter`)],Kt);var qt=Kt,$=class extends z{constructor(e){super(e),this._featureLayerAdapter=null,this.workerClient=null,this.adapterName=`scene-layer-adapter`}destroy(){this.workerClient?.destroy()}_hasCachedStatistics(e){return this.layer.hasCachedStatistics(e)}_updateQuery(e,t=[],n=[]){if(!e||!n.length)return e;let r=this.layer.objectIdField,i=e.clone(),a=t.filter(e=>{let t=this.layer.getField(e);return!n.includes(t.name)});return i.outFields=a.some(e=>this.layer.getField(e).name===r)?a:[...a,r],i}async _fetchFeaturesFromMemory(e,n,r){if(!e)throw new t(`scene-layer-adapter:insufficient-data`,`view is required to fetch the features from layerView`);let i=await e.whenLayerView(this.layer),a=new AbortController,o=a.signal,s=oe(()=>!i.updating,o);await ie(s,5e3,a);let c=V(this,r,i);T(o);let l=this._updateQuery(n,r??[],c),u=await i.queryFeatures(l,{signal:o});T(o);let d=u.features;return c.length?i.whenGraphicAttributes(d,c):d}async _fetchFeaturesJSONFromMemory(e,t,n){return this._fetchFeaturesFromMemory(e,t,n).then(B)}_fetchFeaturesForStats(e,t){return k({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then(n=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:n,signal:e.signal},t))}async _processStatsFromMemoryParams(e){let n=e.features;if(n?.length)return n.length&&`declaredClass`in n[0]&&n[0].declaredClass===`esri.Graphic`?{graphics:n}:{featuresJSON:n};let{view:r,field:i,normalizationField:a,valueExpression:o,signal:s}=e,c=await this._fetchFeaturesForStats({field:i,valueExpression:o,normalizationField:a,view:r,signal:s},null);if(!c?.length)throw new t(`scene-layer-adapter:insufficient-data`,`No features are available to calculate statistics`);return{graphics:c}}_getCachedStatistics(e,n){let r=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.minValue||e.maxValue?Promise.reject(new t(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified`)):r.queryCachedStatistics(n?.name,{signal:e.signal}).then(e=>{let t=e.stats,{min:n,max:r,totalValuesCount:i}=t,{avg:a,stddev:o,sum:s,variance:c,count:l}=t;return n===0&&r===0||(a=a===0?null:a,s=s===0?null:s,o=o===0?null:o,c=c===0?null:c,l=l===0?null:l),l??(s!=null&&a!=null?l=Math.round(s/a):i!=null&&(l=i)),{avg:a,count:l,max:r,min:n,stddev:o,sum:s,variance:c}})}async _getNormalizationTotal(e,n,r){let i={include:[`sum`]},a=(n?await this.workerClient.summaryStatistics({field:e,outStatisticTypes:i},n):await F({attribute:{field:e,outStatisticTypes:i},features:r})).sum;if(a==null)throw new t(`scene-layer-adapter:invalid`,`invalid normalizationTotal`);return a}async _getSummaryStatisticsFromMemory(e,t){let{view:n,field:r,normalizationField:i,valueExpression:a}=e,{featuresJSON:o,graphics:s}=await this._processStatsFromMemoryParams(e),c={field:r,valueExpression:a,normalizationType:e.normalizationType,normalizationField:i,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes};return e.valueExpression&&n&&o&&(c.fieldType=t?.type?he.toJSON(t.type):null,c.viewInfoParams=K(n),c.timeZone=n.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(c.normalizationTotal=await this._getNormalizationTotal(r,o,s)),o?this.workerClient.summaryStatistics(c,o):F({attribute:c,features:s})}_getCachedStatisticsForUniqueValues(e,n){let r=this.layer,i=n?.name,a=n&&e.field?this.getFieldDomain(e.field):null;return e.valueExpression||e.sqlExpression||e.sqlWhere?Promise.reject(new t(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified`)):r.queryCachedStatistics(i,{signal:e.signal}).then(t=>{let a=t.stats;if(!a.mostFrequentValues)throw Error();let o=t.labels?.labels,s={},c=[],l=`countOF`+i;a.mostFrequentValues.forEach(e=>{let t=new f({attributes:{}});t.attributes[i]=n&&n.name!==r.objectIdField&&(y(n)||O(n))?Number(e.value):e.value,t.attributes[l]=e.count,c.push(t)}),o&&o.forEach(e=>{s[e.value]=e.label});let u=new se({features:c});return pt(u,{layer:this,field:e.field,labels:s,view:e.view,signal:e.signal})}).then(t=>D(t,[a],e.returnAllCodedValues))}async _getUniqueValuesFromMemory(e,t){let{view:n,field:r,field2:i,field3:a,valueExpression:o,returnAllCodedValues:s}=e,c={field:r,field2:i,field3:a,fieldDelimiter:`,`,valueExpression:o,domains:t,returnAllCodedValues:s},{featuresJSON:l,graphics:u}=await this._processStatsFromMemoryParams(e);return e.valueExpression&&n&&l&&(c.viewInfoParams=K(n),c.timeZone=n.timeZone),l?this.workerClient.uniqueValues(c,l):He({attribute:c,features:u})}_getCachedStatisticsForHistogram(e,n){let r=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.normalizationType?Promise.reject(new t(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified`)):r.queryCachedStatistics(n&&n.name,{signal:e.signal}).then(t=>{let n=t.stats,{minValue:r,maxValue:i}=e,a=r??n.min,o=i??n.max,s=e.numBins||10,c=Jt(n.histogram,a,o,s);return ft(c,a,o,s)})}async _getClassBreaksFromMemory(e){let{view:t,field:n,normalizationField:r,valueExpression:i}=e,{featuresJSON:a,graphics:o}=await this._processStatsFromMemoryParams(e),s={field:n,valueExpression:i,normalizationType:e.normalizationType,normalizationField:r,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return e.valueExpression&&t&&a&&(s.viewInfoParams=K(t),s.timeZone=t.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotal(n,a,o)),a?this.workerClient.classBreaks(s,a):Ue({attribute:s,features:o})}async _getHistogramFromMemory(e){let{view:t,field:n}=e,{featuresJSON:r,graphics:i}=await this._processStatsFromMemoryParams(e),a={field:n,valueExpression:e.valueExpression,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return e.valueExpression&&t&&r&&(a.viewInfoParams=K(t),a.timeZone=t.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(a.normalizationTotal=await this._getNormalizationTotal(n,r,i)),r?this.workerClient.histogram(a,r):P({attribute:a,features:i})}getField(e){return this.layer.getField(e??``)}getFieldUsageInfo(e){let t=this.getField(e);if(!t)return null;let n=this.layer.getFieldUsageInfo(t.name);return{supportsLabelingInfo:n.supportsLabelingInfo,supportsPopupTemplate:n.supportsPopupTemplate,supportsRenderer:n.supportsRenderer,supportsLayerQuery:n.supportsLayerQuery,supportsStatistics:!0}}getFieldDomain(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(e,t):null}createQuery(){return this.layer.createQuery()}summaryStatistics(e){let n=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.summaryStatistics(e);if(e.filter)throw new t(`scene-layer-adapter:not-supported`,`filter is not supported`);return this._hasCachedStatistics(n?.name)?this._getCachedStatistics(e,n).catch(()=>(T(e.signal),this._getSummaryStatisticsFromMemory(e,n))):this._getSummaryStatisticsFromMemory(e,n)}async uniqueValues(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.uniqueValues(e);if(e.filter)throw new t(`scene-layer-adapter:not-supported`,`filter is not supported`);let n=await G(e,this),{field:r,field2:i}=e,a=r&&i,o=this.getField(r);return!a&&o&&this._hasCachedStatistics(o.name)?this._getCachedStatisticsForUniqueValues(e,o).catch(()=>(T(e.signal),this._getUniqueValuesFromMemory(e,n))):this._getUniqueValuesFromMemory(e,n)}histogram(e){let n=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.histogram(e);if(e.filter)throw new t(`scene-layer-adapter:not-supported`,`filter is not supported`);return n&&this._hasCachedStatistics(n.name)?this._getCachedStatisticsForHistogram(e,n).catch(()=>(T(e.signal),this._getHistogramFromMemory(e))):this._getHistogramFromMemory(e)}classBreaks(e){let n=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.classBreaks(e);if(e.filter)throw new t(`scene-layer-adapter:not-supported`,`filter is not supported`);return this._hasCachedStatistics(n?.name)?Promise.reject(new t(`scene-layer-adapter:not-supported`,`Cached stats not supported`)):this._getClassBreaksFromMemory(e)}queryFeatureCount(e){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(e):Promise.reject(new t(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support count query`))}generateRenderer(e,n){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(e,n):Promise.reject(new t(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support generateRenderer operation`))}heatmapStatistics(e){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(e):Promise.reject(new t(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support heatmapStatistics operation`))}async predominantCategories(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(e);throw new t(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support predominantCategories`)}async getSampleFeatures(e,n){if(e.filter)throw new t(`scene-layer-adapter:not-supported`,`filter is not supported`);let{view:r,sampleSize:i,requiredFields:a,returnGeometry:o,signal:s}=e,c=n===`json`,l=this.createQuery();l.outFields=a,l.returnGeometry=!!o,l.where=null,l.num=i;let u=[];try{if(u=c?await this._fetchFeaturesJSONFromMemory(r,l,a):await this._fetchFeaturesFromMemory(r,l,a),u.length&&i!=null&&i>0&&i<=u.length)return S(u,i,1)}catch{T(s)}let d=null;if(this._featureLayerAdapter){let t={...e};delete t.view,d=await this._featureLayerAdapter.getSampleFeatures(t,n)}return d?.length?d:S(u,u.length,1)}load(e){let t=this.layer.load(e).then(async t=>{this.workerClient=I.getInstance(),await this.workerClient.open(e.signal);let n=t.associatedLayer;if(this.geometryType=t.geometryType,n!=null)return this._featureLayerAdapter=new Q({layer:n}),this._featureLayerAdapter.load(e).then(()=>{this.objectIdField=this._featureLayerAdapter.objectIdField,this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression,this.minScale=this._featureLayerAdapter.minScale,this.maxScale=this._featureLayerAdapter.maxScale,this.fullExtent=this._featureLayerAdapter.fullExtent});this.objectIdField=t.objectIdField,this.supportsSQLExpression=!1,this.hasQueryEngine=!1,this.fullExtent=t.fullExtent});return this.addResolvingPromise(t),Promise.resolve(this)}};function Jt(e,t=e.minimum,n=e.maximum,r){let i=[];for(let e=0;e<r;e++)i[e]=0;let a=e.counts.length,o=e.minimum,s=e.maximum;for(let c=0;c<a;c++){let l=(c+.5)/a,u=((1-l)*o+l*s-t)/(n-t)*r;u>=0&&u<=r&&(i[u===r?r-1:Math.floor(u)]+=e.counts[c])}let c=[];return i.forEach((e,t)=>{let n=new f({attributes:{}});n.attributes.EXPR_1=t+1,n.attributes.countOFExpr=e,c.push(n)}),new se({features:c})}C([r({readOnly:!0})],$.prototype,`adapterName`,void 0),C([r({constructOnly:!0})],$.prototype,`layer`,void 0),$=C([v(`esri.smartMapping.support.adapters.SceneLayerAdapter`)],$);var Yt=class extends ${constructor(e){super(e),this.adapterName=`point-cloud-layer-adapter`}getField(e){return this.layer.fieldsIndex.get(e??``)}getFieldUsageInfo(e){let t=this.getField(e);if(!t)return null;let n=this._hasCachedStatistics(t.name);return{supportsLabelingInfo:n,supportsPopupTemplate:n,supportsRenderer:n,supportsLayerQuery:!1,supportsStatistics:n}}getFieldDomain(){return null}load(e){let t=this.layer.load(e).then(()=>{this.geometryType=`point`,this.objectIdField=null,this.supportsSQLExpression=!1,this.hasQueryEngine=!1});return this.addResolvingPromise(t),Promise.resolve(this)}};C([r({readOnly:!0})],Yt.prototype,`adapterName`,void 0),Yt=C([v(`esri.smartMapping.support.adapters.PointCloudLayerAdapter`)],Yt);var Xt=class extends Z{constructor(){super(...arguments),this.adapterName=`stream-layer-adapter`}async _summaryStatsFromClientQuery(e,t){let{signal:n,view:r}=e,i=q(this,e,t);i.outStatistics=i.outStatistics?.filter(e=>e.outStatisticFieldName!==`totalcount_value`);let a=await this._fetchFeatureSetFromMemory(i,r,n),o=H(a,O(t)||b(t));return E(o,e.outStatisticTypes)}};C([r({readOnly:!0})],Xt.prototype,`adapterName`,void 0),Xt=C([v(`esri.smartMapping.support.adapters.StreamLayerAdapter`)],Xt);var Zt={0:{adapter:Q,type:`catalog`,label:`CatalogLayer`},1:{adapter:Q,type:`catalog-footprint`,label:`CatalogFootprintLayer`},2:{adapter:Gt,type:`csv`,label:`CSVLayer`},3:{adapter:Q,type:`feature`,label:`FeatureLayer`},5:{adapter:Q,type:`imagery`,label:`ImageryLayer`},4:{adapter:Q,type:`geojson`,label:`GeoJSONLayer`},6:{adapter:Q,type:`knowledge-graph-sublayer`,label:`KnowledgeGraphSublayer`},7:{adapter:Z,type:`ogc-feature`,label:`OGCFeatureLayer`},8:{adapter:Q,type:`oriented-imagery`,label:`OrientedImageryLayer`},9:{adapter:Q,type:`parquet`,label:`ParquetLayer`},10:{adapter:Yt,type:`point-cloud`,label:`PointCloudLayer`},11:{adapter:$,type:`scene`,label:`SceneLayer`},12:{adapter:Xt,type:`stream`,label:`StreamLayer`},13:{adapter:Q,type:`subtype-group`,label:`SubtypeGroupLayer`},14:{adapter:Q,type:`subtype-sublayer`,label:`SubtypeSublayer`},15:{adapter:Q,type:`wfs`,label:`WFSLayer`}},Qt=[0,1,2,3,4,6,7,8,9,10,11,12,13,14,15],$t=[2,3,4,7,6,8,9,12,15];function en(e){return e.map(e=>Zt[e].label)}function tn(e,t=Qt,n){if(e instanceof z)return e;let r=nn(e,t);return r?n?new qt({layer:e}):new r({layer:e}):null}function nn(e,t=Qt){let n=null;return t.some(t=>{let r=e.type===Zt[t].type;return r&&(n=Zt[t].adapter),r}),n}async function rn(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new t(`unique-values:missing-parameters`,`'layer' and 'field' or 'valueExpression' parameters are required`);let n=e.valueExpression||e.sqlExpression,r=n&&!e.sqlExpression;if(n){if(r){if(!e.view)throw new t(`unique-values:missing-parameters`,`View is required when 'valueExpression' is specified`)}else if(!e.valueExpression)throw new t(`unique-values:missing-parameters`,`'valueExpression' parameters are required`)}e.forBinning&&We(e,`unique-values`);let{layer:i,...a}=e,o=[...Qt,5],s=e.forBinning?$t:o,c=tn(i,s,e.forBinning);if(!c)throw new t(`unique-values:invalid-parameters`,`'layer' must be one of these types: `+en(s).join(`, `));let l={layerAdapter:c,...a},u=l.signal==null?null:{signal:l.signal};await c.load(u);let d=await k({field:l.field,field2:l.field2,field3:l.field3,valueExpression:l.valueExpression}),f=je(c,d,`unique-values:invalid-parameters`);if(f)throw f;l.filter&&!l.filter.spatialRelationship&&(l.filter.spatialRelationship=`intersects`);let p=Ne(l.filter,`summary-statistics:invalid-parameters`);if(p)throw p;return l}async function an(e){let{layerAdapter:t,...n}=await rn(e);return t.uniqueValues(n)}export{an as default};