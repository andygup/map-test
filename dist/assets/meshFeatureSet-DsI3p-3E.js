import{Qn as e,aE as t,ax as n,ha as r,uE as i,vd as a,wx as o}from"./index-CzMixifc.js";import"./quatf64-eO7UAs9K.js";import"./quat-XKFzqP_i.js";import"./axisAngleDegrees-GaSk0_KM.js";import"./meshCloneUtils-5rtyOBgA.js";import"./MeshMaterialMetallicRoughness-dLgvoHFj.js";import"./meshProperties-DwrhStLW.js";import"./MeshComponent-B_wmH396.js";import{t as s}from"./Mesh-C4QPhA-0.js";import"./MeshLocalVertexSpace-Dfv_NBsU.js";import"./MeshTransform-BGwY5MT4.js";import"./MeshVertexAttributes-Dvo9ht5s.js";import"./meshVertexSpaceUtils-CrM2H6JB.js";import"./earcut-CsNwSYFA.js";import"./Indices-DELx3He_.js";import"./plane--nqwMDYx.js";import"./vectorStacks-BQiry9fn.js";import"./triangulationUtils-DZOlYzLu.js";import"./deduplicate-C8bQBzHi.js";import"./projectPointToVector-D72S8Uh5.js";import"./computeTranslationToOriginAndRotation-DwwRDWAD.js";import"./BufferView-BPABY7if.js";import"./Util-YNFIi00s.js";import"./vec3-D13Z1xO0.js";import"./vec4-CJBDH7oG.js";import"./vertexSpaceConversion-WXuyjrGI.js";import"./spatialReferenceEllipsoidUtils-b6wDfyu0.js";import{a as c,r as l}from"./External-BGzO9MR2.js";import{n as u,t as d}from"./meshFeatureAttributes-BiaxiIdJ.js";var f=()=>i.getLogger(`esri.rest.support.meshFeatureSet`);function p(e,t,n){let i=n.features;n.features=[],delete n.geometryType;let s=r.fromJSON(n);if(s.geometryType=`mesh`,!n.assetMaps)return s;let c=g(t,n.assetMaps),l=e.sourceSpatialReference??o.WGS84,u=n.globalIdFieldName,{outFields:d}=e,f=d!=null&&d.length>0?m(d.includes(`*`)?null:new Set(d)):()=>({});for(let e of i){let n=h(e,u,l,t,c);s.features.push(new a({geometry:n,attributes:f(e)}))}return s}function m(e){return({attributes:t})=>{if(!t)return{};if(!e)return t;for(let n in t)e.has(n)||delete t[n];return t}}function h(e,t,r,i,a){let o=e.attributes[t],c=a.get(o);if(c==null||!e.geometry)return null;let l=u(e.attributes,r,i.transformFieldRoles),f=n.fromJSON(e.geometry);f.spatialReference=r;let p=d(e.attributes,i.transformFieldRoles),m=r.isGeographic?`local`:`georeferenced`,h=_(c);return h?s.createWithExternalSource(l,h,{extent:f,transform:p,vertexSpace:m,unitConversionDisabled:!0}):s.createIncomplete(l,{extent:f,transform:p,vertexSpace:m})}function g(n,r){let i=new Map;for(let a of r){let r=a.parentGlobalId;if(r==null)continue;let o=a.assetName,s=a.assetType,c=a.assetHash,l=a.assetURL,u=a.conversionStatus,d=a.seqNo,p=e(s,n.supportedFormats);if(!p){f().error(`mesh-feature-set:unknown-format`,`Service returned an asset of type ${s}, but it does not list it as a supported type`);continue}let m=t(i,r,()=>({files:new Map}));t(m.files,o,()=>({name:o,type:s,mimeType:p,status:v(u),parts:[]})).parts[d]={hash:c,url:l}}return i}function _(e){let t=Array.from(e.files.values()),n=[];for(let e of t){if(e.status!==2)return null;let t=[];for(let n of e.parts){if(!n)return null;t.push(new c(n.url,n.hash))}n.push(new l(e.name,e.mimeType,t))}return{type:`service`,assets:n}}function v(e){switch(e){case`COMPLETED`:case`SUBMITTED`:return 2;case`INPROGRESS`:return 1;default:return 0}}export{g as assetMapFromAssetMapsJSON,h as extractMesh,p as meshFeatureSetFromJSON};