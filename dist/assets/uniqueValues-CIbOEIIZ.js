const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/meshFeatureSet-DsI3p-3E.js","assets/index-CzMixifc.js","assets/index-CDgdHpAj.css","assets/earcut-CsNwSYFA.js","assets/vec3-D13Z1xO0.js","assets/vec4-CJBDH7oG.js","assets/vectorStacks-BQiry9fn.js","assets/quatf64-eO7UAs9K.js","assets/quat-XKFzqP_i.js","assets/Mesh-C4QPhA-0.js","assets/computeTranslationToOriginAndRotation-DwwRDWAD.js","assets/projectPointToVector-D72S8Uh5.js","assets/spatialReferenceEllipsoidUtils-b6wDfyu0.js","assets/MeshComponent-B_wmH396.js","assets/MeshMaterialMetallicRoughness-dLgvoHFj.js","assets/meshCloneUtils-5rtyOBgA.js","assets/meshProperties-DwrhStLW.js","assets/MeshLocalVertexSpace-Dfv_NBsU.js","assets/MeshTransform-BGwY5MT4.js","assets/axisAngleDegrees-GaSk0_KM.js","assets/MeshVertexAttributes-Dvo9ht5s.js","assets/External-BGzO9MR2.js","assets/vertexSpaceConversion-WXuyjrGI.js","assets/BufferView-BPABY7if.js","assets/Util-YNFIi00s.js","assets/meshVertexSpaceUtils-CrM2H6JB.js","assets/triangulationUtils-DZOlYzLu.js","assets/Indices-DELx3He_.js","assets/deduplicate-C8bQBzHi.js","assets/plane--nqwMDYx.js","assets/meshFeatureAttributes-BiaxiIdJ.js","assets/intersectionOperator-KwqsA1cA.js","assets/SpatialReference-BzfAMI5E.js","assets/Envelope2D-n2TB2v9l.js","assets/Point2D-BslC4Gs9.js","assets/OperatorDefinitions-DoM9xd5U.js","assets/SimpleGeometryCursor-BbFgAuic.js","assets/Transformation2D-B6W9saMR.js","assets/intersectionOperator-DfqrY2U-.js","assets/operatorIntersection-PPDIGfSU.js","assets/apiConverter-BOyb99jX.js","assets/jsonConverter-CYYMdpyx.js","assets/OptimizedGeometry-5fDazGe-.js","assets/memoryEstimations-C3WUBUZI.js"])))=>i.map(i=>d[i]);
import{$w as e,BS as t,BT as n,DT as r,GC as i,GE as a,H as o,Hn as s,JE as c,MT as l,OT as u,O_ as d,Op as f,RS as p,Up as m,Vh as h,Vp as g,Vw as _,YS as v,cd as y,dd as b,eT as x,gD as S,gp as ee,ha as C,hd as te,hp as ne,hu as re,id as w,jp as ie,mT as ae,pD as oe,pd as se,qn as ce,rd as le,ru as ue,sd as de,tv as fe,uE as pe,ud as me,vd as he,ya as ge,zp as _e}from"./index-CzMixifc.js";import"./memoryEstimations-C3WUBUZI.js";import"./OptimizedGeometry-5fDazGe-.js";import"./OptimizedFeatureSet-D4F9ObY_.js";import"./featureConversionUtils-VvJ2pauf.js";import"./urlUtils-7tPnOsRB.js";import{n as ve,t as ye}from"./generateRendererUtils-Boi4GqnB.js";import{_ as be,h as xe,l as Se,p as T,r as E,s as Ce,t as D,u as we}from"./utils-nAxNAb0W.js";import"./pbf-Dny0go3N.js";import"./pbfQueryUtils-Dy8pLZgd.js";import"./queryUtils-ByyjBzze.js";import"./query-BeU-rNp1.js";import{t as Te}from"./executeQueryJSON-BmDY9cVm.js";import{t as Ee}from"./executeQueryPBF-Brhxo-EH.js";import"./queryUtils-fxq7u50x.js";import{c as De}from"./quantizationUtils-CzrQVcZ1.js";import{a as Oe,i as O,n as ke,o as k,r as A,t as Ae}from"./utils-BUI45WL8.js";import{a as je,i as j,n as Me,o as M,r as Ne,t as N}from"./utils-Cm-RG8rq.js";import{a as Pe,n as Fe,r as Ie,t as Le}from"./FixedIntervalBinParameters-5fcY6iRA.js";import{t as Re}from"./AttributeBinsQuery-BqDFZU-T.js";import{n as ze,t as Be}from"./PivotQuery-oj9Nn1TH.js";import{a as Ve,i as P,n as F,r as He,t as Ue}from"./statsWorker-DToyUrt5.js";function We(e,t){if(!e.view)throw new n(`${t}:missing-parameters`,`'view' parameter is required for binning`);if(e.sqlExpression)throw new n(`${t}:invalid-parameters`,`'sqlExpression' parameter is not supported for binning`);if(e.view.type===`3d`)throw new n(`${t}:invalid-parameters`,`3d view is not supported for binning`)}var I=class e{constructor(){this.connection=null}async open(e){this.connection=await ge(`statsWorker`,{strategy:`distributed`,signal:e})}destroy(){this.connection?.close()}static getInstance(){return e.instance||=new e,e.instance}async summaryStatistics(e,t){if(!this.connection)throw new n(`worker-client:summary-statistics`,`connection is required`);return this.connection.invoke(`summaryStatistics`,{attribute:e,features:t})}async uniqueValues(e,t){if(!this.connection)throw new n(`worker-client:unique-values`,`connection is required`);return this.connection.invoke(`uniqueValues`,{attribute:e,features:t})}async classBreaks(e,t){if(!this.connection)throw new n(`worker-client:class-breaks`,`connection is required`);return this.connection.invoke(`classBreaks`,{attribute:e,features:t})}async histogram(e,t){if(!this.connection)throw new n(`worker-client:histogram`,`connection is required`);return this.connection.invoke(`histogram`,{attribute:e,features:t})}async heatmapStatistics(e,t){if(!this.connection)throw new n(`worker-client:heatmap-statistics`,`connection is required`);return this.connection.invoke(`heatmapStatistics`,{attribute:e,features:t})}};async function Ge(e,t,n,r,i){return Je(t,await Ke(e,t,n,r,i),n,r)}async function Ke(e,t,n,r,i){let a={...r},o=Ye(t,n),s=t.outStatistics?.[0]!=null,c=oe(`featurelayer-pbf-statistics`),l=!s||c,u;if(n?.format===`pbf`&&l)try{u=await Ee(e,o,a,i)}catch(e){if(e.name!==`query:parsing-pbf`)throw e;n.format=`json`}return n?.format!==`json`&&l||(u=await Te(e,o,a,i)),qe(n?.fieldsIndex,u.fields),u}function qe(e,t){if(e!=null&&t!=null)for(let n of t){let t=e.get(n.name);t&&Object.assign(n,t.toJSON())}}async function Je(n,r,i,a){let o=i?.infoFor3D;if(!Xe(n,o)||o==null||!r.assetMaps||!r.features?.length)return C.fromJSON(r);let{meshFeatureSetFromJSON:s}=await e(t(()=>import(`./meshFeatureSet-DsI3p-3E.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])),a);return s(n,o,r)}function Ye(e,t){let r=le.from(e);r.sourceSpatialReference=r.sourceSpatialReference??t?.sourceSpatialReference??null,(t?.gdbVersion||t?.dynamicDataSource)&&(r=r===e?r.clone():r,r.gdbVersion=e.gdbVersion||t.gdbVersion,r.dynamicDataSource=e.dynamicDataSource?y.from(e.dynamicDataSource):t.dynamicDataSource);let i=t?.infoFor3D;if(i!=null&&Xe(e,i)){r=r===e?r.clone():r,r.formatOf3DObjects=null;let t=s(i),a=ce(i);for(let e of i.queryFormats){if(e===t){r.formatOf3DObjects=e;break}e!==a||r.formatOf3DObjects||(r.formatOf3DObjects=e)}if(!r.formatOf3DObjects)throw new n(`query:unsupported-3d-query-formats`,`Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf`);if(r.outFields==null||!r.outFields.includes(`*`)){r=r===e?r.clone():r,r.outFields??=[];let{originX:t,originY:n,originZ:a,translationX:o,translationY:s,translationZ:c,scaleX:l,scaleY:u,scaleZ:d,rotationX:f,rotationY:p,rotationZ:m,rotationDeg:h}=i.transformFieldRoles;r.outFields.push(t,n,a,o,s,c,l,u,d,f,p,m,h)}}return r}function Xe(e,t){return t!=null&&!0===e.returnGeometry&&e.multipatchOption!==`xyFootprint`&&!e.outStatistics}async function Ze(e,t,n,r){let i=re(e),{source:a,checkValueRange:o}=t,{classificationDefinition:s}=n,c={...n.toJSON(),f:`json`},l=null;if(l=s?.type===`class-breaks-definition`?s.classificationField:s?.attributeField,a){let e={source:a?.toJSON()};c.layer=JSON.stringify(e)}c.classificationDef&&=JSON.stringify(c.classificationDef);let u={query:c};r&&(u={...r,...u});let d={url:i.path,field:l,checkValueRange:o},f=i.path+`/generateRenderer`;return p(f,u).then(e=>Qe(d,e))}function Qe(e,t){let{field:n,checkValueRange:r,url:i}=e,a=t?.data;if(!a)return;if(!r){let e=$e(a);return Promise.resolve(e)}let o=new w({statisticType:`min`,onStatisticField:n}),s=new w({statisticType:`max`,onStatisticField:n}),c=new le({outStatistics:[o,s]});return Ge(i,c).then(e=>{let t=e.features[0].attributes,n=null,r=null;for(let e in t)e.toLowerCase().startsWith(`min`)?n=t[e]:r=t[e];return $e(a,n,r)})}function $e(e,t,n){if(e.type===`classBreaks`){let r=o(e);return{classBreaks:r.classBreakInfos.map((e,i)=>(i===0&&t!=null&&(e.minValue=t),i===r.classBreakInfos.length-1&&n!=null&&(e.maxValue=n),{minValue:e.minValue,maxValue:e.maxValue,label:e.label})),normalizationTotal:r.normalizationTotal}}let{uniqueValueInfos:r}=e;return{uniqueValues:r?.map((e,i)=>(i===0&&t!=null&&(e.value=t),i===r.length-1&&n!=null&&(e.value=n),{count:e.count,value:e.value,label:e.label}))??[]}}var L=class extends i{constructor(e){super(e),this.classificationDefinition=null,this.where=null}};S([r({json:{name:`classificationDef`,write:!0}})],L.prototype,`classificationDefinition`,void 0),S([r({type:String,json:{write:!0}})],L.prototype,`where`,void 0),L=S([u(`esri.rest.support.GenerateRendererParameters`)],L);var R=class extends i{constructor(e){super(e),this.type=`unique-value-definition`,this.attributeField=null,this.attributeField2=null,this.attributeField3=null,this.fieldDelimiter=null}get uniqueValueFields(){let e=[];return this.attributeField&&e.push(this.attributeField),this.attributeField2&&e.push(this.attributeField2),this.attributeField3&&e.push(this.attributeField3),e}};S([l({uniqueValueDef:`unique-value-definition`})],R.prototype,`type`,void 0),S([r()],R.prototype,`attributeField`,void 0),S([r()],R.prototype,`attributeField2`,void 0),S([r()],R.prototype,`attributeField3`,void 0),S([r({json:{write:!0}})],R.prototype,`fieldDelimiter`,void 0),S([r({json:{write:!0}})],R.prototype,`uniqueValueFields`,null),R=S([u(`esri.rest.support.UniqueValueDefinition`)],R);var et=`no_dominant_category`;function tt(e){return{expression:nt(e,{returnFieldName:!0,defaultValue:`'${et}'`})}}function nt(e,t){let{returnFieldName:n,defaultValue:r,layer:i}=t,a=[];if(n&&r){let t=e.map(e=>`${e} <= 0`).join(` AND `);a.push(`WHEN ${t} THEN ${r}`)}for(let t of e){let r=e.reduce((e,n)=>(t!==n&&e.push(`${t} > ${n}`),e),[]).join(` AND `),o=i&&ke(i,t),s=n&&`'${t}'`?`'${t}'`:o?A(t):t;a.push(`WHEN ${r} THEN ${s}`)}return`CASE ${a.join(` `)} ELSE ${r||`0`} END`}function rt(e){return e&&e.map(e=>`$feature["${e}"];`).join(`
`)+`
`||``}function it(e,t=!1){let n=e.map(e=>`"${e}"`);return`\n  var fieldNames = [ ${n.join(`, `)} ];\n  var numFields = ${n.length};\n  var maxValueField = null;\n  var maxValue = -Infinity;\n  var value, i, totalValue = null;\n\n  for(i = 0; i < numFields; i++) {\n    value = $feature[fieldNames[i]];\n\n    if(value > 0) {\n      if(value > maxValue) {\n        maxValue = value;\n        maxValueField = fieldNames[i];\n      }\n      else if (value == maxValue) {\n        maxValueField = null;\n      }\n    }\n    ${t?`
  if(value != null && value >= 0) {
    if (totalValue == null) { totalValue = 0; }
    totalValue = totalValue + value;
  }
  `:``}\n  }\n  `}function at(e){let t=it(e);return`\n  ${rt(e)}\n  ${t}\n  return maxValueField;\n  `}var z=class extends h{constructor(e){super(e),this.adapterName=`layer-adapter`}};S([r({readOnly:!0})],z.prototype,`adapterName`,void 0),S([r({constructOnly:!0})],z.prototype,`layer`,void 0),S([r()],z.prototype,`geometryType`,void 0),S([r()],z.prototype,`objectIdField`,void 0),S([r()],z.prototype,`supportsSQLExpression`,void 0),S([r()],z.prototype,`hasQueryEngine`,void 0),S([r()],z.prototype,`minScale`,void 0),S([r()],z.prototype,`maxScale`,void 0),S([r()],z.prototype,`fullExtent`,void 0),z=S([u(`esri.smartMapping.support.adapters.LayerAdapter`)],z);var ot=/_value$/i,st=Math.LOG10E,ct={SECOND:1e3,MINUTE:6e4,HOUR:36e5};function B(e){return e.map(e=>e.toJSON())}function lt(e,t){let n=[],r=e.layer,i=`featureReduction`in r?r.featureReduction:null,a=i?.type===`binning`,o=i!=null&&`fields`in i?i.fields?.map(e=>e.name?.toLowerCase()).filter(Boolean):[];if(!a||!t)return n;for(let e of t)o.includes(e.toLowerCase())||n.push(e);return n}function V(e,t,n){let r=[];if(t)for(let i of t){let t=e.getField(i);t&&n&&`availableFields`in n&&!n.availableFields?.includes(t.name)&&r.push(t.name)}return r}function H(e,t){let n=e&&e.features;if(n?.length===0)return{avg:null,count:0,max:null,median:null,min:null,nullcount:0,stddev:null,sum:null,variance:null};let r=n?.[0]?.attributes,i={};for(let e in r)i[e.replace(ot,``).toLowerCase()]=r[e];return i.totalcount!=null&&i.totalcount>=i.count&&(i.nullcount=i.totalcount-i.count),delete i.totalcount,i.min===i.max&&i.min!=null&&i.stddev==null&&(i.stddev=i.variance=0),t&&([`min`,`max`,`avg`,`stddev`,`sum`,`variance`].forEach(e=>{i[e]!=null&&(i[e]=Math.ceil(i[e]))}),i.min===i.max&&i.min!=null&&(i.avg=i.min,i.stddev=i.variance=0)),i}function ut(e){let t=[],n=e.classBreaks,r=n[0].minValue,i=n[n.length-1].maxValue;n.forEach(e=>{t.push([e.minValue,e.maxValue])});let a={field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,layer:e.layer};return{min:r,max:i,intervals:t,sqlExpr:U(a),excludeZerosExpr:e.where,normTotal:e.normalizationTotal}}function U(e){let{field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,layer:a}=e,o=ke(a,t),s=t;return n===`percent-of-total`?s=`((${o?A(t):t} / ${i}) * 100)`:n===`log`?s=`(log(${t}) * ${st})`:n===`field`?s=`(${o?A(t):t} / ${r})`:n===`natural-log`?s=`(log(${o?A(t):t}))`:n===`square-root`&&(s=`(power(${o?A(t):t}, 0.5))`),s}function dt(e,t){let n;if(t=t.toLowerCase(),e){for(let r in e)if(r.toLowerCase()!==t){n=e[r];break}}return n}function W(e,t){let n;if(t=t.toLowerCase(),e){for(let r in e)if(r.toLowerCase()===t){n=e[r];break}}return n}function ft(e,t,n,r,i){let a={},o=`countOFExpr`;e&&e.features&&e.features.forEach(e=>{let t=e.attributes,n=dt(t,o),r=W(t,o);n!=null&&r!=null&&n!==0&&(a[n]=r)});let s=[];return T(t,n,r).forEach((e,t)=>{let n=(t+1).toString();s.push({minValue:e[0],maxValue:e[1],count:a.hasOwnProperty(n)?a[n]:0})}),{bins:s,minValue:t,maxValue:n,normalizationTotal:i}}async function pt(e,t){let n=e&&e.features,{field:r,field2:i,field3:a,fieldDelimiter:o,layer:s,view:c,signal:l,labels:u}=t,d=`countOF${(!r||!i)&&r||`Expr`}`,f={},p=!1;for(let e of n){let t=e.attributes,n=W(t,d),s=r?W(t,r):dt(t,d),c=i?W(t,i):null,l=a?W(t,a):null;s===null&&n===0&&(p=!0),(s==null||typeof s==`string`&&s.trim()===``)&&(s=null),i&&(c==null||typeof c==`string`&&c.trim()===``)&&(c=null),a&&(l==null||typeof l==`string`&&l.trim()===``)&&(l=null);let u=s;i&&(u=`${xe(u)}${o}${xe(c)}`,a&&(u=`${u}${o}${xe(l)}`)),f[u]==null?f[u]={count:n,data:u}:f[u].count=f[u].count+n}if(r&&p){let e=r+` is NULL`;try{let t=await s.queryFeatureCount({whereClause:e,view:c,signal:l});return f.null.count=f.null.count+t,mt(f,u)}catch{return x(l),mt(f,u)}}return mt(f,u)}function mt(e,t){if(t)for(let n in e)e[n].label=t[n];return{count:e}}async function ht(e,t,n){let r=e?n.getField(e):null,i=r?n.getFieldDomain(r.name):null;if(i)return i;let{uniqueValueInfos:a}=await n.uniqueValues({field:e,sqlWhere:t.sqlWhere,features:t.features,useFeaturesInView:t.useFeaturesInView,view:t.view,signal:t.signal}),o=a.map(e=>new te({code:e.value}));return new se({codedValues:o})}async function G(e,t){if(!e.returnAllCodedValues)return[];let{field:n,field2:r,field3:i}=e;if(n&&!r){let e=n?t.getField(n):null,r=e?t.getFieldDomain(e.name):null;return r?[r]:[]}let a=[];return n&&(a.push(ht(n,e,t)),r&&(a.push(ht(r,e,t)),i&&a.push(ht(i,e,t)))),Promise.all(a)}function gt(e,t){return Ae(e,new Date(0),t,`milliseconds`).sqlExpression}function _t(e,t){return`EXTRACT(${t} FROM ${e}) * ${ct[t]}`}function vt(e){return e?A([`HOUR`,`MINUTE`,`SECOND`].map(t=>`(${_t(e,t)})`).join(` + `)):null}function K(e){return{viewingMode:e.type===`2d`?`map`:e.viewingMode,scale:e.scale,spatialReference:e.spatialReference?.toJSON()}}function yt(e,t){let n=new Set(e.map(e=>e.value)),r=t.filter(e=>!n.has(e));for(let t of r)e.push({value:t,count:0});e.sort((e,n)=>t.indexOf(e.value)-t.indexOf(n.value));for(let t of e)t.value===`no_dominant_category`&&(t.value=null);return{predominantCategoryInfos:e}}function bt(e){let t=`featureReduction`in e?e.featureReduction:null;return((t!=null&&`fields`in t?t.fields:null)??[]).map(t=>{let n=xt(t,e.fieldsIndex);return n?new me({type:n,name:t.name,alias:t.alias}):null}).filter(c)}function xt(e,t){switch(e.statisticType){case`avg`:case`avg_angle`:return`double`;case`count`:return`integer`;case`min`:case`max`:case`sum`:return e.onStatisticField?t.get(e.onStatisticField)?.type??null:e.onStatisticExpression?e.onStatisticExpression.returnType===`string`?null:`double`:null;case`mode`:return e.onStatisticField?t.get(e.onStatisticField)?.type??null:e.onStatisticExpression?e.onStatisticExpression.returnType===`string`?`string`:`double`:null;default:return null}}function St(e,t){return O(t)?gt(e,t?.name):g(t)?vt(t?.name):null}function Ct(e,t,n){let r=null;for(let i of n){let n=i?e.getField(i):null,a=q(e,{...t,field:i,outStatisticTypes:{include:[`min`,`max`,`sum`,`count`]}},n,!0,!0);r?r.outStatistics=r.outStatistics.concat(a.outStatistics):r=a}return r.where=e.createQuery()?.where,r}function wt(e,t,n,r){return t.map(t=>{let i=new w,a=null,o=null,s=`${t}_value${r?`_${r}`:``}`;if(t===`variance`)a=`var`,o=n;else if(t===`nullcount`){let t=e.objectIdField;a=`count`,o=t&&e.getField(t)?t:`1`,s=`totalcount_value`}else t===`median`?(a=`percentile-continuous`,o=n,i.statisticParameters={value:.5}):(a=t,o=n);return i.statisticType=a,i.onStatisticField=o,i.outStatisticFieldName=s,i})}function q(e,t,n,r=!0,i=!1){let{field:a,normalizationType:o,normalizationField:s,normalizationTotal:c,minValue:l,maxValue:u,filter:d}=t,f=e.supportsSQLExpression?St(e,n)||t.sqlExpression:null,p=U({field:a,normalizationType:o,normalizationField:s,normalizationTotal:c,layer:e}),m=f||p,h=m?j(m,l,u):null,g=N({field:a,normalizationField:s,normalizationType:o}),_=M(t.sqlWhere,g),v=M(_,h),y=we({normalizationField:s,normalizationType:o,sqlExpression:f,supportsSQLExpression:e.supportsSQLExpression,minValue:l,maxValue:u}),b=ne(e.getField(a??void 0)),{include:x,exclude:S}=t.outStatisticTypes||{},ee=Se.filter(e=>(!x||x.includes(e))&&(!S||!S.includes(e))&&(e===`nullcount`?y:!b||e===`count`)&&(e!==`median`||r)),C=e.createQuery();return C.where=M(C.where,v),C.sqlFormat=f?`standard`:null,C.outStatistics=wt(e,ee,m,i?a:void 0),J(C,d),C}function Tt(e,t,n=!0){let{fields:r,filter:i}=t,{include:a,exclude:o}=t.outStatisticTypes||{},s=Se.filter(e=>(!a||a.includes(e))&&(!o||!o.includes(e))&&(e!==`median`||n)),c=new Be;c.where=M(e.createQuery()?.where,t.sqlWhere)??void 0;let l=`new_value`;return c.outPivots=[new ze({sourceFields:r,valueFieldName:l})],c.outStatistics=wt(e,s,l),J(c,i),c}function J(e,t){t&&(e.geometry=t.geometry,e.spatialRelationship=t.spatialRelationship,e.timeExtent=e.timeExtent?.intersection(t.timeExtent)??t.timeExtent,e.distance=t.distance,e.units=t.units)}function Et(e,t){let{field:n,field2:r,field3:i,sqlExpression:a}=t,o=!(!n||!r),s=e.createQuery();return s.where=M(s.where,t.sqlWhere),s.sqlFormat=a?`standard`:null,s.outStatistics=[Dt(o?null:n,o?`1`:a)].filter(Boolean),s.groupByFieldsForStatistics=[n||a,r,i].filter(Boolean),J(s,t.filter),s}function Dt(e,t){let n=`countOF`+(e||`Expr`),r=new w;return r.statisticType=`count`,r.onStatisticField=t?`1`:e,r.outStatisticFieldName=n,r}function Y(e,t,n,r=10,i,a,o){let{min:s,max:c,normTotal:l,excludeZerosExpr:u}=t,d=t.intervals||T(s,c,r),f=t.sqlExpr||n;return Ot(e,d,f,u,i,a,o).then(e=>({bins:e.map((e,t)=>({minValue:d[t][0],maxValue:d[t][1],count:e.status===`fulfilled`?e.value:0})),minValue:s,maxValue:c,normalizationTotal:l}))}function Ot(e,t,n,r,i,a,o){let s=[],c=t.length;for(let e=0;e<c;e++){let i=M(r,M(n+` >= `+t[e][0],t[e][1]===null?``:n+(e===c-1?` <= `:` < `)+t[e][1]));s.push(i)}return Promise.allSettled(s.map(t=>e.queryFeatureCount({whereClause:t,view:i,filter:a,signal:o})))}var kt=`countOFExpr`,At=`lowerBoundary`,jt=`upperBoundary`;function Mt(e,t,n){let r=e.valueExpression||e.sqlExpression,i=e.signal;if(!r){let{field:r,normalizationType:a,normalizationField:o}=e,s=r?t.getField(r):null,c=O(s)||g(s);return{sqlExpression:c?St(t,s):U({field:r,normalizationType:a,normalizationField:o,normalizationTotal:n,layer:t}),sqlWhere:c?null:e.sqlWhere||N({field:r,normalizationType:a,normalizationField:o}),filter:e.filter,signal:i}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,filter:e.filter,signal:i}}async function Nt(e,t,n){let{field:r,normalizationType:i,normalizationField:a,signal:o}=e,s=N({field:r,normalizationType:i,normalizationField:a}),c=new L({classificationDefinition:be({field:r,normalizationType:i,normalizationField:a,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numBins||10}),where:M(s,n)});return t.generateRenderer(c,o).then(e=>{let{normalizationTotal:n,classBreaks:o}=e;return ut({field:r,normalizationType:i,normalizationField:a,normalizationTotal:n,classBreaks:o,where:s,layer:t})})}async function Pt(e,t,r,i,a){let{field:o,sqlExpression:s,normalizationField:c,classificationMethod:l,normalizationType:u}=e,d=o?t.getField(o):null,p=g(d),m=f(d)||p,h=e.numBins||10;if(m){if(u||l)throw new n(`${t.adapterName}:not-supported`,`NormalizationType and classificationMethod are not supported for date-only and time-only fields`);let e=(i-r)/h/1e3,a=e/86400;return new Ie({field:o,expression:s,interval:{unit:p?`seconds`:`days`,value:Math.ceil(p?e:a)},start:r,end:i})}if(l===`defined-interval`)return new Le({field:o,expression:s,normalizationField:c,normalizationTotal:a,normalizationType:u,interval:e.definedInterval??Math.ceil((i-r)/h),start:u?null:r,end:u?null:i,normalizationMinValue:u?r:null,normalizationMaxValue:u?i:null});if(l===`manual`)throw new n(`${t.adapterName}:not-supported`,`Layer does not support manual classificationMethod`);if(l===`natural-breaks`||l===`quantile`||l===`standard-deviation`){let i=U({field:o,normalizationField:c,normalizationTotal:a,normalizationType:u,layer:t}),l=e.minValue!==null&&e.maxValue!==null?j(i,e.minValue,e.maxValue):void 0,d=await Nt(e,t,l);if(!d.intervals)throw new n(`${t.adapterName}:invalid`,`Invalid intervals returned from generate renderer`);let f=[r,...d.intervals.map(e=>e[1])];return new Fe({field:u?null:o,expression:u?i:s,boundaries:f})}return new Pe({field:o,normalizationField:c,normalizationTotal:a,normalizationType:u,expression:s,numBins:h,start:u?null:r,end:u?null:i,normalizationMinValue:u?r:null,normalizationMaxValue:u?i:null})}function Ft(e,t,n,r){return n!=null&&r!=null?Promise.resolve({min:n,max:r}):t.summaryStatistics({...e,outStatisticTypes:{include:[`min`,`max`]}}).then(e=>({min:e.min,max:e.max}))}async function It(e,t,n,r){let{field:i,minValue:a,maxValue:o,filter:s,view:c}=e,l=i?t.getField(i):null,u=ee(l)||_e(l),f=Mt(e,t,n),{min:p,max:m}=await Ft(f,t,a,o);if(p==null||m==null)return{query:null,min:p,max:m};let h=new w({statisticType:`count`,outStatisticFieldName:kt,onStatisticField:`1`}),{where:g,timeExtent:_}=r||{},v=M(g,f.sqlWhere),y=new Re({binParameters:await Pt(e,t,p,m,n),outStatistics:[h],binOrder:e.sortOrder,where:v,timeExtent:_,lowerBoundaryAlias:`lowerBoundary`,upperBoundaryAlias:`upperBoundary`,outTimeZone:c?.timeZone&&u?d(c.timeZone):null});return J(y,s),{query:y,min:p,max:m}}function Lt(e,t=!1){return typeof e==`string`?(t?new Date(`1970-01-01T${e}Z`):new Date(e)).getTime():e}function Rt(e,t,n){let r=g(t);return{...n,bins:e.features.map(e=>({minValue:Lt(e.attributes[At],r),maxValue:Lt(e.attributes[jt],r),count:e.attributes[kt]}))}}function zt(e,t,n){let{valueExpression:r,view:i}=e,{featuresJSON:a,graphics:o,fieldInfos:s}=t,c={field:e.field,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:n,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&i&&(a||o)&&(c.viewInfoParams=K(i),c.timeZone=i.timeZone,c.fieldInfos=s),c}var Bt=5,Vt=null,X=class extends z{constructor(){super(...arguments),this._hasLocalSource=!1,this.adapterName=`in-memory-layer-adapter`}destroy(){this.workerClient?.destroy()}async _waitForLayerViewUpdate(e){if(!e)throw new n(`${this.adapterName}:insufficient-data`,`layerView is required to fetch the features`);let t=new AbortController,r=fe(()=>!e.updating,t.signal);await _(r,5e3,t).catch(e=>{throw pe.getLogger(this).warn(`LayerView is taking too long to update. Aborting fetch from layerView.`),e})}async _fetchFeatureSetFromMemory(e,t,r){let i=this.layer;if(this._hasLocalSource&&`queryFeatures`in i)return i.queryFeatures(e);if(!t)throw new n(`${this.adapterName}:insufficient-data`,`view is required to fetch the features from layerView`);let a=await t.whenLayerView(this.layer);return await this._waitForLayerViewUpdate(a),a.queryFeatures(e,{signal:r})}async _fetchFeaturesFromMemory(e,t,r,i){let a=this.layer,o=i===`json`;if(this._hasLocalSource&&`queryFeatures`in a){let e=await a.queryFeatures(t);return o?B(e.features):e.features}if(await this._waitForLayerViewUpdate(e),o&&`queryFeaturesJSON`in e&&e.queryFeaturesJSON){let{features:n}=await e.queryFeaturesJSON(t,{signal:r});return n}if(!(`queryFeatures`in e))throw new n(`${this.adapterName}:not-supported`,`'queryFeatures' is not supported on the layerView`);let s=await e.queryFeatures(t,{signal:r});return o?B(s.features):s.features}_fetchFeaturesForStats(e,t){return k({field:e.field,field2:e.field2,field3:e.field3,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then(n=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,filter:e.filter,requiredFields:n,signal:e.signal},t))}async _summaryStatsFromClientQuery(e,t){let{view:n,signal:r}=e,i=q(this,e,t),a=await this._fetchFeatureSetFromMemory(i,n,r),o=H(a,O(t)||g(t));return E(o,e.outStatisticTypes)}async _getNormalizationTotalFromMemory(e,t,r){let{featuresJSON:i,graphics:a,layerView:o,query:s}=t,c={include:[`sum`]},l=(!i&&!a&&o&&`querySummaryStatistics`in o?await o.querySummaryStatistics(s,{field:e},{signal:r}):i?await this.workerClient.summaryStatistics({field:e,outStatisticTypes:c},i):await F({attribute:{field:e,outStatisticTypes:c},features:a??[]})).sum;if(l==null)throw new n(`${this.adapterName}:invalid`,`invalid normalizationTotal`);return l}async _summaryStatsFromMemory(e,t){let{view:n,field:r,valueExpression:i,normalizationType:a,signal:o}=e,s={field:r,valueExpression:i,normalizationType:a,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes},{featuresJSON:c,graphics:l,layerView:u,query:d,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`querySummaryStatistics`});return i&&n&&(c||l)&&(s.fieldType=t?.type?b.toJSON(t.type):null,s.viewInfoParams=K(n),s.timeZone=n.timeZone,s.fieldInfos=f),a===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:c,graphics:l,layerView:u,query:d},o)),!c&&!l&&u&&`querySummaryStatistics`in u?u.querySummaryStatistics(d,s,{signal:o}):c?this.workerClient.summaryStatistics(s,c):F({attribute:s,features:l})}async _getFilteredFeatures(e,n){let r=e,i=n?.geometry;if(n?.spatialRelationship===`intersects`&&i){let n=await t(()=>import(`./intersectionOperator-KwqsA1cA.js`),__vite__mapDeps([31,32,1,2,33,34,35,36,37,38,39,40,41,42,43]));r=e.filter(({geometry:e})=>!(!e||!n.execute(e,i)))}return e.length&&`declaredClass`in e[0]&&e[0].declaredClass===`esri.Graphic`?{graphics:r}:{featuresJSON:r}}async _processStatsFromMemoryParams(e){let{features:t,filter:n}=e;if(t?.length)return this._getFilteredFeatures(t,n);let{view:r,field:i,field2:a,field3:o,normalizationField:s,valueExpression:c,layerViewFunc:l,signal:u}=e,d=e.returnGeometry;if(d==null&&c){if(!Vt){let{arcadeUtils:e}=await m();Vt=e}let e=Vt.hasGeometryOperations(c);e&&await Vt.enableGeometryOperations(),d=e}let f=null,p=null,h=null,g=null,_=null;if(r)try{let e=this.layer.type===`subtype-sublayer`?this.layer.parent:this.layer;f=await r.whenLayerView(e),p=l!=null&&f!=null&&l in f&&typeof f[l]==`function`}catch{p=!1}if(p)try{await this._waitForLayerViewUpdate(f);let e=await k({field:i,field2:a,field3:o,normalizationField:s,valueExpression:c});V(this,e,f).length?p=!1:(h=this.layer.createQuery(),h.outFields=e,h.returnGeometry=!1,J(h,n)),f.suspended&&(p=!1)}catch{p=!1}return p||(g=await this._fetchFeaturesForStats({field:i,field2:a,field3:o,valueExpression:c,normalizationField:s,returnGeometry:d,filter:n,view:r,signal:u},`json`),_=(await k({valueExpression:c})).map(e=>this.getField(e)?.toJSON()).filter(Boolean)),{layerView:f,query:h,featuresJSON:g,fieldInfos:_}}async _uvFromClientQuery(e,t){let{view:n,signal:r}=e,i=Et(this,e),a=await this._fetchFeatureSetFromMemory(i,n,r),o=await pt(a,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,view:e.view,signal:e.signal});return D(o,t,e.returnAllCodedValues,`,`)}async _uvFromMemory(e,t){let{view:n,field:r,valueExpression:i,returnAllCodedValues:a,signal:o}=e,{featuresJSON:s,graphics:c,layerView:l,query:u,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryUniqueValues`}),f={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,valueExpression:i,domains:t,returnAllCodedValues:a};return i&&n&&(s||c)&&(f.viewInfoParams=K(n),f.timeZone=n.timeZone,f.fieldInfos=d),!s&&!c&&l&&`queryUniqueValues`in l?l.queryUniqueValues(u,f,{signal:o}):s?this.workerClient.uniqueValues(f,s):He({attribute:f,features:c})}_histogramForField(e){let t=null;return t=e.minValue!=null&&e.maxValue!=null?Promise.resolve({min:e.minValue,max:e.maxValue}):this.summaryStatistics({...e,outStatisticTypes:{include:[`min`,`max`,`count`]}}).then(e=>{if(!e.count)throw new n(`${this.adapterName}:insufficient-data`,`Either the layer has no features or none of the features have data for the field`);return{min:e.min,max:e.max}}),t.then(t=>Y(this,{min:t.min,max:t.max},e.field,e.numBins??void 0,e.view,e.filter,e.signal))}async _histogramFromQueryAttributeBinsFromMemory(e){let{field:t,normalizationType:n,signal:r}=e,i=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAttributeBins`}),{featuresJSON:a,graphics:o,layerView:s,query:c}=i,l=n===`percent-of-total`?e.normalizationTotal??await this._getNormalizationTotalFromMemory(t,i,r):void 0;if(!s||!(`queryAttributeBins`in s)||a||o){let t=zt(e,i,l);return a?this.workerClient.histogram(t,a):P({attribute:t,features:o})}let{query:u,min:d,max:f}=await It(e,this,l,c);if(!u)return{bins:[],minValue:d,maxValue:f,normalizationTotal:l};let p=await s.queryAttributeBins(u,{signal:r});return Rt(p,t?this.getField(t):null,{minValue:d,maxValue:f,normalizationTotal:l})}async _histogramFromMemory(e){let{field:t,signal:n}=e,r=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryHistogram`}),{featuresJSON:i,graphics:a,layerView:o,query:s}=r,c=e.normalizationType===`percent-of-total`?e.normalizationTotal??await this._getNormalizationTotalFromMemory(t,r,n):void 0,l=zt(e,r,c);return!i&&!a&&o&&`queryHistogram`in o?o.queryHistogram(s,l,{signal:n}):i?this.workerClient.histogram(l,i):P({attribute:l,features:a})}_classBreaksFromInterpolation(e){let{minValue:t,maxValue:n}=e,r=e.numClasses||Bt,i=[],a=(n-t)/r;for(let e=0;e<r;e++){let n=t+e*a;i.push({minValue:n,maxValue:n+a})}i[r-1].maxValue=n;let o={classBreaks:i,normalizationTotal:e.normalizationTotal},s=Ce(o,e.classificationMethod);return Promise.resolve(s)}async _classBreaksFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryClassBreaks`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryClassBreaks`in s?s.queryClassBreaks(c,u,{signal:i}):a?this.workerClient.classBreaks(u,a):Ue({attribute:u,features:o})}async _heatmapStatsFromMemory(e){let{view:t,field:n,radius:r,signal:i}=e;ae(t,`InMemoryLayerAdapter: must have a view`);try{let n=await t.whenLayerView(this.layer);if(`queryHeatmapStatistics`in n&&!n.updating&&!e.filter)return await n.queryHeatmapStatistics({field:e.field,radius:e.radius})}catch{x(i)}let{featuresJSON:a,graphics:o}=await this._processStatsFromMemoryParams({...e,returnGeometry:!0}),s=new de({extent:t.extent,tolerance:t.type===`2d`?t.state.resolution:t.pixelSizeAt?.(t.center)}),c={field:n,radius:r,transform:De(s),spatialReference:t.spatialReference?.toJSON(),size:t.size};return a?.length||o?.length?a?this.workerClient.heatmapStatistics(c,a):Ve({attribute:c,features:o}):{min:null,max:null}}getField(e=``){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}createQuery(){return this.layer.createQuery()}async summaryStatistics(e){let{field:t,valueExpression:r,sqlExpression:i,features:a,view:o}=e,s=t?this.getField(t):null,c=!!r,l=o?.type===`3d`;if(!r&&i&&!this.supportsSQLExpression)throw new n(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return c||a||l?this._summaryStatsFromMemory(e,s):this._summaryStatsFromClientQuery(e,s)}async uniqueValues(e){let{valueExpression:t,sqlExpression:r,features:i,view:a}=e,o=await G(e,this),s=!!t,c=a?.type===`3d`;if(!t&&r&&!this.supportsSQLExpression)throw new n(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return s||i||c?this._uvFromMemory(e,o):this._uvFromClientQuery(e,o)}async histogram(e){let{features:t,valueExpression:r,normalizationType:i,sqlExpression:a}=e,o=t||!!r;if(!r&&a&&!this.supportsSQLExpression)throw new n(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return o||i?this._histogramFromMemory(e):this._histogramForField(e)}async classBreaks(e){return!1===e.analyzeData?this._classBreaksFromInterpolation(e):this._classBreaksFromMemory(e)}async queryFeatureCount(e){let{whereClause:t,view:r,signal:i}=e;if(!r)throw new n(`${this.adapterName}:insufficient-data`,`view is required to fetch the features from layerView`);let a=this.layer.createQuery();a.where=M(a.where,t);let o=await r.whenLayerView(this.layer);return await fe(()=>!o.updating,i),o.queryFeatureCount(a,{signal:i})}async generateRenderer(e,t){throw new n(`${this.adapterName}:not-supported`,`Layer does not support generateRenderer operation`)}async predominantCategories(e){let{fields:t,view:n,signal:r,filter:i}=e,a=at(t),o=await this._uvFromMemory({valueExpression:a,view:n,signal:r,filter:i});return yt(o.uniqueValueInfos,t)}async heatmapStatistics(e){return this._heatmapStatsFromMemory(e)}async getSampleFeatures(e,t){let{view:r,sampleSize:i,requiredFields:o,returnGeometry:s,filter:c,signal:l}=e,u=this.layer.createQuery();if(u.outSpatialReference=r?.spatialReference,u.returnGeometry=!!s,u.outFields=o,J(u,c),!r)throw new n(`${this.adapterName}:not-supported`,`view is required to get sample features for Layer`);let d=await r.whenLayerView(this.layer);if(V(this,o,d).length)throw new n(`${this.adapterName}:not-supported`,`Required fields need to be passed in the outFields for Layer`);let f=await this._fetchFeaturesFromMemory(d,u,l,t),p=i!=null&&i>0&&i<=f.length?i:f.length;return a(f,p,1)}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.type===`stream`||!!t.capabilities?.query?.supportsSqlExpression,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=`fullExtent`in t?t.fullExtent:t.parent?.fullExtent,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};S([r({readOnly:!0})],X.prototype,`adapterName`,void 0),S([r({constructOnly:!0})],X.prototype,`layer`,void 0),X=S([u(`esri.smartMapping.support.adapters.InMemoryLayerAdapter`)],X);var Ht=5,Ut=2e4,Wt=4e5,Z=class extends X{constructor(){super(...arguments),this.adapterName=`feature-layer-adapter`}_isStatsSupportedOnService(){let e=this.layer;if(!e.capabilities?.query?.supportsStatistics||this.geometryType===`multipatch`&&!v(e.url)&&e.version<10.5)throw new n(`${this.adapterName}:not-supported`,`Layer does not support statistics query`);return Promise.resolve()}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then(e=>e.features)}_fetchFeaturesJSONFromService(e,t){return this._fetchFeaturesFromService(e,t).then(B)}_summaryStatsFromGenRend(e){let t=e.normalizationType,n=e.normalizationField;return this.classBreaks({field:e.field,numClasses:Ht,classificationMethod:`standard-deviation`,standardDeviationInterval:.25,normalizationType:t,normalizationField:t===`field`?n:void 0,minValue:e.minValue,maxValue:e.maxValue,filter:e.filter,signal:e.signal}).then(t=>{let n,r,i;if(t.classBreakInfos?.some(e=>(e.hasAvg&&(n=e),!!n)),n){let e=n.maxValue-n.minValue;r=n.minValue+e/2,i=4*e}let a={min:t.minValue,max:t.maxValue,avg:r,stddev:i};return E(a,e.outStatisticTypes)})}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),e.normalizationType===`percent-of-total`&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType,e.filter));let n=O(t)||g(t),r=`capabilities`in this.layer?this.layer.capabilities:null,i=q(this,e,t,r?.query?.supportsPercentileStatistics??!1),a=await this.layer.queryFeatures(i,{signal:e.signal}),o=H(a,n);return E(o,e.outStatisticTypes)}async _summaryStatsForFieldsBasic(e){let{outStatisticTypes:t,fields:n}=e,r=[];for(let t=0;t<n.length;t+=50){let i=n.slice(t,t+50),a=Ct(this,e,i);r.push(this.layer.queryFeatures(a,{signal:e.signal}))}let i=(await Promise.all(r)).flatMap(e=>e.features).map(e=>e.attributes).reduce((e,t)=>Object.assign(e,t),{}),a={};for(let e in i){let t=e.match(/^(\w+)_value_/);if(i[e]==null||!t)continue;switch(t[1]){case`min`:a.min=a.min==null?i[e]:Math.min(a.min,i[e]);break;case`max`:a.max=a.max==null?i[e]:Math.max(a.max,i[e]);break;case`sum`:a.sum=(a.sum||0)+i[e];break;case`count`:a.count=(a.count||0)+i[e]}}return E(a,t)}async _summaryStatsForFieldsAdvanced(e,t){let{outStatisticTypes:n,fields:r}=e,i=n?.exclude?.includes(`variance`)||n?.include&&!n.include.includes(`variance`),a=n?.exclude?.includes(`stddev`)||n?.include&&!n.include.includes(`stddev`);if(t.sum==null||!t.count||i&&a)return t;t.avg=t.sum/t.count;let o=[];for(let n=0;n<r.length;n+=50){let i=r.slice(n,n+50),a=Ct(this,e,i);a.outStatistics=[];for(let e of i){let n=`sumOfSquares_${e}`,r=`(power(${ke(this.layer,e)?A(e):e} - ${t.avg}, 2))`,i=new w({statisticType:`sum`,onStatisticField:r,outStatisticFieldName:n});a.outStatistics.push(i)}o.push(this.layer.queryFeatures(a,{signal:e.signal}))}return t.variance=(await Promise.all(o)).reduce((e,t)=>e+Object.values(t.features[0].attributes).reduce((e,t)=>e+t,0),0)/(t.count-1),t.stddev=Math.sqrt(t.variance),E(t,n)}async _summaryStatsForFields(e){let t=await this._summaryStatsForFieldsBasic(e);return this._summaryStatsForFieldsAdvanced(e,t)}async _summaryStatsUsingQueryPivot(e){await this._isStatsSupportedOnService();let t=`capabilities`in this.layer?this.layer.capabilities:null,n=Tt(this,e,t?.query?.supportsPercentileStatistics??!1),r=await this.layer.queryPivot(n,{signal:e.signal}),i=H(r,!1);return E(i,e.outStatisticTypes)}_uvFromGenRenderer(e,t){let n=e.field??void 0,r=new R({attributeField:n}),i=new L({classificationDefinition:r});return this.generateRenderer(i,e.signal).then(e=>{let t={},r=this.getField(n);return e.uniqueValues.forEach(e=>{let n=e.value;n!=null&&n!==``&&(typeof n!=`string`||n.trim()!==``&&n.toLowerCase()!==`<null>`)||(n=null),t[n]==null?t[n]={count:e.count,data:ie(r)&&n?Number(n):n}:t[n].count=t[n].count+e.count}),{count:t}}).then(n=>D(n,[t],e.returnAllCodedValues))}async _uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(Et(this,e),{signal:e.signal})).then(t=>pt(t,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,view:e.view,signal:e.signal})).then(n=>D(n,t,e.returnAllCodedValues,`,`))}_getNormalizationTotal(e,t,n,r){return e&&t===`percent-of-total`?this.summaryStatistics({field:e,outStatisticTypes:{include:[`sum`]},filter:n,signal:r}).then(e=>e.sum):Promise.resolve(null)}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.filter,e.signal).then(t=>{let n=Mt(e,this,t);return Ft(n,this,e.minValue,e.maxValue).then(r=>{let i=r.min,a=r.max;if(i==null||a==null)return{bins:[],minValue:i,maxValue:a,normalizationTotal:t};let o=e.numBins||10,s=T(i,a,o),c=Gt(n.sqlExpression,s,e.minValue!=null&&e.maxValue!=null),l=new w({statisticType:`count`,outStatisticFieldName:`countOFExpr`,onStatisticField:`1`}),u=this.layer.createQuery();return u.where=M(u.where,n.sqlWhere),u.sqlFormat=`standard`,u.outStatistics=[l],u.groupByFieldsForStatistics=[c],u.orderByFields=[c],J(u,e.filter),this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(u,{signal:n.signal})).then(e=>ft(e,i,a,o,t))})})}async _histogramForFields(e){let{min:t,max:n}=await Ft({fields:e.fields,sqlWhere:e.sqlWhere,filter:e.filter,signal:e.signal},this,e.minValue,e.maxValue);if(t==null||n==null)return{bins:[],minValue:t,maxValue:n};let r=`newField`,i=e.numBins||10,a=Gt(r,T(t,n,i),e.minValue!=null&&e.maxValue!=null),o=new w({statisticType:`count`,outStatisticFieldName:`countOFExpr`,onStatisticField:r}),s=new Be,{where:c,timeExtent:l}=this.createQuery();return s.where=M(c,e.sqlWhere),s.outPivots=[new ze({sourceFields:e.fields,valueFieldName:r})],s.outStatistics=[o],s.groupByFieldsForStatistics=[a],s.orderByFields=[a],s.timeExtent=l,J(s,e.filter),this._isStatsSupportedOnService().then(()=>this.layer.queryPivot(s,{signal:e.signal})).then(e=>ft(e,t,n,i))}async _histogramFromQueryAttributeBins(e){let{field:t,normalizationType:n,filter:r,signal:i}=e,a=await this._getNormalizationTotal(t,n,r,i),{query:o,min:s,max:c}=await It(e,this,a,this.createQuery());if(!o)return{bins:[],minValue:s,maxValue:c,normalizationTotal:a};let l=await this.layer.queryAttributeBins(o,{signal:i});return Rt(l,t?this.getField(t):null,{minValue:s,maxValue:c,normalizationTotal:a})}_classBreaksFromGenRend(e){let{field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,signal:a}=e,o=N({field:t,normalizationType:n,normalizationField:r}),s=U({field:t,normalizationType:n,normalizationField:r,normalizationTotal:i,layer:this}),c=j(s,e.minValue,e.maxValue),l=be({field:t,normalizationType:n,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||Ht}),u=new L({classificationDefinition:l});return u.where=M(o,c),this.generateRenderer(u,a).then(t=>Ce(t,e.classificationMethod))}async summaryStatistics(e){let{field:t,fields:r,normalizationType:i,valueExpression:a,sqlExpression:o,view:s,features:c,useFeaturesInView:l}=e,u=t?this.getField(t):null,d=O(u)||g(u),f=a&&!(o&&this.supportsSQLExpression),p=this._hasLocalSource||c||l,m=s?.type===`3d`;if(r?.length){let t={...e,fields:r};if(!this.layer.capabilities?.operations?.supportsQueryPivot)return await this._summaryStatsForFields(t);try{return await this._summaryStatsUsingQueryPivot(t)}catch{return await this._summaryStatsForFields(t)}}if(p||f)return f||c||l||m||this._hasLocalSource&&!this.layer.capabilities.query.supportsStatistics?this._summaryStatsFromMemory(e,u):this._summaryStatsFromClientQuery(e,u);if(!this.supportsSQLExpression&&(d||o||i===`natural-log`||i===`square-root`))throw new n(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return(i&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,u)).catch(()=>(x(e.signal),this._summaryStatsFromMemory(e,u)))}async uniqueValues(e){let{valueExpression:t,sqlExpression:n,features:r,useFeaturesInView:i,signal:a}=e,o=t&&!(n&&this.supportsSQLExpression),s=this._hasLocalSource||r||i||o,c=e.view,l=c?.type===`3d`,u=await G(e,this);return s?o||r||i||l||this._hasLocalSource&&!this.layer.capabilities.query.supportsStatistics?this._uvFromMemory(e,u):this._uvFromClientQuery(e,u):this._uvFromServiceQuery(e,u).catch(t=>(x(a),!e.field||e.field2||e.field3||e.filter?t:this._uvFromGenRenderer(e,u[0]))).catch(()=>(x(a),l?this._uvFromMemory(e,u):this._uvFromClientQuery(e,u)))}async histogram(e){let{field:t,normalizationType:r,normalizationField:i,classificationMethod:a,view:o,filter:s,signal:c}=e,l=t?this.getField(t):null,u=O(l)||g(l),d=e.valueExpression||e.sqlExpression,f=e.valueExpression&&!(e.sqlExpression&&this.supportsSQLExpression),p=this._hasLocalSource||e.features||e.useFeaturesInView||f,m=this.supportsSQLExpression,h=!a||a===`equal-interval`,_=e.minValue,v=e.maxValue,y=_!=null&&v!=null,b=e.numBins||10;if(e.fields?.length){if(!m)throw new n(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);if(!this.layer.capabilities?.operations?.supportsQueryPivot)throw new n(`${this.adapterName}:not-supported`,`Layer does not support pivot queries`);return this._histogramForFields(e)}if(p)return this._histogramFromMemory(e);if(this.layer.capabilities?.operations?.supportsQueryBins&&e.useQueryAttributeBins)try{return await this._histogramFromQueryAttributeBins(e)}catch{return x(c),this._histogramFromQueryAttributeBinsFromMemory(e)}if((d||m)&&h){if(!m&&(d||r===`natural-log`||r===`square-root`))throw new n(`${this.adapterName}:not-supported`,`Layer does not support standardized SQL expression for queries`);return this._histogramForExpr(e)}if(u&&h)throw new n(`${this.adapterName}:not-supported`,`Normalization and date field are not allowed when layer does not support standardized SQL expression for queries`);return r||!h?Nt(e,this).then(a=>{if(!y)return Y(this,a,t,b,o,s,c);if(_>a.max||v<a.min)throw new n(`${this.adapterName}:insufficient-data`,`Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field`);if(h)return Y(this,{min:_,max:v,sqlExpr:a.sqlExpr,excludeZerosExpr:a.excludeZerosExpr},t,b,o,s,c);{let n={field:t,normalizationType:r,normalizationField:i,normalizationTotal:a.normTotal,layer:this},l=U(n),u=j(l,_,v);return Nt(e,this,u).then(e=>Y(this,e,t,b,o,s,c))}}):this._histogramForField(e)}async classBreaks(e){let t=!1!==e.analyzeData,n=this._hasLocalSource||e.features||e.useFeaturesInView||e.valueExpression||e.filter;return t&&n?this._classBreaksFromMemory(e):(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch(()=>(x(e.signal),this._classBreaksFromMemory(e)))}async queryFeatureCount(e){if(this._hasLocalSource)throw new n(`${this.adapterName}:not-supported`,`Layer does not support count query`);let t=this.layer,r=t.createQuery();return r.where=M(r.where,e.whereClause),J(r,e.filter),t.queryFeatureCount(r,{signal:e.signal})}async generateRenderer(e,t){let r=this.layer;if(this._hasLocalSource||r.version<10.1)throw new n(`${this.adapterName}:not-supported`,`Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)`);let i=r.createQuery();return e.where=M(e.where,i.where),Ze(r.parsedUrl?.path??``,{source:r.dynamicDataSource??void 0,gdbVersion:r.gdbVersion??void 0},e,{signal:t})}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new n(`${this.adapterName}:not-supported`,`Layer does not support advanced SQL expressions and standardized queries`);let{fields:t,view:r,signal:i,filter:a}=e,o=at(t),s=tt(t),c=r&&this._hasLocalSource?await this._uvFromMemory({valueExpression:o,view:r,signal:i,filter:a}):await this._uvFromServiceQuery({sqlExpression:s.expression,valueExpression:o,signal:i,filter:a});return yt(c.uniqueValueInfos,t)}async getSampleFeatures(e,t){let{view:n,requiredFields:r,returnGeometry:i,filter:o,signal:s}=e,c=e.sampleSize;if(c==null||c===0)return[];let l=this.layer.createQuery(),u=t===`json`;l.outSpatialReference=n?.spatialReference,l.returnGeometry=!!i,l.outFields=r,J(l,o);let d=[],f=!1;if(n)try{let i=await n.whenLayerView(this.layer);if(f=!V(this,r,i).length,f){if(c>=1&&!e.filter&&`getSampleFeatures`in i){await this._waitForLayerViewUpdate(i);let e=await i.getSampleFeatures({minFeatureCount:c,sampleSize:c});if(e!=null)return u?e:e.map(e=>he.fromJSON(e))}if(d=await this._fetchFeaturesFromMemory(i,l,s,t),d.length>=c&&c>0)return a(d,c,1)}}catch{x(s)}try{if(this._hasLocalSource)return f?d:u?await this._fetchFeaturesJSONFromService(l,s):await this._fetchFeaturesFromService(l,s);let t=await this.queryFeatureCount({view:n,filter:o,signal:s}),r=this.layer.capabilities.query.maxRecordCount,i=c===-1?t:c;if(i=r&&i>r?r:i,t<=d.length||d.length>=r)return d;if(l.maxAllowableOffset=e.resolution||(n?n.extent.width/n.width/n.scale:ue(this.layer.spatialReference))*Wt,t<=i)return u?await this._fetchFeaturesJSONFromService(l,s):await this._fetchFeaturesFromService(l,s);if(t<=Ut){let e=this.layer.createQuery();J(e,o);let t=await this.layer.queryObjectIds();return l.objectIds=a(t,i,1),u?await this._fetchFeaturesJSONFromService(l,s):await this._fetchFeaturesFromService(l,s)}return this.layer.capabilities?.query?.supportsPagination&&(l.num=Math.min(i,Ut)),u?await this._fetchFeaturesJSONFromService(l,s):await this._fetchFeaturesFromService(l,s)}catch{return x(s),d}}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.capabilities?.query?.supportsSqlExpression,this._hasLocalSource=t.type===`parquet`||!t.url&&!!t.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};function Gt(e,t,n){let r=[],i=t.length;return t.forEach((t,a)=>{let[o,s]=t,c=null;c=a!==0||n?a!==i-1||n?M(`${e} >= ${o}`,`${e} ${a===i-1?` <= `:` < `} ${s}`):`${e} >= ${o}`:`${e} < ${s}`,r.push(`WHEN (`+c+`) THEN `+(a+1))}),[`CASE`,r.join(` `),`ELSE 0`,`END`].join(` `)}S([r({readOnly:!0})],Z.prototype,`adapterName`,void 0),S([r({constructOnly:!0})],Z.prototype,`layer`,void 0),Z=S([u(`esri.smartMapping.support.adapters.FeatureLayerAdapter`)],Z);var Kt=class extends Z{constructor(){super(...arguments),this.adapterName=`csv-layer-adapter`}async _createGenerateRendererResult(e,t,r,i,a){let o=e?.features;if(!o?.length)throw new n(`csv-layer-adapter:insufficient-data`,`No features are available to calculate statistics`);let s=B(o),c=null;if(i===`percent-of-total`&&(c=(await this.workerClient.summaryStatistics({field:t},s)).sum,c==null))throw new n(`csv-layer-adapter:invalid`,`invalid normalizationTotal`);if(a?.type===`class-breaks-definition`){let e=(await Me({field:t,normalizationType:i,normalizationField:r,normalizationTotal:c},s)).filter(e=>Number.isFinite(e));return ye({definition:a,values:e,normalizationTotal:c})}let l=(await Me({field:t},s)).filter(e=>e!=null&&typeof e==`string`&&e.trim()!==``);return ve(l)}generateRenderer(e,t){let n=e.classificationDefinition,r=null,i=null,a=null;n?.type===`class-breaks-definition`?(r=n.classificationField,i=n.normalizationField,a=n.normalizationType):r=n?.attributeField;let o=this.layer;return k({field:r,normalizationField:i}).then(s=>{let c=o.createQuery();return c.returnGeometry=!1,c.outFields=s,c.where=M(c.where,e.where),o.queryFeatures(c,{signal:t}).then(e=>this._createGenerateRendererResult(e,r,i,a,n))})}load(e){let t=this.layer.load(e).then(async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};S([r({readOnly:!0})],Kt.prototype,`adapterName`,void 0),Kt=S([u(`esri.smartMapping.support.adapters.CSVLayerAdapter`)],Kt);var qt=class extends Z{constructor(){super(...arguments),this.adapterName=`feature-layer-binning-adapter`}async _getNormalizationTotalFromMemory(e,t,r){let{featuresJSON:i,graphics:a,layerView:o,query:s}=t,c={include:[`sum`]},l=(!i&&!a&&o&&`queryAggregateSummaryStatistics`in o?await o.queryAggregateSummaryStatistics(s,{field:e,outStatisticTypes:c},{signal:r}):i?await this.workerClient.summaryStatistics({field:e},i):await F({attribute:{field:e,outStatisticTypes:c},features:a})).sum;if(l==null)throw new n(`${this.adapterName}:invalid`,`invalid normalizationTotal`);return l}async _processStatsFromMemoryParams(e){let{features:t,filter:r}=e;if(t?.length)return this._getFilteredFeatures(t,r);let{view:i,field:a,field2:o,field3:s,normalizationField:c,valueExpression:l,returnGeometry:u,layerViewFunc:d,signal:f}=e,p=null,m=null,h=null,g=null,_=null;if(i)try{if(p=await i.whenLayerView(this.layer),ae(p),m=d!=null&&d in p&&typeof p[d]==`function`,m){await this._waitForLayerViewUpdate(p);let e=await k({field:a,field2:o,field3:s,normalizationField:c,valueExpression:l});lt(this,e).length?m=!1:(h=`createAggregateQuery`in p?p.createAggregateQuery():null,h?(h.outFields=e,h.returnGeometry=!1,J(h,r)):m=!1),p.suspended&&(m=!1)}}catch{m=!1}if(!m&&(_=bt(this.layer).map(e=>e.toJSON()),g=await this._fetchFeaturesForStats({field:a,field2:o,field3:s,valueExpression:l,normalizationField:c,returnGeometry:u,filter:r,view:i,signal:f},`json`),!g?.length))throw new n(`${this.adapterName}:insufficient-data`,`No features are available to calculate statistics`);return{layerView:p,query:h,featuresJSON:g,fieldInfos:_}}async _summaryStatsFromMemory(e,t){let{view:n,field:r,valueExpression:i,normalizationType:a,signal:o}=e,s={field:r,valueExpression:i,normalizationType:a,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes},{featuresJSON:c,graphics:l,layerView:u,query:d,fieldInfos:f}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateSummaryStatistics`});return i&&n&&(c||l)&&(s.fieldType=t?.type?b.toJSON(t.type):null,s.viewInfoParams=K(n),s.timeZone=n.timeZone,s.fieldInfos=f),a===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:c,graphics:l,layerView:u,query:d},o)),!c&&!l&&u&&`queryAggregateSummaryStatistics`in u?u.queryAggregateSummaryStatistics(d,s,{signal:o}):c?this.workerClient.summaryStatistics(s,c):F({attribute:s,features:l})}async _uvFromMemory(e,t){let{view:n,field:r,valueExpression:i,returnAllCodedValues:a,signal:o}=e,{featuresJSON:s,graphics:c,layerView:l,query:u,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateUniqueValues`}),f={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:`,`,valueExpression:i,domains:t,returnAllCodedValues:a};return i&&n&&(s||c)&&(f.viewInfoParams=K(n),f.timeZone=n.timeZone,f.fieldInfos=d),!s&&!c&&l&&`queryAggregateUniqueValues`in l?l.queryAggregateUniqueValues(u,f,{signal:o}):s?this.workerClient.uniqueValues(f,s):He({attribute:f,features:c})}async _histogramFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateHistogram`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryAggregateHistogram`in s?s.queryAggregateHistogram(c,u,{signal:i}):a?this.workerClient.histogram(u,a):P({attribute:u,features:o})}async _classBreaksFromMemory(e){let{view:t,field:n,valueExpression:r,signal:i}=e,{featuresJSON:a,graphics:o,layerView:s,query:c,fieldInfos:l}=await this._processStatsFromMemoryParams({...e,layerViewFunc:`queryAggregateClassBreaks`}),u={field:n,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(a||o)&&(u.viewInfoParams=K(t),u.timeZone=t.timeZone,u.fieldInfos=l),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(n,{featuresJSON:a,graphics:o,layerView:s,query:c},i)),!a&&!o&&s&&`queryAggregateClassBreaks`in s?s.queryAggregateClassBreaks(c,u,{signal:i}):a?this.workerClient.classBreaks(u,a):Ue({attribute:u,features:o})}getField(e=``){return bt(this.layer)?.find(t=>t.name.toLowerCase()===e?.toLowerCase())}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(e,t){return null}async summaryStatistics(e){let{field:t}=e,r=t?this.getField(t):null,i=O(r)||g(r),a=e.sqlExpression&&!e.valueExpression&&!t;if(i||a)throw new n(`${this.adapterName}:not-supported`,`Date field and sqlExpression are not supported`);return this._summaryStatsFromMemory(e,r)}async uniqueValues(e){let t=await G(e,this);return this._uvFromMemory(e,t)}async histogram(e){let{field:t}=e,r=t?this.getField(t):null,i=O(r)||g(r),a=e.sqlExpression&&!e.valueExpression&&!t;if(i||a)throw new n(`${this.adapterName}:not-supported`,`Date field and sqlExpression are not supported`);return this._histogramFromMemory(e)}async classBreaks(e){return(!1===e.analyzeData?this._classBreaksFromInterpolation(e):this._classBreaksFromMemory(e)).catch(()=>(x(e.signal),this._classBreaksFromMemory(e)))}async queryFeatureCount(e){let t=await e.view?.whenLayerView(this.layer);if(!t||!(`queryAggregateCount`in t)||!t.queryAggregateCount)throw new n(`${this.adapterName}:not-supported`,`LayerView is not supported.`);await this._waitForLayerViewUpdate(t);let r=t.createAggregateQuery();return r.where=M(r.where,e.whereClause),J(r,e.filter),t.queryAggregateCount(r,{signal:e.signal})}generateRenderer(e,t){throw new n(`${this.adapterName}:not-supported`,`'generateRenderer' is not supported.`)}heatmapStatistics(e){throw new n(`${this.adapterName}:not-supported`,`'heatmapStatistics' is not supported.`)}async predominantCategories(e){let{fields:t,view:n,signal:r}=e,i=at(t),a=await this._uvFromMemory({valueExpression:i,view:n,signal:r});return yt(a.uniqueValueInfos,t)}async getSampleFeatures(e,t){let{view:r,sampleSize:i,requiredFields:o,returnGeometry:s,filter:c,signal:l}=e;if(!r)throw new n(`${this.adapterName}:not-supported`,`'view' is required to get sample features for binning.`);if(r.type===`3d`)throw new n(`${this.adapterName}:not-supported`,`3d 'view' is not supported to get sample features for binning.`);let u=await r.whenLayerView(this.layer);if(!(`queryAggregateJSON`in u&&u.queryAggregateJSON&&`queryAggregates`in u&&u.queryAggregates))throw new n(`${this.adapterName}:not-supported`,`LayerView is not supported.`);if(await this._waitForLayerViewUpdate(u),lt(this,o).length)throw new n(`${this.adapterName}:insufficient-data`,`Layer does not have required fields`);let d=t===`json`,f=u.createAggregateQuery();f.outSpatialReference=r?.spatialReference,f.returnGeometry=!!s,f.outFields=o,J(f,c);let{features:p}=d?await u.queryAggregateJSON(f,{signal:l}):await u.queryAggregates(f,{signal:l});return p.length&&i!=null&&i>0&&i<=p.length?a(p,i,1):p}load(e){let t=this.layer.load(e).then(async t=>{let r=`featureReduction`in t?t.featureReduction:null;if(r?.type!==`binning`&&r?.type!==`cluster`)throw new n(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${r?.type} is not supported`);this.geometryType=r?.type===`cluster`?`point`:`polygon`,this.objectIdField=null,this.supportsSQLExpression=!1,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this.workerClient=I.getInstance(),await this.workerClient.open(e.signal)});return this.addResolvingPromise(t),Promise.resolve(this)}};S([r({readOnly:!0})],qt.prototype,`adapterName`,void 0),qt=S([u(`esri.smartMapping.support.adapters.FeatureLayerBinningAdapter`)],qt);var Jt=qt,Q=class extends z{constructor(e){super(e),this._featureLayerAdapter=null,this.workerClient=null,this.adapterName=`scene-layer-adapter`}destroy(){this.workerClient?.destroy()}_hasCachedStatistics(e){return this.layer.hasCachedStatistics(e)}_updateQuery(e,t=[],n=[]){if(!e||!n.length)return e;let r=this.layer.objectIdField,i=e.clone(),a=t.filter(e=>{let t=this.layer.getField(e);return!n.includes(t.name)});return i.outFields=a.some(e=>this.layer.getField(e).name===r)?a:[...a,r],i}async _fetchFeaturesFromMemory(e,t,r){if(!e)throw new n(`scene-layer-adapter:insufficient-data`,`view is required to fetch the features from layerView`);let i=await e.whenLayerView(this.layer),a=new AbortController,o=a.signal,s=fe(()=>!i.updating,o);await _(s,5e3,a);let c=V(this,r,i);x(o);let l=this._updateQuery(t,r??[],c),u=await i.queryFeatures(l,{signal:o});x(o);let d=u.features;return c.length?i.whenGraphicAttributes(d,c):d}async _fetchFeaturesJSONFromMemory(e,t,n){return this._fetchFeaturesFromMemory(e,t,n).then(B)}_fetchFeaturesForStats(e,t){return k({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then(n=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:n,signal:e.signal},t))}async _processStatsFromMemoryParams(e){let t=e.features;if(t?.length)return t.length&&`declaredClass`in t[0]&&t[0].declaredClass===`esri.Graphic`?{graphics:t}:{featuresJSON:t};let{view:r,field:i,normalizationField:a,valueExpression:o,signal:s}=e,c=await this._fetchFeaturesForStats({field:i,valueExpression:o,normalizationField:a,view:r,signal:s},null);if(!c?.length)throw new n(`scene-layer-adapter:insufficient-data`,`No features are available to calculate statistics`);return{graphics:c}}_getCachedStatistics(e,t){let r=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.minValue||e.maxValue?Promise.reject(new n(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified`)):r.queryCachedStatistics(t?.name,{signal:e.signal}).then(e=>{let t=e.stats,{min:n,max:r,totalValuesCount:i}=t,{avg:a,stddev:o,sum:s,variance:c,count:l}=t;return n===0&&r===0||(a=a===0?null:a,s=s===0?null:s,o=o===0?null:o,c=c===0?null:c,l=l===0?null:l),l??(s!=null&&a!=null?l=Math.round(s/a):i!=null&&(l=i)),{avg:a,count:l,max:r,min:n,stddev:o,sum:s,variance:c}})}async _getNormalizationTotal(e,t,r){let i={include:[`sum`]},a=(t?await this.workerClient.summaryStatistics({field:e,outStatisticTypes:i},t):await F({attribute:{field:e,outStatisticTypes:i},features:r})).sum;if(a==null)throw new n(`scene-layer-adapter:invalid`,`invalid normalizationTotal`);return a}async _getSummaryStatisticsFromMemory(e,t){let{view:n,field:r,normalizationField:i,valueExpression:a}=e,{featuresJSON:o,graphics:s}=await this._processStatsFromMemoryParams(e),c={field:r,valueExpression:a,normalizationType:e.normalizationType,normalizationField:i,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,outStatisticTypes:e.outStatisticTypes};return e.valueExpression&&n&&o&&(c.fieldType=t?.type?b.toJSON(t.type):null,c.viewInfoParams=K(n),c.timeZone=n.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(c.normalizationTotal=await this._getNormalizationTotal(r,o,s)),o?this.workerClient.summaryStatistics(c,o):F({attribute:c,features:s})}_getCachedStatisticsForUniqueValues(e,t){let r=this.layer,i=t?.name,a=t&&e.field?this.getFieldDomain(e.field):null;return e.valueExpression||e.sqlExpression||e.sqlWhere?Promise.reject(new n(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified`)):r.queryCachedStatistics(i,{signal:e.signal}).then(n=>{let a=n.stats;if(!a.mostFrequentValues)throw Error();let o=n.labels?.labels,s={},c=[],l=`countOF`+i;a.mostFrequentValues.forEach(e=>{let n=new he({attributes:{}});n.attributes[i]=t&&t.name!==r.objectIdField&&(ie(t)||O(t))?Number(e.value):e.value,n.attributes[l]=e.count,c.push(n)}),o&&o.forEach(e=>{s[e.value]=e.label});let u=new C({features:c});return pt(u,{layer:this,field:e.field,labels:s,view:e.view,signal:e.signal})}).then(t=>D(t,[a],e.returnAllCodedValues))}async _getUniqueValuesFromMemory(e,t){let{view:n,field:r,field2:i,field3:a,valueExpression:o,returnAllCodedValues:s}=e,c={field:r,field2:i,field3:a,fieldDelimiter:`,`,valueExpression:o,domains:t,returnAllCodedValues:s},{featuresJSON:l,graphics:u}=await this._processStatsFromMemoryParams(e);return e.valueExpression&&n&&l&&(c.viewInfoParams=K(n),c.timeZone=n.timeZone),l?this.workerClient.uniqueValues(c,l):He({attribute:c,features:u})}_getCachedStatisticsForHistogram(e,t){let r=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.normalizationType?Promise.reject(new n(`scene-layer-adapter:not-supported`,`This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified`)):r.queryCachedStatistics(t&&t.name,{signal:e.signal}).then(t=>{let n=t.stats,{minValue:r,maxValue:i}=e,a=r??n.min,o=i??n.max,s=e.numBins||10,c=Yt(n.histogram,a,o,s);return ft(c,a,o,s)})}async _getClassBreaksFromMemory(e){let{view:t,field:n,normalizationField:r,valueExpression:i}=e,{featuresJSON:a,graphics:o}=await this._processStatsFromMemoryParams(e),s={field:n,valueExpression:i,normalizationType:e.normalizationType,normalizationField:r,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return e.valueExpression&&t&&a&&(s.viewInfoParams=K(t),s.timeZone=t.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(s.normalizationTotal=await this._getNormalizationTotal(n,a,o)),a?this.workerClient.classBreaks(s,a):Ue({attribute:s,features:o})}async _getHistogramFromMemory(e){let{view:t,field:n}=e,{featuresJSON:r,graphics:i}=await this._processStatsFromMemoryParams(e),a={field:n,valueExpression:e.valueExpression,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return e.valueExpression&&t&&r&&(a.viewInfoParams=K(t),a.timeZone=t.timeZone),e.normalizationType===`percent-of-total`&&e.normalizationTotal==null&&(a.normalizationTotal=await this._getNormalizationTotal(n,r,i)),r?this.workerClient.histogram(a,r):P({attribute:a,features:i})}getField(e){return this.layer.getField(e??``)}getFieldUsageInfo(e){let t=this.getField(e);if(!t)return null;let n=this.layer.getFieldUsageInfo(t.name);return{supportsLabelingInfo:n.supportsLabelingInfo,supportsPopupTemplate:n.supportsPopupTemplate,supportsRenderer:n.supportsRenderer,supportsLayerQuery:n.supportsLayerQuery,supportsStatistics:!0}}getFieldDomain(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(e,t):null}createQuery(){return this.layer.createQuery()}summaryStatistics(e){let t=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.summaryStatistics(e);if(e.filter)throw new n(`scene-layer-adapter:not-supported`,`filter is not supported`);return this._hasCachedStatistics(t?.name)?this._getCachedStatistics(e,t).catch(()=>(x(e.signal),this._getSummaryStatisticsFromMemory(e,t))):this._getSummaryStatisticsFromMemory(e,t)}async uniqueValues(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.uniqueValues(e);if(e.filter)throw new n(`scene-layer-adapter:not-supported`,`filter is not supported`);let t=await G(e,this),{field:r,field2:i}=e,a=r&&i,o=this.getField(r);return!a&&o&&this._hasCachedStatistics(o.name)?this._getCachedStatisticsForUniqueValues(e,o).catch(()=>(x(e.signal),this._getUniqueValuesFromMemory(e,t))):this._getUniqueValuesFromMemory(e,t)}histogram(e){let t=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.histogram(e);if(e.filter)throw new n(`scene-layer-adapter:not-supported`,`filter is not supported`);return t&&this._hasCachedStatistics(t.name)?this._getCachedStatisticsForHistogram(e,t).catch(()=>(x(e.signal),this._getHistogramFromMemory(e))):this._getHistogramFromMemory(e)}classBreaks(e){let t=this.getField(e.field);if(this._featureLayerAdapter)return this._featureLayerAdapter.classBreaks(e);if(e.filter)throw new n(`scene-layer-adapter:not-supported`,`filter is not supported`);return this._hasCachedStatistics(t?.name)?Promise.reject(new n(`scene-layer-adapter:not-supported`,`Cached stats not supported`)):this._getClassBreaksFromMemory(e)}queryFeatureCount(e){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(e):Promise.reject(new n(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support count query`))}generateRenderer(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(e,t):Promise.reject(new n(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support generateRenderer operation`))}heatmapStatistics(e){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(e):Promise.reject(new n(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support heatmapStatistics operation`))}async predominantCategories(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(e);throw new n(`scene-layer-adapter:not-supported`,`SceneLayer without associated FeatureLayer does not support predominantCategories`)}async getSampleFeatures(e,t){if(e.filter)throw new n(`scene-layer-adapter:not-supported`,`filter is not supported`);let{view:r,sampleSize:i,requiredFields:o,returnGeometry:s,signal:c}=e,l=t===`json`,u=this.createQuery();u.outFields=o,u.returnGeometry=!!s,u.where=null,u.num=i;let d=[];try{if(d=l?await this._fetchFeaturesJSONFromMemory(r,u,o):await this._fetchFeaturesFromMemory(r,u,o),d.length&&i!=null&&i>0&&i<=d.length)return a(d,i,1)}catch{x(c)}let f=null;if(this._featureLayerAdapter){let n={...e};delete n.view,f=await this._featureLayerAdapter.getSampleFeatures(n,t)}return f?.length?f:a(d,d.length,1)}load(e){let t=this.layer.load(e).then(async t=>{this.workerClient=I.getInstance(),await this.workerClient.open(e.signal);let n=t.associatedLayer;if(this.geometryType=t.geometryType,n!=null)return this._featureLayerAdapter=new Z({layer:n}),this._featureLayerAdapter.load(e).then(()=>{this.objectIdField=this._featureLayerAdapter.objectIdField,this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression,this.minScale=this._featureLayerAdapter.minScale,this.maxScale=this._featureLayerAdapter.maxScale,this.fullExtent=this._featureLayerAdapter.fullExtent});this.objectIdField=t.objectIdField,this.supportsSQLExpression=!1,this.hasQueryEngine=!1,this.fullExtent=t.fullExtent});return this.addResolvingPromise(t),Promise.resolve(this)}};function Yt(e,t=e.minimum,n=e.maximum,r){let i=[];for(let e=0;e<r;e++)i[e]=0;let a=e.counts.length,o=e.minimum,s=e.maximum;for(let c=0;c<a;c++){let l=(c+.5)/a,u=((1-l)*o+l*s-t)/(n-t)*r;u>=0&&u<=r&&(i[u===r?r-1:Math.floor(u)]+=e.counts[c])}let c=[];return i.forEach((e,t)=>{let n=new he({attributes:{}});n.attributes.EXPR_1=t+1,n.attributes.countOFExpr=e,c.push(n)}),new C({features:c})}S([r({readOnly:!0})],Q.prototype,`adapterName`,void 0),S([r({constructOnly:!0})],Q.prototype,`layer`,void 0),Q=S([u(`esri.smartMapping.support.adapters.SceneLayerAdapter`)],Q);var $=class extends Q{constructor(e){super(e),this.adapterName=`point-cloud-layer-adapter`}getField(e){return this.layer.fieldsIndex.get(e??``)}getFieldUsageInfo(e){let t=this.getField(e);if(!t)return null;let n=this._hasCachedStatistics(t.name);return{supportsLabelingInfo:n,supportsPopupTemplate:n,supportsRenderer:n,supportsLayerQuery:!1,supportsStatistics:n}}getFieldDomain(){return null}load(e){let t=this.layer.load(e).then(()=>{this.geometryType=`point`,this.objectIdField=null,this.supportsSQLExpression=!1,this.hasQueryEngine=!1});return this.addResolvingPromise(t),Promise.resolve(this)}};S([r({readOnly:!0})],$.prototype,`adapterName`,void 0),$=S([u(`esri.smartMapping.support.adapters.PointCloudLayerAdapter`)],$);var Xt=class extends X{constructor(){super(...arguments),this.adapterName=`stream-layer-adapter`}async _summaryStatsFromClientQuery(e,t){let{signal:n,view:r}=e,i=q(this,e,t);i.outStatistics=i.outStatistics?.filter(e=>e.outStatisticFieldName!==`totalcount_value`);let a=await this._fetchFeatureSetFromMemory(i,r,n),o=H(a,O(t)||g(t));return E(o,e.outStatisticTypes)}};S([r({readOnly:!0})],Xt.prototype,`adapterName`,void 0),Xt=S([u(`esri.smartMapping.support.adapters.StreamLayerAdapter`)],Xt);var Zt={0:{adapter:Z,type:`catalog`,label:`CatalogLayer`},1:{adapter:Z,type:`catalog-footprint`,label:`CatalogFootprintLayer`},2:{adapter:Kt,type:`csv`,label:`CSVLayer`},3:{adapter:Z,type:`feature`,label:`FeatureLayer`},5:{adapter:Z,type:`imagery`,label:`ImageryLayer`},4:{adapter:Z,type:`geojson`,label:`GeoJSONLayer`},6:{adapter:Z,type:`knowledge-graph-sublayer`,label:`KnowledgeGraphSublayer`},7:{adapter:X,type:`ogc-feature`,label:`OGCFeatureLayer`},8:{adapter:Z,type:`oriented-imagery`,label:`OrientedImageryLayer`},9:{adapter:Z,type:`parquet`,label:`ParquetLayer`},10:{adapter:$,type:`point-cloud`,label:`PointCloudLayer`},11:{adapter:Q,type:`scene`,label:`SceneLayer`},12:{adapter:Xt,type:`stream`,label:`StreamLayer`},13:{adapter:Z,type:`subtype-group`,label:`SubtypeGroupLayer`},14:{adapter:Z,type:`subtype-sublayer`,label:`SubtypeSublayer`},15:{adapter:Z,type:`wfs`,label:`WFSLayer`}},Qt=[0,1,2,3,4,6,7,8,9,10,11,12,13,14,15],$t=[2,3,4,7,6,8,9,12,15];function en(e){return e.map(e=>Zt[e].label)}function tn(e,t=Qt,n){if(e instanceof z)return e;let r=nn(e,t);return r?n?new Jt({layer:e}):new r({layer:e}):null}function nn(e,t=Qt){let n=null;return t.some(t=>{let r=e.type===Zt[t].type;return r&&(n=Zt[t].adapter),r}),n}async function rn(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new n(`unique-values:missing-parameters`,`'layer' and 'field' or 'valueExpression' parameters are required`);let t=e.valueExpression||e.sqlExpression,r=t&&!e.sqlExpression;if(t){if(r){if(!e.view)throw new n(`unique-values:missing-parameters`,`View is required when 'valueExpression' is specified`)}else if(!e.valueExpression)throw new n(`unique-values:missing-parameters`,`'valueExpression' parameters are required`)}e.forBinning&&We(e,`unique-values`);let{layer:i,...a}=e,o=[...Qt,5],s=e.forBinning?$t:o,c=tn(i,s,e.forBinning);if(!c)throw new n(`unique-values:invalid-parameters`,`'layer' must be one of these types: `+en(s).join(`, `));let l={layerAdapter:c,...a},u=l.signal==null?null:{signal:l.signal};await c.load(u);let d=await k({field:l.field,field2:l.field2,field3:l.field3,valueExpression:l.valueExpression}),f=je(c,d,`unique-values:invalid-parameters`);if(f)throw f;l.filter&&!l.filter.spatialRelationship&&(l.filter.spatialRelationship=`intersects`);let p=Ne(l.filter,`summary-statistics:invalid-parameters`);if(p)throw p;return l}async function an(e){let{layerAdapter:t,...n}=await rn(e);return t.uniqueValues(n)}export{an as default};