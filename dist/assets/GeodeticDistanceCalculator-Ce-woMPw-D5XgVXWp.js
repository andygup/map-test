import{_D as e,mD as t}from"./index-CzMixifc.js";import{Ut as n,cn as r,ht as i,in as a,kt as o,ln as s,pn as c,r as l,vn as u,xn as d,z as f}from"./Point2D-BslC4Gs9.js";import{t as p}from"./Envelope2D-n2TB2v9l.js";import{An as m,B as h,H as g,In as _,Mt as v,N as y,Nt as b,W as x,a as S,en as C,ft as w,k as T,kt as E,l as D,ln as O,n as k,q as A,r as j,ut as M,yn as N}from"./SpatialReference-BzfAMI5E.js";import{t as P}from"./Transformation2D-B6W9saMR.js";import{t as F}from"./SimpleGeometryCursor-BbFgAuic.js";import{i as I,r as L,t as R}from"./Distance2DCalculator-CXhBP-8I-DgwBxA-7.js";import{n as z}from"./OperatorGeodeticDensifyByLength-CRdE_CL1.js";var B=class{getOperatorType(){return 10317}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,n,r,i,a){return new z(e,t,4,n,r,i,a)}execute(e,t,n,r,i,a){let o=new F([e]),c=this.executeMany(o,t,n,r,i,a).next();return c||s(`null output`),c}};function V(){return new p}var H=class{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(e,t,n){this.m_peR1=new j,this.m_peR2=new j,this.m_peR3=new j,e===void 0?this.reset(1,0,1):this.reset(e,t,n)}reset(e,t,n){this.m_a=e,this.m_e2=t,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=n,this.m_unitToRad=.017453292519943295*n,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(e,t,n,r){let a=this.m_peR1,o=this.m_peR2,s=this.m_peR3;S.geodeticDistance(this.m_a,this.m_e2,e*this.m_unitToRad,t*this.m_unitToRad,n*this.m_unitToRad,r*this.m_unitToRad,s,a,o,0);let c=Math.cos(a.val),l=Math.cos(o.val+3.141592653589793),u=t*this.m_unitToRad,d=h.phiToEta(this.m_e2,u),f=Math.sin(a.val)*Math.cos(d),p=t;if(c*l<0){let e=c<0?-1:1,t=Math.acos(Math.abs(f))*e;p=h.etaToPhi(this.m_e2,t)/this.m_unitToRad}let m=i((n-e)*this.m_unitToRad,2*Math.PI);Math.abs(m)>Math.PI&&(m=m>0?m-2*Math.PI:m+2*Math.PI),m/=this.m_unitToRad,n=e+m;let g=V();return g.xmin=Math.min(e,n),g.xmax=Math.max(e,n),g.ymin=Math.min(t,r),g.ymin=Math.min(g.ymin,p),g.ymax=Math.max(t,r),g.ymax=Math.max(g.ymax,p),g}minDistanceGeodesic(e,t){let n=U(e),r=U(t);if(n&&r)return this.lowerDistanceGeodetic_(e.xmin,e.ymin,t.xmin,t.ymin);let i=this.normalizeGeodesic_(t,e);return W(e,i)?e.ymin>=i.ymax?this.minDistanceGeodesicUpDown_(e,i):i.ymin>=e.ymax?this.minDistanceGeodesicUpDown_(i,e):e.xmin>i.xmax?this.minDistanceGeodesicLeftRight_(i,e):this.minDistanceGeodesicLeftRight_(e,i):0}normalizeGeodesic_(e,t){let n=e.clone(),r=e.clone(),i=G(n,t);if(i===0)return n;for(;r.xmax>t.xmin;){r.xmin-=this.m_u360,r.xmax-=this.m_u360;let e=G(r,t);if(e<i&&(n.assign(r),i=e,i===0))return n}for(r.assign(e);r.xmin<t.xmax;){r.xmin+=this.m_u360,r.xmax+=this.m_u360;let e=G(r,t);if(e<i&&(n.assign(r),i=e,i===0))return n}return n}lowerDistanceGeodetic_(e,t,n,r){let i=this.m_peR1;{let a=this.m_b*this.m_b/this.m_a,o=h.phiToPhig(this.m_e2,this.m_unitToRad*t),s=h.phiToPhig(this.m_e2,this.m_unitToRad*r);S.geodeticDistance(a,0,this.m_unitToRad*e,o,this.m_unitToRad*n,s,i,null,null,0)}return i.val}minDistanceGeodesicUpDown_(e,t){if(t.xmin<=e.xmin?t.xmax>=e.xmin:e.xmax>=t.xmin)return this.lowerDistanceGeodetic_(0,e.ymin,0,t.ymax);if(t.xmin>e.xmax){let n=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);if(t.xmax-e.xmin<this.m_u180)return n;let r=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);return Math.min(n,r)}{let n=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);if(e.xmax-t.xmin<this.m_u180)return n;let r=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);return Math.min(n,r)}}minDistanceGeodesicLeftRight_(e,t){let n=Math.abs(e.xmax-t.xmin);for(;n>this.m_u180;)n-=this.m_u360;let r=Math.abs(e.xmin-t.xmax);for(;r>this.m_u180;)r-=this.m_u360;return Math.abs(n)<=Math.abs(r)?this.minDistanceGeodesicLeftRightNormalized_(e,t):this.minDistanceGeodesicLeftRightNormalized_(t,e)}minDistanceGeodesicLeftRightNormalized_(e,t){let n,r;return n=this.lowerDistanceGeodetic_(e.xmax,e.ymin,t.xmin,t.ymin),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymin,t.xmin,t.ymin,t.ymax),n=Math.min(n,r)),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymin,e.xmax,e.ymin,e.ymax),n=Math.min(n,r)),r=this.lowerDistanceGeodetic_(e.xmax,e.ymax,t.xmin,t.ymax),n=Math.min(n,r),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymax,t.xmin,t.ymin,t.ymax),n=Math.min(n,r)),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(r=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymax,e.xmax,e.ymin,e.ymax),n=Math.min(n,r)),n}lowerDistanceGeodeticSegMeridional_(e,t,n,r,i,a){let o=this.lowerDistanceGeodeticPtMeridional_(e,t,r,i,a),s=this.lowerDistanceGeodeticPtMeridional_(e,n,r,i,a),c=this.lowerDistanceGeodeticPtMeridional_(r,i,e,t,n),l=this.lowerDistanceGeodeticPtMeridional_(r,a,e,t,n);return o=Math.min(o,s),c=Math.min(c,l),Math.min(o,c)}lowerDistanceGeodeticPtMeridional_(e,t,n,r,i){let a=this.m_b*this.m_b/this.m_a,s=h.phiToPhig(this.m_e2,this.m_unitToRad*t),c=h.phiToPhig(this.m_e2,this.m_unitToRad*r),l=h.phiToPhig(this.m_e2,this.m_unitToRad*i),u=this.m_peR1,d=this.m_peR2;S.geodeticDistance(a,0,this.m_unitToRad*n,c,this.m_unitToRad*e,s,u,null,null,0),S.geodeticDistance(a,0,this.m_unitToRad*n,l,this.m_unitToRad*e,s,d,null,null,0);let f=w(1,0,new o(this.m_unitToRad*e,s)),p=w(1,0,new o(this.m_unitToRad*n,c)),m=w(1,0,new o(this.m_unitToRad*n,l)),g=new _;g.setCrossProductVector(p,m);let v=p.dotProduct(m);if(g.length()<1568e-13)return v>=0?Math.min(u.val,d.val):0;g=g.getUnitVector();let y=new _;if(y.setCrossProductVector(g,f),y.length()<1568e-13)return Math.min(u.val,d.val)-1e-5*a;y=y.getUnitVector();let b=f.sub(g.mul(f.dotProduct(g)));{let t=new _;t.setCrossProductVector(p,b);let n=new _;n.setCrossProductVector(b,m);let r=g.dotProduct(t)>0&&g.dotProduct(n)>0;if(r||=(b.negateThis(),t.setCrossProductVector(p,b),n.setCrossProductVector(b,m),g.dotProduct(t)>0&&g.dotProduct(n)>0),r){b=b.getUnitVector();let t=T(1,0,b),n=this.m_peR3;S.geodeticDistance(a,0,this.m_unitToRad*e,s,t.x,t.y,n,null,null,0);let r=Math.min(u.val,d.val);return Math.min(r,n.val)}}return Math.min(u.val,d.val)}};function U(e){return e.xmin===e.xmax&&e.ymin===e.ymax}function W(e,t){return t.xmax<e.xmin||t.xmin>e.xmax||t.ymax<e.ymin||t.ymin>e.ymax}function G(e,t){let n,r=0;return n=e.xmin-t.xmax,n>r&&(r=n),n=t.xmin-e.xmax,n>r&&(r=n),r}var K=class{};function q(e){return{outPoint:e===void 0?new o:e.clone()}}function J(e,t){e.outPoint.assign(t.outPoint)}function Y(){return new p}var X=class{constructor(e,t,n,r,i=0,a=4){this.m_ptDistFrom=new o,this.m_segStartPt=new o,this.m_segEndPt=new o,this.m_geodeticLength=new j,this.m_az12=new j,this.m_minGeodeticDist=new j,this.m_segStartPt3d=new _,this.m_segEndPt3d=new _,this.m_sr=r,this.m_distCurveType=i,this.m_segCurveType=a,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();let s=D();this.m_inputGCS.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_eSquared=s.e2,this.setPointDistFrom(e),this.setSegmentEndPoints(t,n)}setSegmentEndPoints(e,t){this.m_segStartPt.assign(e),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(w(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(w(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(e){this.m_ptDistFrom.assign(e),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(e){this.m_segCurveType=e}setDistanceCurveType(e){this.m_distCurveType=e}makeFunctor(){return n=>{let r;switch(this.m_segCurveType){case 0:case 1:case 3:{let i={stack:[],error:void 0,hasError:!1};try{let e=t(i,new j,!1),a=t(i,new j,!1);S.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*n,this.m_az12.val,e,a,this.m_segCurveType),r=new o(e.val,a.val);break}catch(e){i.error=e,i.hasError=!0}finally{e(i)}}case 2:{let e=_.lerp(this.m_segStartPt3d,this.m_segEndPt3d,n);r=T(this.m_a,this.m_eSquared,e);break}case 4:r=o.lerp(this.m_segStartPt,this.m_segEndPt,n),this.m_bIsPannablePcs&&(E(this.m_sr,0,[r],1),r.mulThis(this.m_rpu));break;default:s(`Invalid curve type`)}return S.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,r.x,r.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:S.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=o.distance(this.m_segStartPt,this.m_segEndPt);break;default:s(`Invalid curve type`)}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}};function Z(){return new K}var Q=class{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(e,t,n,r,i){this.m_boxGeomA=Y(),this.m_boxGeomB=Y(),this.m_envGeomA=new p,this.m_envGeomB=new p,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new P,this.m_scaleToDegrees=new P,this.m_inputSR=e,this.m_distCurveType=t,this.m_progressTracker=n,this.m_maxDistance=r,this.m_maxDeviation=i,this.m_inputGCS=e.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;let a=D();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new H(this.m_a,this.m_eSquared,1),this.m_distCurveType===4&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=this.m_inputSR.getCoordinateSystemType()===2&&this.m_inputSR.isPannable()}progress(e=!1){}calculate(e,t,n,r){let i=q(),a=q();if(e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(e,t,i,a))return n&&J(n,i),r&&J(r,a),0;let o=this.prepareGeometry(e);if(o.isEmpty())return NaN;let s=this.prepareGeometry(t);if(s.isEmpty())return NaN;this.m_tolerance=this.computeTolerance(o,s);let c=this._ExecuteBruteForce(o,s,i,a);return c>=this.m_maxDistance?NaN:(n&&(this.prepareOutput(i),J(n,i)),r&&(this.prepareOutput(a),J(r,a)),c)}createDistanceFunctor(e,t,n){let r=new X(e,t,n,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||this.m_inputSR.getCoordinateSystemType()===1||r.setSegmentCurveType(2),r}_NormalizeAndProject(e){if(this.m_inputSR.isPannable()&&(e=new v().foldInto360Range(e,this.m_inputSR)),this.m_inputSR.getCoordinateSystemType()===2){let t=y(this.m_inputSR,this.m_inputGCS,null);e=new v().execute(e,t,this.m_progressTracker)}return e}_ExecuteBruteForce(e,t,n,i){switch(e.getGeometryType()){case r.enumPoint:return this.calculateDistanceGeodeticPointGeometry(e,t,n,i);case r.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(e,t,n,i);case r.enumPolyline:case r.enumPolygon:case r.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(e,t,n,i);default:a(``)}}calculateDistanceGeodeticPointGeometry(e,t,n,i){switch(t.getGeometryType()){case r.enumPoint:return this.calculateDistanceGeodeticPointPoint(e,t,n,i);case r.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,n,i);case r.enumPolyline:case r.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(e,t,n,i);default:a(``)}}calculateDistanceGeodeticPointPoint(n,r,i,a){let o={stack:[],error:void 0,hasError:!1};try{let e=n.getXY();e.scale(this.m_rpu);let s=r.getXY();s.scale(this.m_rpu),i.outPoint.assign(e),a.outPoint.assign(s);let c=t(o,new j,!1);return S.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,s.x,s.y,c,null,null,this.m_distCurveType),c.val}catch(e){o.error=e,o.hasError=!0}finally{e(o)}}calculateDistanceGeodeticPointMultipoint(n,r,i,a){let s={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(n,r);let e=this.estimateMinimumDistance(i,a),c=e<this.m_maxDistance?e:this.m_maxDistance,l=n.getXY();l.scale(this.m_rpu),i.outPoint.assign(l);let u=w(this.m_a,this.m_eSquared,l),d=new o,f=r.getImpl(),p=t(s,new j,!1),m=f.getPointCount();for(let e=0;e<m;++e){f.queryXY(e,d),d.scale(this.m_rpu);let t=w(this.m_a,this.m_eSquared,d);if(!(_.distance(u,t)>c)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>c)&&(S.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,d.x,d.y,p,null,null,this.m_distCurveType),p.val<c&&(c=p.val,a.outPoint=d,c===0)))return c}return c===this.m_maxDistance?1/0:c}catch(e){s.error=e,s.hasError=!0}finally{e(s)}}calculateDistanceGeodeticPointMultipath(n,r,i,a){let s={stack:[],error:void 0,hasError:!1};try{let e=new o,c=new o;e.assign(n.getXY()),c.assign(n.getXY()),i.outPoint.assign(c.mul(this.m_rpu)),this.m_bIsPannablePcs&&g(this.m_inputSR,[e],1,!1),this.computeEnvelopesAndBoxes(n,r);let l=this.estimateMinimumDistance(i,a),d=l<this.m_maxDistance?l:this.m_maxDistance,f=r.getImpl(),p=new o(0,0),m=new o(0,0),h=[1],_=this.canUseSpatialTree(n,r),v=Z();_&&this.buildSpatialTree(v,r);let y=Y();y.setCoords({xmin:c.x,ymin:c.y,xmax:c.x,ymax:c.y});let b=t(s,this.createDistanceFunctor(c,p,m),!1),x=f.querySegmentIterator();if(x.stripAttributes(),_)u(0);else for(;x.nextPath();)for(;x.hasNextSegment();){let t=x.nextSegment(),n=this.findOrComputeBoxSegment(x.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(y,n)>d)continue;let r=this.calculateDistanceGeodeticPointSegment(e,c,t,h,b);if(r.second<d&&(this.updateOutputSegment(a,t,r.first),d=r.second,d===0))return 0}return d===this.m_maxDistance?1/0:d}catch(e){s.error=e,s.hasError=!0}finally{e(s)}}calculateDistanceGeodeticMultipointGeometry(e,t,n,i){switch(t.getGeometryType()){case r.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,i,n);case r.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(e,t,n,i);case r.enumPolyline:case r.enumPolygon:case r.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(e,t,n,i);default:a(``)}}calculateDistanceGeodeticMultipointMultipoint(n,r,i,a){let s={stack:[],error:void 0,hasError:!1};try{let e=t(s,new j,!1);this.computeEnvelopesAndBoxes(n,r);let c=this.estimateMinimumDistance(i,a),l=c<this.m_maxDistance?c:this.m_maxDistance,u=new o,d=new o,f=n.getImpl(),p=r.getImpl(),m=Y(),h=f.getPointCount(),g=p.getPointCount();for(let t=0;t<h;++t){if(u.assign(f.getXY(t)),m.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),this.m_envHelper.minDistanceGeodesic(m,this.m_boxGeomB)>l)continue;u.scale(this.m_rpu);let n=w(this.m_a,this.m_eSquared,u);for(let t=0;t<g;++t){d.assign(p.getXY(t)),d.scale(this.m_rpu);let r=w(this.m_a,this.m_eSquared,d);if(!(_.distance(n,r)>=l)&&(S.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,d.x,d.y,e,null,null,this.m_distCurveType),e.val<l&&(i.outPoint.assign(u),a.outPoint.assign(d),l=e.val,l===0)))return l}}return l===this.m_maxDistance?1/0:l}catch(e){s.error=e,s.hasError=!0}finally{e(s)}}calculateDistanceGeodeticMultipointMultipath(n,r,i,a){let s={stack:[],error:void 0,hasError:!1};try{let e=r.getImpl().querySegmentIterator();e.stripAttributes(),this.computeEnvelopesAndBoxes(n,r);let c=this.estimateMinimumDistance(i,a),l=c<this.m_maxDistance?c:this.m_maxDistance,d=new o,f=new o(0,0),p=new o(0,0),m=new o(0,0),h=[0],_=Y(),v=t(s,this.createDistanceFunctor(f,p,m),!1),y=Z(),b=this.canUseSpatialTree(n,r);b&&this.buildSpatialTree(y,r);let x=n.getPointCount();for(let t=0;t<x;++t)if(d.assign(n.getXY(t)),f.assign(n.getXY(t)),this.m_bIsPannablePcs&&g(this.m_inputSR,[d],1,!1),_.setCoords({xmin:f.x,ymin:f.y,xmax:f.x,ymax:f.y}),!(this.m_envHelper.minDistanceGeodesic(_,this.m_boxGeomB)>l))if(v.setPointDistFrom(f),b)u(0);else{for(;e.nextPath();)for(;e.hasNextSegment();){let t=e.nextSegment();if(this.m_envHelper.minDistanceGeodesic(_,this.findOrComputeBoxSegment(e.getStartPointIndex(),t,this.m_segmentBoxesB))>l)continue;let n=this.calculateDistanceGeodeticPointSegment(d,f,t,h,v);if(n.second<l&&(i.outPoint.assign(f.mul(this.m_rpu)),this.updateOutputSegment(a,t,n.first),l=n.second,l===0))return 0}e.resetToFirstPath()}return l===this.m_maxDistance?1/0:l}catch(e){s.error=e,s.hasError=!0}finally{e(s)}}calculateDistanceGeodeticMultipathGeometry(e,t,n,i){switch(t.getGeometryType()){case r.enumPoint:return this.calculateDistanceGeodeticPointMultipath(t,e,i,n);case r.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(t,e,i,n);case r.enumPolyline:case r.enumPolygon:case r.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(e,t,n,i);default:a(``)}}calculateDistanceGeodeticMultipathMultipath(e,t,n,r){let i=[e],a=[t],o=this.swapGeometries(i,a),s=i[0],c=a[0];this.computeEnvelopesAndBoxes(i[0],a[0]);let l=this.estimateMinimumDistance(n,r),u=this.calculateDistanceGeodeticMultipathMultipath_(s,c,n,r,l);return o&&(r.outPoint=f(n.outPoint,n.outPoint=r.outPoint)),u}calculateDistanceGeodeticMultipathMultipath_(n,r,i,a,s=Number.MAX_VALUE){let c={stack:[],error:void 0,hasError:!1};try{let e=s,l=new o(0,0),d=new o,f=new o(0,0),p=new o,m=new o(0,0),h=new o,g=new o,_=new o,v=[new o],y=[0],b=[0],x=Y(),S=Y(),C=t(c,this.createDistanceFunctor(m,l,f),!1),w=Z(),T=this.canUseSpatialTree(n,r);T&&this.buildSpatialTree(w,r);let D=r.querySegmentIterator();D.stripAttributes();let k=new O,A=R(n);for(let t=0;t<A.length;++t){let r=A[t];n.getSegmentBuffer(r,k,!0);let o=k.get();if(x.assign(this.findOrComputeBoxSegment(r,o,this.m_segmentBoxesA)),T)u(0);else{if(m.assign(o.getStartXY()),h.assign(o.getStartXY()),g.assign(o.getEndXY()),_.assign(o.getEndXY()),this.m_bIsPannablePcs&&(E(this.m_inputSR,0,[h],1),E(this.m_inputSR,0,[_],1)),this.m_envHelper.minDistanceGeodesic(x,this.m_boxGeomB)>e)continue;for(;D.nextPath();){for(;D.hasNextSegment();){let t=D.nextSegment();if(l.assign(t.getStartXY()),d.assign(t.getStartXY()),f.assign(t.getEndXY()),p.assign(t.getEndXY()),o.intersect(t,v,y,b,this.m_tolerance))return this.updateOutputSegment(i,o,y[0]),this.updateOutputSegment(a,t,b[0]),0;if(this.m_bIsPannablePcs&&(E(this.m_inputSR,0,[d],1),E(this.m_inputSR,0,[p],1)),S.assign(this.findOrComputeBoxPoint(D.getStartPointIndex(),d,p,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(x,S)>e)continue;C.setSegmentEndPoints(l,f),C.setPointDistFrom(h);let n=M(C.makeFunctor(),0,1,1e-10);if(n.second<e&&(i.outPoint.assign(h.mul(this.m_rpu)),this.updateOutputSegment(a,t,n.first),e=n.second,e===0)||(C.setPointDistFrom(_),n=M(C.makeFunctor(),0,1,1e-10),n.second<e&&(i.outPoint.assign(_.mul(this.m_rpu)),this.updateOutputSegment(a,t,n.first),e=n.second,e===0))||(C.setSegmentEndPoints(m,g),C.setPointDistFrom(d),n=M(C.makeFunctor(),0,1,1e-10),n.second<e&&(this.updateOutputSegment(i,o,n.first),a.outPoint.assign(d.mul(this.m_rpu)),e=n.second,e===0))||(C.setPointDistFrom(p),n=M(C.makeFunctor(),0,1,1e-10),n.second<e&&(this.updateOutputSegment(i,o,n.first),a.outPoint.assign(p.mul(this.m_rpu)),e=n.second,e===0)))break}if(e===0)return 0}D.resetToFirstPath()}}return e===this.m_maxDistance?1/0:e}catch(e){c.error=e,c.hasError=!0}finally{e(c)}}calculateDistanceGeodeticPointSegment(e,t,n,r,i){let a=n.getStartXY(),o=n.getEndXY();return n.intersectPoint(e,r,this.m_tolerance)?l(r[0],0):(i.setPointDistFrom(t),i.setSegmentEndPoints(a,o),M(i.makeFunctor(),0,1,1e-10))}prepareGeometry(e){let t=e.clone(),n=e.getGeometryType();if(n===r.enumPoint||n===r.enumMultiPoint)return this._NormalizeAndProject(t);if(n===r.enumEnvelope&&(t=this.envelopeToPolygon(t)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(t,4);if(this.m_inputSR.getCoordinateSystemType()===2){if(t=A(t,this.m_inputSR,0,null),t.isEmpty())return t;t=new B().execute(t,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);let e=this.m_inputSR.getSRToGCSTransform();return new v().execute(t,e,this.m_progressTracker)}let i=new p;t.queryLooseEnvelope(i);let a=this.m_inputSR.getPannableExtent();if(i.ymin<a.ymin||i.ymax>a.ymax){let e=new p(i.xmin-1,a.ymin,i.xmax+1,a.ymax);if(t=new C().execute(t,e,this.m_inputSR,this.m_progressTracker),t.isEmpty())return t}return i.width()>2*a.width()&&(t=b(t,-2*a.width(),2*a.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker)),t}prepareGeometryPannable(e,t){let r=new p;e.queryEnvelope(r);let i=this.m_inputSR.getPannableExtent();if(i.containsEnvelope(r))return e;let a=new n;i.queryIntervalX(a);let o=new n;return r.queryIntervalX(o),e=a.contains(o)?k(e,this.m_inputSR):new v().foldInto360RangeGeodetic(e,this.m_inputSR,t)}prepareOutput(e){e.outPoint.scale(1/this.m_rpu),this.m_inputSR.getCoordinateSystemType()===2&&g(this.m_inputSR,[e.outPoint],1,!1)}updateOutputSegment(e,t,n){t.queryCoord2D(n,e.outPoint),this.m_bIsPannablePcs&&E(this.m_inputSR,0,[e.outPoint],1),e.outPoint.mulThis(this.m_rpu)}computeTolerance(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB);let n=new p(this.m_envGeomA);return n.mergeEnvelope2D(this.m_envGeomB),m(null,n)}envelopeToPolygon(e){let t=new N;return t.addEnvelope(e,!1),t}computeEnvelopesAndBoxes(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(e,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(t,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(e,t,n){switch(e.getGeometryType()){case r.enumPoint:return this.computeBoxPoint(e,t);case r.enumMultiPoint:return this.computeBoxMultiPoint(e,t);case r.enumPolyline:case r.enumPolygon:return this.computeBoxMultiPath(e,t,n);default:s(`Invalid geometry type`)}}computeBoxPoint(e,t){let n=e.getXY();t.length=0,t.push(n.mul(this.m_rpu));let r=Y();return r.setCoords({xmin:n.x,ymin:n.y,xmax:n.x,ymax:n.y}),r}computeBoxMultiPoint(e,t){let n=!0;for(let r=0;r<e.getPointCount();++r){let i=e.getXY(r);if(n){t.length=0;for(let e=0;e<4;++e)t.push(i.clone());n=!1}i.x<t[0].x&&t[0].assign(i),i.y>t[1].y&&t[1].assign(i),i.x>t[2].x&&t[2].assign(i),i.y<t[3].y&&t[3].assign(i)}for(let e=0;e<t.length;++e)t[e].mulThis(this.m_rpu);let r=Y();return e.queryEnvelope(r),r}computeBoxMultiPath(e,t,n){let r=!0,i=Y();i.setEmpty();let a=e.querySegmentIterator();for(a.stripAttributes();a.nextPath();)for(;a.hasNextSegment();){let e=a.nextSegment(),o=e.getStartXY(),s=e.getEndXY();if(this.m_bIsPannablePcs&&(E(this.m_inputSR,0,[o],1),E(this.m_inputSR,0,[s],1)),r){for(let e=0;e<4;++e)t.push(o.clone());r=!1}o.x<t[0].x&&t[0].assign(o),o.y>t[1].y&&t[1].assign(o),o.x>t[2].x&&t[2].assign(o),o.y<t[3].y&&t[3].assign(o),s.x<t[0].x&&t[0].assign(s),s.y>t[1].y&&t[1].assign(s),s.x>t[2].x&&t[2].assign(s),s.y<t[3].y&&t[3].assign(s);let c=this.findOrComputeBoxPoint(a.getStartPointIndex(),o,s,n);i.mergeEnvelope2D(c)}for(let e=0;e<t.length;++e)t[e].mulThis(this.m_rpu);return i}findOrComputeBoxSegment(e,t,n){if(!n.has(e)){let r=Y();if(t.queryEnvelope(r),this.m_bIsPannablePcs){let e=o.construct(r.xmin,r.ymin),t=o.construct(r.xmax,r.ymax);E(this.m_inputSR,0,[e],1),E(this.m_inputSR,0,[t],1),r=this.m_envHelper.calculateBbox(e.x,e.y,t.x,t.y)}return n.set(e,r),r}return n.get(e)}findOrComputeBoxPoint(e,t,n,r){if(!r.has(e)){let i=Y();return i.setCoords({xmin:t.x,ymin:t.y,xmax:n.x,ymax:n.y}),this.m_bIsPannablePcs&&(i=this.m_envHelper.calculateBbox(i.xmin,i.ymin,i.xmax,i.ymax)),r.set(e,i),i}return r.get(e)}estimateMinimumDistance(n,r){let i={stack:[],error:void 0,hasError:!1};try{let e=e=>w(this.m_a,this.m_eSquared,e),a=this.m_boundaryPtsA.map(e),o=this.m_boundaryPtsB.map(e),s=Number.MAX_VALUE,c=0,l=0;for(let e=0;e<a.length;++e)for(let t=0;t<o.length;++t){let n=_.distance(a[e],o[t]);n<s&&(s=n,c=e,l=t)}n.outPoint.assign(this.m_boundaryPtsA[c]),r.outPoint.assign(this.m_boundaryPtsB[l]);let u=t(i,new j,!1);return S.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[c].x,this.m_boundaryPtsA[c].y,this.m_boundaryPtsB[l].x,this.m_boundaryPtsB[l].y,u,null,null,this.m_distCurveType),u.val}catch(e){i.error=e,i.hasError=!0}finally{e(i)}}swapGeometries(e,t){return d(e[0])>d(t[0])&&(t[0]=f(e[0],e[0]=t[0]),this.m_envGeomB=f(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(e,t){return!1}checkGeometriesIntersect(e,t,n,i){let a=e.getGeometryType(),o=t.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(a===r.enumPoint&&t.getDimension()===2){let r=[0],a=[e.getXY()];if(x(t,a,1,this.m_tolerance,r),r[0]!==0)return n.outPoint.assign(a[0]),i.outPoint.assign(a[0]),!0}else if(o===r.enumPoint&&e.getDimension()===2){let r=[2],a=[t.getXY()];if(x(e,a,1,this.m_tolerance,r),r[0]!==0)return n.outPoint.assign(a[0]),i.outPoint.assign(a[0]),!0}if(a===r.enumMultiPoint&&t.getDimension()===2)return this.multipointIntersectsArea(e,t,n,i);if(o===r.enumMultiPoint&&e.getDimension()===2)return this.multipointIntersectsArea(t,e,i,n);let s,l,u=e,d=t;if(a===r.enumEnvelope&&(s=this.envelopeToPolygon(e),u=s,a=r.enumPolygon),o===r.enumEnvelope&&(l=this.envelopeToPolygon(t),d=l,o=r.enumPolygon),c(a)&&c(o)){let e=u.querySegmentIterator(),t=d.querySegmentIterator(),r=I(),a=I();if(L(u,d,e,t,r,a))return n.outPoint.assign(r.outPoint),i.outPoint.assign(r.outPoint),!0}}return!1}multipointIntersectsArea(e,t,n,r){let i=e.getPointCount();for(let a=0;a<i;++a){let i=[2],o=e.getXY(a);if(x(t,[o],1,this.m_tolerance,i),i[0]!==0)return n.outPoint.assign(o),r.outPoint.assign(o),!0}return!1}getNearestNeighbourVisitor(e,t,n,r,i,a,o){return u(0),{}}buildSpatialTree(e,t){u(0)}};export{Q as n,q as r,X as t};