import{Al as e,Bx as t,DT as n,Nu as r,OT as i,Ol as a,Sb as o,XC as s,YC as c,_b as l,_w as u,c_ as d,gD as f,gb as p,hb as m,iv as h,mb as g,wb as ee,yb as _,yl as v}from"./index-ByaFsVj4.js";import"./quatf64-eO7UAs9K.js";import"./plane-Dmhe_zL4.js";import"./vectorStacks-DhZu7qGn.js";import"./projectPointToVector-DjmX75N6.js";import"./dehydratedPoint-CVzHYxaL.js";import"./projectVectorToVector-BnpPb96u.js";import{m as y}from"./elevationInfoUtils-CyQsBf6_.js";import"./ObjectStack-C2IlraSC.js";import"./ray-CUcS4KDu.js";import{d as b,r as x}from"./quantity-b_p_m453.js";import"./geodesicUtils-Dvm-3luO.js";import{_ as S,c as C,g as w,h as T,i as E,l as D,o as O}from"./LineSnappingHint-3ZzJwo5I.js";import{n as k}from"./ParallelSnappingHint-68YI0lzr.js";import{a as A,l as j,o as M,r as N}from"./snappingUtils-C_5v3bem.js";import"./vec3-DP8KhY5h.js";import"./sphere-BCy4W-Wa.js";import{f as te,u as P}from"./constraints-CFQ1UrIW.js";import"./SnappingCandidate-CgOYxD9J.js";import{t as F}from"./LineSnappingCandidate-COvu3vdD.js";import{n as I,t as L}from"./RightAngleTriangleSnappingCandidate-CghH-bTz.js";import"./RightAngleSnappingHint-CU6G_WVm.js";import{n as R,t as z}from"./viewUtils-2ptPti_Q.js";import"./viewUtils-DLrdDgo8.js";import{c as B,n as V}from"./angularMeasurementUtils-g0-pmZ8Q.js";var H=class{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=k.shortLineThreshold*k.shortLineThreshold}snap(e,t){return t.vertexHandle==null?this.snapNewVertex(e,t):t.vertexHandle.type===`vertex`?this.snapExistingVertex(e,t):[]}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(T(e.leftVertex.pos,this.view,t),T(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:n}){return this.squaredShortLineThreshold===0||N(z(t,n,y,this.view),z(e,n,y,this.view))>this.squaredShortLineThreshold}isVertical(e,n,{spatialReference:r}){let i=t(r);return o(S(e),S(n))*i<k.verticalLineThresholdMeters}squaredProximityThreshold(e){return e===`touch`?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){let{distance:e,touchSensitivityMultiplier:t}=this.options,n=e*t;return n*n}},U=class extends H{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=n.segments.length,i=[];if(r<1)return i;let{spatialReference:a}=t,o=z(e,a,y,this.view),{view:s}=this,c=n.segments[r-1],l=c;do{if(M(l)&&this.edgeExceedsShortLineThreshold(l,t)){let n=A(l,s,t);this._processCandidateProposal(n.left,n.right,e,o,t,i)}l=l.leftVertex.leftSegment}while(l&&l!==c);return i}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2)return n;let{view:a}=this,{spatialReference:o}=t,s=z(e,o,y,a),c=r.leftSegment,l=r.rightSegment;M(c)&&M(l)&&this.edgeExceedsShortLineThreshold(c,t)&&this.edgeExceedsShortLineThreshold(l,t)&&this._processCandidateProposal(T(c.leftVertex.pos,a,t),T(l.rightVertex.pos,a,t),e,s,t,n);let u=i.segments[0],d=u;do{if(M(d)&&d!==r.leftSegment&&d!==r.rightSegment&&this.edgeExceedsShortLineThreshold(d,t)){let r=A(d,a,t);this._processCandidateProposal(r.left,r.right,e,s,t,n)}d=d.rightVertex.rightSegment}while(d&&d!==u);return n}_processCandidateProposal(e,t,n,r,i,a){let{spatialReference:o,pointer:s}=i,c=d();W(c,e,t,n,i,this._geodesicLengthMeasurementUtils);let l=w(D(c));N(r,z(l,o,y,this.view))<this.squaredProximityThreshold(s)&&a.push(new F({lineStart:e,lineEnd:t,targetPoint:l,isDraped:i.elevationInfo?.mode===`on-the-ground`}))}};function W(e,t,n,r,i,a){G(e,t,n,r,i,a)||K(e,r,t,n)}function G(e,t,n,r,{spatialReference:i},a){let o=B(t,n,i,i);if(o==null)return!1;let l=B(n,r,i,i);if(l==null)return!1;let u=a.geodesicDistance(n,r,i);if(u==null)return!1;let d=Math.abs(s.shortestSignedDiff(o,l))>Math.PI/2?c.normalize(o+Math.PI):o;return V(e,n,i,b(u,`meters`),x(d,`radians`,`geographic`),`geodesic`),e[2]=r[2],!0}function K(e,t,n,r){te(t,{start:n,end:r,type:1},e),e[2]=t[2]}var q=class extends H{snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=n.segments.length,i=n.vertices.length,a=[];if(r<2)return a;let{view:o}=this,s=z(e,t.spatialReference,y,o),c=n.vertices[0],l=n.vertices[i-1],u=M(l.leftSegment)?T(l.pos,o,t):null,d=M(c.rightSegment)?T(c.pos,o,t):null,f=n.segments[r-1],p=f;do{if(M(p)&&this.edgeExceedsShortLineThreshold(p,t)){let n=A(p,o,t);u&&this._checkEdgeForParallelLines(n,u,e,s,t,a),d&&this._checkEdgeForParallelLines(n,d,e,s,t,a)}p=p.leftVertex.leftSegment}while(p&&p!==f);return a}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<3)return n;let{view:a}=this,o=z(e,t.spatialReference,y,a),s=r.leftSegment,c=r.rightSegment,l=i.vertices[0],u=T(l.pos,a,t),d=i.vertices.length,f=i.vertices[d-1],p=T(f.pos,a,t),m=i.segments[0],h=m;do{if(M(h)&&h!==s&&h!==c&&this.edgeExceedsShortLineThreshold(h,t)){let i=A(h,a,t);M(s)&&this._checkEdgeForParallelLines(i,T(s.leftVertex.pos,a,t),e,o,t,n),M(c)&&this._checkEdgeForParallelLines(i,T(c.rightVertex.pos,a,t),e,o,t,n),r===l?this._checkEdgeForParallelLines(i,p,e,o,t,n):r===f&&this._checkEdgeForParallelLines(i,u,e,o,t,n)}h=h.rightVertex.rightSegment}while(h&&h!==m);return n}_checkEdgeForParallelLines(e,t,n,r,i,a){let o=e.left,s=e.right;if(O(Y,S(t),S(o),S(s)),m(Y,S(t))<k.parallelLineThreshold)return;O(Y,S(n),S(o),S(s),S(t));let{spatialReference:c,pointer:l}=i,u=w(C(Y[0],Y[1],n[2]));if(N(r,z(u,c,y,this.view))<this.squaredProximityThreshold(l)){if(this.isVertical(u,t,i)||this.isVertical(o,s,i)||J(e,a))return;a.push(new I({referenceLine:e,lineStart:t,targetPoint:u,isDraped:i.elevationInfo?.mode===`on-the-ground`}))}}};function J(e,t){let n=e.left,r=e.right;for(let i of t)if(O(Y,S(r),S(i.constraint.start),S(i.constraint.end),S(n)),m(Y,S(r))<k.parallelLineThreshold)return i.addReferenceLine(e),!0;return!1}var Y=r(),ne=class extends H{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=[];if(n.vertices.length<2)return r;let{view:i}=this,a=z(e,t.spatialReference,y,i),o=n.vertices.at(-1);M(o.leftSegment)&&this._checkForSnappingCandidate(1,r,o.leftSegment,o,o.leftSegment.leftVertex,e,a,t);let s=n.vertices[0];return M(s.rightSegment)&&this._checkForSnappingCandidate(2,r,s.rightSegment,s,s.rightSegment.rightVertex,e,a,t),r}snapExistingVertex(e,t){let n=[],r=t.vertexHandle;if(r.part.vertices.length<3)return n;let{view:i}=this,a=z(e,t.spatialReference,y,i),o=r.leftSegment,s=r.rightSegment;if(M(o?.leftVertex.leftSegment)){let r=o.leftVertex.leftSegment;this._checkForSnappingCandidate(3,n,r,r.rightVertex,r.leftVertex,e,a,t)}if(M(s)&&M(s.rightVertex.rightSegment)){let r=s.rightVertex.rightSegment;this._checkForSnappingCandidate(3,n,r,r.leftVertex,r.rightVertex,e,a,t)}return n}_checkForSnappingCandidate(e,t,n,r,i,a,o,s){if(!M(n)||!this.edgeExceedsShortLineThreshold(n,s))return;let c=this.view,l=T(r.pos,c,s),u=T(i.pos,c,s);re(Z,u,l,a,s,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,u,l,Z,a,o,s)}_checkForSnappingCandidateAlongProjectedRay(t,n,r,i,a,o,s,c){let{spatialReference:u,pointer:f}=c,m=l(X,S(o),S(i)),h=_(a,m)/ee(a),g=p(X,S(i),a,h),v=w(C(g[0],g[1],o[2]));if(N(s,z(v,u,y,this.view))>this.squaredProximityThreshold(f)||this.isVertical(v,i,c)||this.isVertical(i,r,c))return;let b=e(d(),i,a,Math.sign(h));n.push(new R({targetPoint:v,constraint:new P(i,D(b)),previousVertex:r,otherVertex:i,otherVertexType:1,selfSnappingType:t,isDraped:c.elevationInfo?.mode===`on-the-ground`}))}};function re(e,t,n,r,i,a){ie(e,t,n,r,i,a)||ae(e,t,n)}function ie(e,t,n,r,{spatialReference:i},a){let o=B(t,n,i,i);if(o==null)return!1;let s=B(n,r,i,i);if(s==null)return!1;let l=Math.sign(c.shortestSignedDiff(o,s))*Math.PI*.5,u=x(o+l,`radians`,`geographic`),f=d(),p=a.geodesicDistance(n,r,i);return p!=null&&(V(f,n,i,b(p,`meters`),u,`geodesic`),v(e,f,n),!0)}function ae(e,t,n){let r=l(X,S(n),S(t));a(e,r[1],-r[0],0)}var X=r(),Z=d(),oe=class extends H{snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=[],i=n.vertices.length;if(t.editGeometryOperations.data.type!==`polygon`||i<2)return r;let{view:a}=this,o=n.vertices[0],s=n.vertices[i-1];if(s.leftSegment&&s.leftSegment.type!==`line`||s.rightSegment&&s.rightSegment.type!==`line`)return r;let c=T(o.pos,a,t),l=T(s.pos,a,t);return this._processCandidateProposal(c,l,e,t,r),r}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2||t.editGeometryOperations.data.type===`polyline`&&(r.index===0||r.index===i.vertices.length-1)||r.leftSegment?.type!==`line`||r.rightSegment?.type!==`line`)return n;let{view:a}=this,o=T(r.leftSegment.leftVertex.pos,a,t),s=T(r.rightSegment.rightVertex.pos,a,t);return this._processCandidateProposal(o,s,e,t,n),n}_processCandidateProposal(e,t,n,r,i){if(!this.exceedsShortLineThreshold(e,t,r))return;let a=g(Q,S(e),S(t),.5),s=.5*o(S(e),S(t)),c=E(Q,S(n),a,s),l=w(C(c[0],c[1],n[2])),{spatialReference:u,pointer:d}=r,f=z(n,u,y,this.view);if(N(f,z(l,u,y,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(e,l,r)||this.isVertical(l,t,r))return;i.push(new L({targetPoint:l,point1:e,point2:t,isDraped:r.elevationInfo?.mode===`on-the-ground`}))}}},Q=r(),$=class extends u{constructor(e){super(e),this.updating=!1,this._snappers=new h,this._domain=2}initialize(){this._snappers.push(new q(this.view,this.options),new U(this.view,this.options,this.geodesicLengthMeasurementUtils),new ne(this.view,this.options,this.geodesicLengthMeasurementUtils),new oe(this.view,this.options))}set options(e){this._set(`options`,e);for(let t of this._snappers)t.options=e}async fetchCandidates(e,t,n){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];let r=[];for(let t of this._snappers.items)for(let i of t.snap(e,n))r.push(i);return j(e,r),r}};f([n({readOnly:!0})],$.prototype,`updating`,void 0),f([n({constructOnly:!0})],$.prototype,`view`,void 0),f([n({constructOnly:!0})],$.prototype,`geodesicLengthMeasurementUtils`,void 0),f([n()],$.prototype,`options`,null),$=f([i(`esri.views.interactive.snapping.SelfSnappingEngine`)],$);export{$ as SelfSnappingEngine};