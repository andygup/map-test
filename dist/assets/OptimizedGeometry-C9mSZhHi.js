class o{constructor(t=[],e=[]){this.lengths=t??[],this.coords=e??[]}static fromJSON(t){return new o(t.lengths,t.coords)}static fromRect(t){const[e,r,s,h]=t,n=s-e,l=h-r;return new o([5],[e,r,n,0,0,l,-n,0,0,-l])}get isPoint(){return this.lengths.length===0}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((t,e)=>t+e)}forEachVertex(t){let e=0;this.lengths.length||t(this.coords[0],this.coords[1]);for(let r=0;r<this.lengths.length;r++){const s=this.lengths[r];for(let h=0;h<s;h++)t(this.coords[2*(h+e)],this.coords[2*(h+e)+1]);e+=s}}deltaDecode(){const t=this.clone(),{coords:e,lengths:r}=t;let s=0;for(const h of r){for(let n=1;n<h;n++)e[2*(s+n)]+=e[2*(s+n)-2],e[2*(s+n)+1]+=e[2*(s+n)-1];s+=h}return t}clone(t){if(this.lengths.length===0)return new o([],[this.coords[0],this.coords[1]]);const e=(this.lengths.length===0?1:this.lengths.reduce((s,h)=>s+h))*2,r=this.coords.slice(0,e);return t?(t.set(r),new o(this.lengths,t)):new o(Array.from(this.lengths),Array.from(r))}}export{o as s};
