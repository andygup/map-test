import{MT as e,OT as t,ax as n,e_ as r,gD as i,px as a}from"./index-CzMixifc.js";import"./_commonjsHelpers-4rFoZa9I.js";import{U as o,d as s,g as c,t as l}from"./RasterSymbolizer-CSgBrmNy.js";import{l as u,t as d}from"./PixelBlock-Cu1E_t0b.js";import{C as f,D as p,M as m,O as h,P as g,_,a as v,m as y,p as b,u as x,v as S}from"./vectorFieldUtils-BZ6-deEm.js";import"./colorUtils-Btp0B-0Y.js";import{t as C}from"./dataUtils-CAfnFU_x.js";import{p as w,u as T}from"./rasterProjectionHelper-cBqbWx2d.js";import"./clipUtils-0cgYPFvv.js";import{t as E}from"./rasterFunctionHelper-Cr6dPgkx.js";import{n as D,r as O,t as k}from"./GCSShiftTransform-_7OG_4yt.js";function A(e,t,n){let r=e.length,i=d.createEmptyBand(n,r);for(let n=0;n<r;n++)if(t[n]){let r=e[n];r<=0?t[n]=0:i[n]=Math.log(r)}return i}function j(e,t,n,r){let i=e.length,a=d.createEmptyBand(n,i),[o,s]=u(n),c=r?.lambda??0,l=r?.shift??0,f=c===0;for(let n=0;n<i;n++)if(t[n]){let r=e[n];if(r<=0)t[n]=0;else if(f)a[n]=Math.log(r+l);else{let e=((r+l)**c-1)/c;a[n]=Math.max(o,Math.min(e,s))}}return a}function M(e,t,n){let r=e.length,i=d.createEmptyBand(n,r);for(let n=0;n<r;n++)if(t[n]){let r=e[n];r<0?t[n]=0:i[n]=Math.sqrt(r)}return i}function N(e,t,n){let r=e.length,i=d.createEmptyBand(n,r),[a,o]=u(n);for(let n=0;n<r;n++)if(!t||t[n]){let t=1/e[n];i[n]=i[n]=Math.max(a,Math.min(t,o))}return i}function P(e,t,n){let{width:r,height:i,pixels:a}=e,o=[];o=e.bandMasks?e.bandMasks.map(e=>new Uint8Array(e)):a.map(()=>e.mask?new Uint8Array(e.mask):new Uint8Array(r*i).fill(255));let s=a.map((e,r)=>{switch(t){case`log`:return A(e,o[r],`f32`);case`sqrt`:return M(e,o[r],`f32`);case`inverse`:return N(e,o[r],`f32`);case`box-cox`:return j(e,o[r],`f32`,n);default:return e}}),c=t===`inverse`,l=c?e.mask:o.length===1?o[0]:h(o),u=c?e.bandMasks:o.length===1?void 0:o;return new d({width:r,height:i,pixelType:`f32`,bandMasks:u,mask:l,pixels:s})}var F,I=F=class extends O{constructor(){super(...arguments),this.type=`identity`}clone(){return new F}};i([e({IdentityXform:`identity`})],I.prototype,`type`,void 0),I=F=i([t(`esri.layers.raster.transforms.IdentityTransform`)],I);var L={GCSShiftXform:k,IdentityXform:I,PolynomialXform:D};function R(e){if(!e?.type)return null;let t=L[e?.type];if(t){let n=new t;return n.read(e),n}return null}function z(e){if(!e)return{result:null,transferList:[]};let{pixelBlock:t,transferList:n}=e.getTransferableObject();return{result:t,transferList:n}}var B=class{convertVectorFieldData(e){let t=d.fromJSON(e.pixelBlock),n=z(v(t,e.type));return Promise.resolve(n)}convertPixelBlockToFeatures(e){let t=g({pixelBlock:d.fromJSON(e.pixelBlock),extent:n.fromJSON(e.extent),fieldNames:e.fieldNames,skipFactor:e.skipFactor,skipSpatialReference:!0,pixelIdOffset:e.pixelIdOffset,imageRowSize:e.imageRowSize});return Promise.resolve(t)}transformPixels(e){let t=d.fromJSON(e.pixelBlock),n=P(t,e.transformType,e.transformParameters);return Promise.resolve(z(n))}computeStatisticsHistograms(e){let t=d.fromJSON(e.pixelBlock),n=s(t,{histogramSize:e.histogramSize,includeSkewnessKurtosis:e.includeSkewnessKurtosis});return Promise.resolve(n)}compositeBands(e){let t=e.pixelBlocks.map(e=>e&&d.fromJSON(e)),n=z(m(t));return Promise.resolve(n)}async decode(e){return z(await o(e.data,e.options))}symbolize(e){let t=e.pixelBlock?d.fromJSON(e.pixelBlock):null,r=e.extent?n.fromJSON(e.extent):null,i=z(this.symbolizer.symbolize({...e,pixelBlock:t,extent:r}));return Promise.resolve(i)}highlightPixels(e){let t=d.fromJSON(e.pixelBlock),n=d.fromJSON(e.renderedPixelBlock);return f({pixelBlock:t,renderedPixelBlock:n,highlightOptions:e.highlightOptions}),Promise.resolve(n.toJSON())}async updateSymbolizer(e){this.symbolizer=l.fromJSON(e.symbolizerJSON),e.histograms&&this.symbolizer?.rendererJSON.type===`rasterStretch`&&(this.symbolizer.rendererJSON.histograms=e.histograms)}async updateRasterFunction(e){this.rasterFunction=E(e.rasterFunctionJSON)}async process(e){return z(this.rasterFunction.process({extent:n.fromJSON(e.extent),primaryPixelBlocks:e.primaryPixelBlocks.map(e=>e==null?null:d.fromJSON(e)),primaryPixelSizes:e.primaryPixelSizes?.map(e=>e==null?null:a.fromJSON(e)),primaryRasterIds:e.primaryRasterIds}))}stretch(e){let t=z(this.symbolizer.simpleStretch(d.fromJSON(e.srcPixelBlock),e.stretchParams));return Promise.resolve(t)}estimateStatisticsHistograms(e){let t=c(d.fromJSON(e.srcPixelBlock));return Promise.resolve(t)}split(e){let t=y(d.fromJSON(e.srcPixelBlock),e.tileSize,e.maximumPyramidLevel??0,!1===e.useBilinear),n=[],r;return t&&(r=new Map,t.forEach((e,t)=>{if(e){let{pixelBlock:i,transferList:a}=e.getTransferableObject();r.set(t,i),a.forEach(e=>{n.includes(e)||n.push(e)})}})),Promise.resolve({result:r,transferList:n})}clipTile(e){let t=d.fromJSON(e.pixelBlock),n=z(b({...e,pixelBlock:t}));return Promise.resolve(n)}async mosaicAndTransform(e){let t=e.srcPixelBlocks.map(e=>e?new d(e):null),n=S(t,e.srcMosaicSize,{blockWidths:e.blockWidths,alignmentInfo:e.alignmentInfo,clipOffset:e.clipOffset,clipSize:e.clipSize}),r,i=n;e.coefs&&(i=_(n,e.destDimension,e.coefs,e.sampleSpacing,e.interpolation)),e.projectDirections&&e.gcsGrid&&(r=p(e.destDimension,e.gcsGrid),i=x(i,e.isUV?`vector-uv`:`vector-magdir`,r));let{result:a,transferList:o}=z(i);return{result:{pixelBlock:a,localNorthDirections:r},transferList:o}}async createFlowMesh(e,t){let n={data:new Float32Array(e.flowData.buffer),mask:new Uint8Array(e.flowData.maskBuffer),width:e.flowData.width,height:e.flowData.height},{vertexData:r,indexData:i}=await C(e.meshType,e.simulationSettings,n,t.signal);return{result:{vertexBuffer:r.buffer,indexBuffer:i.buffer},transferList:[r.buffer,i.buffer]}}async getProjectionOffsetGrid(e){let t=n.fromJSON(e.projectedExtent),i=n.fromJSON(e.srcBufferExtent),a=null;e.datumTransformationSteps?.length&&(a=new r({steps:e.datumTransformationSteps})),await T();let o=e.rasterTransform?R(e.rasterTransform):null;return w({...e,projectedExtent:t,srcBufferExtent:i,datumTransformation:a,rasterTransform:o})}};export{B as default};