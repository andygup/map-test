const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-WG5sF5gR.js","assets/SpatialReference-BzfAMI5E.js","assets/index-CzMixifc.js","assets/index-CDgdHpAj.css","assets/Envelope2D-n2TB2v9l.js","assets/Point2D-BslC4Gs9.js","assets/OperatorDefinitions-DoM9xd5U.js","assets/SimpleGeometryCursor-BbFgAuic.js","assets/Transformation2D-B6W9saMR.js","assets/densifyOperator-CaiWkypI.js","assets/apiConverter-BOyb99jX.js","assets/jsonConverter-CYYMdpyx.js","assets/OptimizedGeometry-5fDazGe-.js","assets/memoryEstimations-C3WUBUZI.js","assets/differenceOperator-BKHsRZcL.js","assets/differenceOperator-DgUykR-S.js","assets/lengthOperator-DO2El8sG.js","assets/lengthOperator-Dt-MIlZz.js"])))=>i.map(i=>d[i]);
import{BS as e,BT as t,DT as n,GC as r,Li as i,MT as a,OT as o,RS as s,US as c,ax as l,bS as u,gD as d,ha as f,iE as p,jT as m,kv as h,nT as g,px as _,tE as v,uE as y,wx as b,xg as x,yg as S}from"./index-CzMixifc.js";import{n as C}from"./QueueProcessor-CbN5H2eO.js";import{c as w,f as T,l as E,n as D,o as O,p as k,r as A,s as j,t as M,u as N}from"./multidimensionalUtils-D8kRIpRe.js";import{E as P,U as F,d as I,t as L,z as R}from"./RasterSymbolizer-CSgBrmNy.js";import{a as z}from"./PixelBlock-Cu1E_t0b.js";import{D as ee,M as B,_ as te,o as ne,u as re,v as V}from"./vectorFieldUtils-BZ6-deEm.js";import{_ as ie,a as ae,c as oe,f as se,g as ce,h as le,i as ue,l as de,m as fe,n as pe,o as me,p as he,r as ge,s as _e,u as ve,y as ye}from"./RasterJobHandlerMixin-CluH4gXo.js";import{r as H,t as be}from"./datasetUtils-qcMNA5LE.js";import{a as xe,c as Se,i as Ce,o as we,r as Te}from"./RawBlockCache-D21-4QWl.js";import{a as U,c as Ee,f as W,l as De,n as Oe,o as ke,p as Ae,r as G,s as je,t as K,u as q}from"./rasterProjectionHelper-cBqbWx2d.js";import{i as J,r as Me}from"./clipUtils-0cgYPFvv.js";import{t as Ne}from"./rasterFunctionHelper-Cr6dPgkx.js";var Pe=8,Fe=256,Ie=0,Y=class extends r{constructor(){super(...arguments),this._tileFetchQueue=new C({concurrency:32,process:(e,t)=>this.fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:`closest`}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:`closest`,tileInfo:S.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){let{rasterInfo:e}=this,t=K(e.spatialReference);return t!=null&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){let{transform:e}=this.rasterInfo;return e==null||e.type===`gcs-shift`}set rasterJobHandler(e){this._set(`rasterJobHandler`,e),H(this)&&this.primaryRasters?.rasters?.forEach(t=>t.rasterJobHandler=e)}get rasterId(){return this.url||`rasterId-`+ Ie++}set url(e){this._set(`url`,c(e,y.getLogger(this)))}async open(e){return this._openPromise??=q().then(()=>this._open(e)),this._openPromise}async fetchTile(e,n,r,i={}){let a=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(e,n,r,a);if(!o)throw new t(`imagery-tile:out-of-bounds`,`Level for fetch tile out of range`);return i={noClip:!0,...i},this.fetchPixels(o,a.size[0],a.size[1],i)}async identify(e,t={}){e=v(_,e).clone().normalize();let{multidimensionalDefinition:n,timeExtent:r}=t,{rasterInfo:i}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:o}=i,{transposedVariableName:s}=t,c=o!=null&&a&&(r!=null||T(n));c&&!s&&(s=n!=null&&n.length>0?n[0].variableName??void 0:o.variables[0].name,t={...t,transposedVariableName:s}),t=this._getRequestOptionsWithSliceId(t);let{spatialReference:u,extent:d}=i,{datumTransformation:f}=t,p=ke(e,u,f);if(!d.intersects(p))return{location:p,value:null};if(i.transform!=null){let e=i.transform.inverseTransform(p);if(!i.nativeExtent.intersects(e))return{location:e,value:null};p=e}let m=0,h=s!=null&&o!=null&&i.hasMultidimensionalTranspose;if(H(this)){let e=this.primaryRasters.rasters[0];if(h)return e.identify(p,t);let{pixelSize:r}=i,a=r.x*3/2,o=r.y*3/2,s=new l({xmin:p.x-a,xmax:p.x+a,ymin:p.y-o,ymax:p.y+o,spatialReference:u}),c={interpolation:`nearest`,multidimensionalDefinition:n,sliceId:t.sliceId,bandIds:t.bandIds},{pixelBlock:d}=await e.fetchPixels(s,3,3,c),{pixelBlock:f}=await this.fetchPixels(s,3,3,c);if(d==null)return{location:p,value:null};let m=!d.mask||d.mask[4]?d.pixels.map(e=>e[4]):null,g;return f!=null&&(g=!f.mask||f.mask[4]?f.pixels.map(e=>e[4]):void 0),{location:p,value:m,processedValue:g,pyramidLevel:0}}if(!h){if(t.srcResolution)m=Ee(t.srcResolution,i,this.ioConfig.sampling).pyramidLevel;else if(m=await this.computeBestPyramidLevelForLocation(e,t),m==null)return{location:p,value:null}}let g=this.identifyPixelLocation(p,m,null,h);if(g===null)return{location:p,value:null};let{row:y,col:b,rowOffset:x,colOffset:S,blockWidth:C}=g,w=await this._fetchRawTile(m,y,b,t);if(!w?.pixels?.length)return{location:p,value:null};let E=x*C+S;return this._processIdentifyResult(w,{srcLocation:p,position:E,pyramidLevel:m,useTransposedTile:!!h,requestSomeSlices:c,identifyOptions:t})}async fetchPixels(e,t,n,r={}){e=je(e),r=this._getRequestOptionsWithSliceId(r);let{_hasNoneOrGCSShiftTransform:i}=this;if(r.requestRawData&&i)return this._fetchPixels(e,t,n,r);let a=K(e.spatialReference),o=W(e);if(a==null||o===0||o===1&&this._isGlobalWrappableSource&&i)return this._fetchPixels(e,t,n,r);if(o>=3)return{extent:e,pixelBlock:null};let s=[],{xmin:c,xmax:u}=e,d=Math.round(a/(u-c)*t),f=d-Math.round((a/2-c)/(u-c)*t),p=0,m=[];for(let i=0;i<=o;i++){let h=new l({xmin:i===0?c:-a/2,xmax:i===o?u-a*i:a/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),g=i===0?d-f:i===o?t-p:d;p+=g,m.push(g);let _=r.disableWrapAround&&i>0?null:this._fetchPixels(h,g,n,r);s.push(_)}let h=(await Promise.all(s)).map(e=>e?.pixelBlock),g=null,_={width:t,height:n};return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:_,destDimension:null,coefs:null,sampleSpacing:null,interpolation:`nearest`,alignmentInfo:null,blockWidths:m},r)).pixelBlock:V(h,_,{blockWidths:m}),{extent:e,srcExtent:G(e,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:g}}async fetchRawPixels(e,t,n,r={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};let i=await this._fetchRawTiles(e,t,n,r),{nativeExtent:a,nativePixelSize:o,storageInfo:s}=this.rasterInfo,c=2**e,u=o.x*c,d=o.y*c,f=new l({xmin:a.xmin+u*t.x,xmax:a.xmin+u*(t.x+n.width-1),ymin:a.ymax-d*(t.y+n.height-1),ymax:a.ymax-d*t.y,spatialReference:a.spatialReference});if(!i)return{extent:f,srcExtent:f,pixelBlock:null};let{pixelBlocks:p,mosaicSize:m}=i;if(p.length===1&&p[0]!=null&&p[0].width===n.width&&p[0].height===n.height)return{extent:f,srcExtent:f,pixelBlock:i.pixelBlocks[0]};let h=e>0?s.pyramidBlockWidth:s.blockWidth,g=e>0?s.pyramidBlockHeight:s.blockHeight,_={x:t.x%h,y:t.y%g},v;return v=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:m,destDimension:n,clipOffset:_,clipSize:n,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:V(p,m,{clipOffset:_,clipSize:n}),{extent:f,srcExtent:f,pixelBlock:v}}fetchRawTile(e,n,r,i){throw new t(`BaseRaster:read-not-implemented`,`fetchRawTile() is not implemented`)}computeExtent(e){return G(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?F(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,n=0){let{customFetchParameters:r}=this.ioConfig,{range:i,query:a,headers:o}=t;n=n??t.retryCount??this.ioConfig.retryCount;let c=i?{Range:`bytes=${i.from}-${i.to}`}:null;try{return await s(e,{...t,query:{...a,...r},headers:{...o,...c}})}catch(r){if(n>0)return n--,this.request(e,t,n);throw r}}getSliceIndex(e){let{multidimensionalInfo:t}=this.rasterInfo;return t==null||e==null||e.length===0?null:M(e,t)}getTileExtentFromTileInfo(e,t,n,r){let i=r.lodAt(e);return i?this.getTileExtent({x:i.resolution,y:i.resolution},t,n,r.origin,r.spatialReference,r.size):null}updateTileInfo(){let{storageInfo:e,spatialReference:t,extent:n,pixelSize:r}=this.rasterInfo,{pyramidResolutions:i}=e;if(!e.tileInfo){let a=[],o=e.maximumPyramidLevel||0,s=(r.x+r.y)/2,c=1/.0254*96*s;for(let e=0;e<=o&&(a.unshift(new x({level:o-e,resolution:s,scale:c})),e!==o);e++)if(i){let t=(i[e].x+i[e].y)/2;c*=t/s,s=t}else s*=2,c*=2;let l=new _({x:n.xmin,y:n.ymax,spatialReference:t});e.tileInfo=new S({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:a}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,n=512,r){let{width:i,height:a,nativeExtent:o,pixelSize:s,spatialReference:c}=e,l=new _({x:o.xmin,y:o.ymax,spatialReference:c});r??=Math.max(0,Math.round(Math.log(Math.max(i,a))/Math.LN2-8));let u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[s],r);e.storageInfo=new P({blockWidth:t,blockHeight:n,pyramidBlockWidth:t,pyramidBlockHeight:n,origin:l,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,n,r,i,a=0,o=2){if(i.length===1&&a>0){i=[...i];let{x:e,y:t}=i[0];for(let n=0;n<a;n++)e*=o,t*=o,i.push({x:e,y:t})}let s=[],{x:c,y:l}=r;for(let r=0;r<i.length;r++){let{x:a,y:o}=i[r];s.push({minCol:Math.floor((e.xmin-c+.1*a)/t/a),maxCol:Math.floor((e.xmax-c-.1*a)/t/a),minRow:Math.floor((l-e.ymax+.1*o)/n/o),maxRow:Math.floor((l-e.ymin-.1*o)/n/o)})}return s}getPyramidPixelSize(e){let{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:n,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(e===0)return t;if(n!=null&&n.length)return n[e-1];let i=r**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,n,r){let{spatialReference:i,nativeExtent:a,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:s,origin:c,transposeInfo:l}=o,u=r&&l!=null?l.tileSize[0]:o.blockWidth,d=r&&l!=null?l.tileSize[1]:o.blockHeight,f=ke(e,i,n);if(!a.intersects(f)||t<0||t>s)return null;let p=this.getPyramidPixelSize(t),{x:m,y:h}=p,g=(c.y-f.y)/h/d,_=(f.x-c.x)/m/u,v=Math.min(d-1,Math.floor((g-Math.floor(g))*d)),y=Math.min(u-1,Math.floor((_-Math.floor(_))*u));return{pyramidLevel:t,row:Math.floor(g),col:Math.floor(_),rowOffset:v,colOffset:y,blockWidth:u,srcLocation:f}}getTileExtent(e,t,n,r,i,a){let[o,s]=a,c=r.x+n*o*e.x,u=c+o*e.x,d=r.y-t*s*e.y,f=d-s*e.y;return new l({xmin:c,xmax:u,ymin:f,ymax:d,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,n){let r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<n||r.minRow>t||r.minCol>n}updateImageSpaceRasterInfo(e){let{pixelSize:t}=e,{width:n,height:r}=e,i=b.WebMercator;e.spatialReference=i,e.extent=e.nativeExtent=new l({xmin:-.5,ymax:.5,xmax:n-.5,ymin:.5-r,spatialReference:i}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new _({x:1,y:1,spatialReference:i});let{extent:a,storageInfo:o}=e;if(o){o.origin=new _({x:a.xmin,y:a.ymax,spatialReference:i});let{pyramidResolutions:n,tileInfo:r}=o;if(n&&n.forEach(e=>{e.x/=t.x,e.y/=t.y}),r){r.origin=o.origin;let t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;r.lods.forEach((e,n)=>{e.resolution=t*2**n,e.scale=96*e.resolution/.0254})}}}async _fetchPixels(e,t,n,r={}){let i=W(e);if(i>=2)return{extent:e,pixelBlock:null};let a=this._getSourceDataInfo(e,t,n,r),{pyramidLevel:o,srcResolution:s,srcExtent:c,srcWidth:l,srcHeight:u,ul:d}=a;if(l===0||u===0)return{extent:e,srcExtent:c,pixelBlock:null};let{rasterInfo:f}=this,p=f.transform,m=p?.type===`gcs-shift`,h=K(e.spatialReference)!=null;!m&&h||(i=W(a.srcExtent,m));let g=await this._fetchRawTiles(o,d,{width:l,height:u,wrapCount:i},r);if(!g)return{extent:e,srcExtent:c,pixelBlock:null};let v=f.storageInfo,y=o>0?v.pyramidBlockWidth:v.blockWidth,b=o>0?v.pyramidBlockHeight:v.blockHeight,{x,y:S}=f.pixelSize;if(o>0){let{pyramidResolutions:e,pyramidScalingFactor:t}=v;if(e!=null&&e[o-1])({x,y:S}=e[o-1]);else{let e=t**o;x*=e,S*=e}}let C=f.spatialReference,w=new _({x,y:S,spatialReference:C}),T=y===l&&b===u&&d.x%y===0&&d.y%b===0,E=new _({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/n,spatialReference:e.spatialReference}),D=!e.spatialReference.equals(C),O=C.isGeographic?1e-9:1e-4,{datumTransformation:k}=r;if(!D&&T&&g.pixelBlocks.length===1&&y===t&&b===n&&Le(s,E,O))return{extent:e,srcExtent:c,srcTilePixelSize:w,pixelBlock:g.pixelBlocks[0]};let A=h&&K(c.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,j=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith(`vector`);j&&!this.rasterJobHandler&&await q();let M=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:E.toJSON(),datumTransformation:k,rasterTransform:p,hasWrapAround:i>0||A,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:j},r):Ae({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:E,datumTransformation:k,rasterTransform:p,hasWrapAround:i>0||A,isAdaptive:!1,includeGCSGrid:j}),N,P=!r.requestRawData,F={rows:M.spacing[0],cols:M.spacing[1]},I=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(o,g.extent.xmin):void 0,{pixelBlocks:L,mosaicSize:R,isPartiallyFilled:z}=g,B=null;if(this.rasterJobHandler){let e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:L,srcMosaicSize:R,destDimension:P?{width:t,height:n}:null,coefs:P?M.coefficients:null,sampleSpacing:P?F:null,projectDirections:j,gcsGrid:j?M.gcsGrid:null,isUV:this.rasterInfo.dataType===`vector-uv`,interpolation:r.interpolation,alignmentInfo:I,blockWidths:null},r);({pixelBlock:N,localNorthDirections:B}=e)}else{let e=V(L,R,{alignmentInfo:I});N=P?te(e,{width:t,height:n},M.coefficients,F,r.interpolation):e,j&&M.gcsGrid&&(B=ee({width:t,height:n},M.gcsGrid),N=re(N,this.rasterInfo.dataType,B))}return r.requestRawData||j?{extent:e,srcExtent:c,srcTilePixelSize:w,pixelBlock:N,transformGrid:M,localNorthDirections:B,isPartiallyFilled:z}:{extent:e,srcExtent:c,srcTilePixelSize:w,pixelBlock:N}}async _fetchRawTiles(e,t,n,r){let{origin:i,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:s}=this.getBlockWidthHeight(e),{x:c,y:u}=t,{width:d,height:f,wrapCount:p}=n,m=this._getRasterTileAlignmentInfo(e,0);r.buffer&&(c-=r.buffer.cols,u-=r.buffer.rows,d+=2*r.buffer.cols,f+=2*r.buffer.rows);let h=0,g=0,_=0;p&&m!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:_,rightPadding:h}=m,g*m.blockWidth-h>=c+d&&(h=0));let v=Math.floor(c/o),y=Math.floor(u/s),b=Math.floor((c+d+h-1)/o),x=Math.floor((u+f+h-1)/s),S=a[e];if(!S)return null;let{minRow:C,minCol:w,maxCol:T,maxRow:E}=S;if(p===0&&(x<C||b<w||y>E||v>T))return null;let D=[],O=!1,k=this.ioConfig.allowPartialFill==null?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=y;t<=x;t++)for(let n=v;n<=b;n++){let i=n;if(!r.disableWrapAround&&p&&m!=null&&g<=n&&(i=n-g-_),t>=C&&i>=w&&E>=t&&T>=i){let n=this._fetchRawTile(e,t,i,r);k?D.push(new Promise(e=>{n.then(t=>e(t)).catch(()=>{O=!0,e(null)})})):D.push(n)}else D.push(Promise.resolve(null))}if(D.length===0)return null;let A=await Promise.all(D),j={height:(x-y+1)*s,width:(b-v+1)*o},{spatialReference:M}=this.rasterInfo,N=this.getPyramidPixelSize(e),{x:P,y:F}=N;return{extent:new l({xmin:i.x+v*o*P,xmax:i.x+(b+1)*o*P,ymin:i.y-(x+1)*s*F,ymax:i.y-y*s*F,spatialReference:M}),pixelBlocks:A,mosaicSize:j,isPartiallyFilled:O}}_fetchRawTile(e,t,n,r){let{storageInfo:i}=this.rasterInfo,a=i.transposeInfo!=null&&!!r.transposedVariableName;if(!a){let r=i.blockBoundary[e];if(!r)return Promise.resolve(null);let{minRow:a,minCol:o,maxCol:s,maxRow:c}=r;if(t<a||n<o||t>c||n>s)return Promise.resolve(null)}let o=a?r.transposeVariableName:r.sliceId,s=i.isBsqTile?r.bandIds:null,c=Ce(this.rasterId,o,s),l=`${e}/${t}/${n}`,u=xe(c,r.registryId,l);if(u==null){let a=new AbortController,o=r.bandIds?.slice();if(o?.length&&i.isBsqTile){let i=new Set(o),s=[],c=Array.from(i);for(let i of c)s.push(this._tileFetchQueue.push({pyramidLevel:e,row:t,col:n,options:{...r,bandIds:[i]}},{signal:a.signal}));u=Promise.all(s).then(e=>{if(e.some(e=>e==null))return null;if(c.length!==o.length){let t=[];for(let n of o){let r=e[c.indexOf(n)];t.includes(r)&&(r=r.clone()),t.push(r)}e=t}return this.rasterJobHandler?this.rasterJobHandler.compositeBands({pixelBlocks:e},{signal:a.signal,transferPixelsToWorker:!0}):B(e)})}else u=this._tileFetchQueue.push({pyramidLevel:e,row:t,col:n,options:r},{signal:a.signal});Te(c,r.registryId,l,u,a),u.catch(()=>Se(c,r.registryId,l))}return r.signal&&g(r,()=>{we(c,r.registryId,l)}),u}_computeMagDirValues(e){let{bandCount:t,dataType:n}=this.rasterInfo;if(!(t===2&&n===`vector-magdir`||n===`vector-uv`)||e?.length!==2||!e[0]?.length)return null;let r=e[0].length;if(n===`vector-magdir`){let t=e[1].map(e=>(e+360)%360);return[e[0],t]}let[i,a]=e,o=[],s=[];for(let e=0;e<r;e++){let[t,n]=ne([i[e],a[e]]);o.push(t),s.push(n)}return[o,s]}_getRasterTileAlignmentInfo(e,t){return this._rasterTileAlignmentInfo??=De(this.rasterInfo),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,n,r={}){let i={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(i.srcResolution=r.srcResolution,this._updateSourceDataInfo(e,i));let a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:s,pyramidLevel:c}=i,l=o/t,u=s/n,d=c<a&&l*u>=16,f=c===a&&this._requireTooManySrcTiles(o,s,t,n);if(d||f||o===0||s===0){let o=new _({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/n,spatialReference:e.spatialReference}),s=Oe(o,this.rasterInfo.spatialReference,e,i.datumTransformation),f=!s||r.srcResolution&&s.x+s.y<r.srcResolution.x+r.srcResolution.y;if(d&&r.srcResolution&&f){let e=Math.round(Math.log(Math.max(l,u))/Math.LN2)-1;if(a-c+3>=e){let t=2**e;s={x:r.srcResolution.x*t,y:r.srcResolution.y*t}}}s&&(i.srcResolution=s,this._updateSourceDataInfo(e,i))}return this._requireTooManySrcTiles(i.srcWidth,i.srcHeight,t,n)&&(i.srcWidth=0,i.srcHeight=0),i}_requireTooManySrcTiles(e,t,n,r){let{tileInfo:i}=this.rasterInfo.storageInfo,a=Math.ceil(e/i.size[0])*Math.ceil(t/i.size[1]),o=e/n,s=t/r,c=Math.max(1,(n+r)/1024);return a>=Fe*c||o>Pe||s>Pe}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;let{rasterInfo:n}=this,r=n.spatialReference,{srcResolution:i,datumTransformation:a}=t,{pyramidLevel:o,pyramidResolution:s,excessiveReading:c}=Ee(i,n,this.ioConfig.sampling);if(c)return;let l=t.srcExtent||G(e,r,a);if(l==null)return;let u=n.transform;u&&(l=u.inverseTransform(l)),t.srcExtent=l;let{origin:d}=n.storageInfo,{width:f,height:p,ul:m}=be(l,d,s,o);t.pyramidLevel=o,t.pyramidResolution=s,t.srcWidth=f,t.srcHeight=p,t.ul=m}_getRequestOptionsWithSliceId(e){return this.rasterInfo.multidimensionalInfo!=null&&e.sliceId==null&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){let{srcLocation:n,position:r,pyramidLevel:i,useTransposedTile:a}=t,o=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[r]))return{location:n,value:null};let{multidimensionalInfo:s}=this.rasterInfo;if(s==null||!a){let t=e.pixels.map(e=>e[r]),a={location:n,value:t,pyramidLevel:i},o=this._computeMagDirValues(t.map(e=>[e]));return o?.length&&(a.magdirValue=o.map(e=>e[0])),a}let c=e.pixels.map(e=>e.slice(r*o,r*o+o)),l=this._computeMagDirValues(c),{requestSomeSlices:u,identifyOptions:d}=t,f=E(s,d.transposedVariableName);if(u){let e=w(f,d.multidimensionalDefinition,d.timeExtent);c=c.map(t=>e.map(e=>t[e])),l=l?.map(t=>e.map(e=>t[e])),f=e.map(e=>f[e])}let p=e.noDataValues||this.rasterInfo.noDataValue,m={pixels:c,pixelType:e.pixelType},h;return p!=null&&(z(m,p),h=m.mask),{location:n,value:null,dataSeries:f.map((e,t)=>{let n={value:h?.[t]===0?null:c.map(e=>e[t]),multidimensionalDefinition:e.multidimensionalDefinition.map(e=>new k({...e,isSlice:!0}))};return l?.length&&(n.magdirValue=[l[0][t],l[1][t]]),n}),pyramidLevel:i}}};function Le(e,t,n){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n}d([n()],Y.prototype,`_rasterTileAlignmentInfo`,void 0),d([n()],Y.prototype,`_tileFetchQueue`,void 0),d([n({readOnly:!0})],Y.prototype,`_isGlobalWrappableSource`,null),d([n({readOnly:!0})],Y.prototype,`_hasNoneOrGCSShiftTransform`,null),d([n()],Y.prototype,`_openPromise`,void 0),d([n()],Y.prototype,`rasterJobHandler`,null),d([n({readOnly:!0})],Y.prototype,`rasterId`,null),d([n(i)],Y.prototype,`url`,null),d([n({type:String,json:{write:!0}})],Y.prototype,`datasetName`,void 0),d([n({type:String,json:{write:!0}})],Y.prototype,`datasetFormat`,void 0),d([n()],Y.prototype,`hasUniqueSourceStorageInfo`,void 0),d([n()],Y.prototype,`rasterInfo`,void 0),d([n()],Y.prototype,`ioConfig`,void 0),d([n()],Y.prototype,`sourceJSON`,void 0),Y=d([o(`esri.layers.raster.datasets.BaseRaster`)],Y);var Re=40,X=class extends Y{constructor(){super(...arguments),this.datasetFormat=`Function`,this.tileType=`Raster`,this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,n,r={}){let{rasters:i,rasterIds:a}=this.primaryRasters,o=!1,{interpolation:s}=r,c=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&c&&(o=i.length===1&&!r.skipRasterFunction,r={...r,interpolation:`bilinear`,requestRawData:o}),r.requestRawData&&i.length>1&&!this.hasUniqueSourceStorageInfo&&(o=!1,r={...r,requestRawData:!1});let l=i.map(i=>i.fetchPixels(e,t,n,r)),u=await Promise.all(l),d=u.map(e=>e.pixelBlock),f=o||r.requestRawData?u.map(e=>e.srcTilePixelSize):null;if(r.skipRasterFunction||d.every(e=>e==null))return u[0];let p=u.find(e=>e.pixelBlock!=null)?.extent??e,m=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:a}):this.rasterFunction.process({extent:p,primaryPixelBlocks:d,primaryPixelSizes:f,primaryRasterIds:a}),{transformGrid:h}=u[0];if(!o||m==null||h==null){let e=r.noClip?null:this.getClippingGeometry(p.spatialReference);return!r.noClip&&m!=null&&e&&(m=await J(m,p,e)),{...u[0],pixelBlock:m}}let g={rows:h.spacing[0],cols:h.spacing[1]},_;_=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[m],srcMosaicSize:{width:m.width,height:m.height},destDimension:{width:t,height:n},coefs:h.coefficients,sampleSpacing:g,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:s,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:te(m,{width:t,height:n},h.coefficients,g,s);let v=r.noClip?null:this.getClippingGeometry(e.spatialReference);return r.noClip||_==null||v==null||(_=await J(_,e,v)),{extent:e,srcExtent:u[0].srcExtent,pixelBlock:_}}getClippingGeometry(e){let t=this._clippingGeometry.get(`0`);if(!e||!t)return t;let n=Be(e),r=this._clippingGeometry.get(n);return r??(r=e.equals(t.spatialReference)?t:U(t,e),this._clippingGeometry.set(n,r)),r}async _open(e){let{rasterFunction:n}=this;n.isRoot=!0,this.primaryRasters?.rasters?.length?n.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=n.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(e=>e.rasterJobHandler=this.rasterJobHandler));let{rasters:r,rasterIds:i}=this.primaryRasters,a=r.map(t=>t.rasterInfo?void 0:t.open(e));await Promise.all(a);let o=r.map(({rasterInfo:e})=>e),s=n.bind({rasterInfos:o,rasterIds:i});if(n.rawSourceRasterInfos=o,!s.success||o.length===0)throw new t(`raster-function:open`,`cannot bind the function: ${s.error??``}`);let c=n.functionName===`Table`?n:n.functionArguments?.raster;c?.functionName===`Table`&&(n.rasterInfo.attributeTable=f.fromJSON(c.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();let l=o[0];this.hasUniqueSourceStorageInfo=o.length===1||o.slice(1).every(e=>ze(e,l)),this.set(`sourceJSON`,r[0].sourceJSON),this.set(`rasterInfo`,n.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){let t=this.rasterFunction.getClippingGeometries()[0],n=t?.clippingGeometry;if(n&&t.clippingType===`inside`){let{extent:t}=this.rasterInfo,r=await e(()=>import(`./densifyOperator-WG5sF5gR.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13])),i=await e(()=>import(`./differenceOperator-BKHsRZcL.js`),__vite__mapDeps([14,1,2,3,4,5,6,7,8,15,10,11,12,13])),a=r.execute(h.fromExtent(t),2*(t.width+t.height)/Re);a=U(a,n.spatialReference),n=i.execute(a,n)}this._clippingGeometry.clear(),n&&this._clippingGeometry.set(`0`,n)}};function ze(e,t){let{storageInfo:n,pixelSize:r,spatialReference:i,extent:a}=e,{storageInfo:o,pixelSize:s,spatialReference:c,extent:l}=t;return r.x===s.x&&r.y===s.y&&i.equals(c)&&a.equals(l)&&n.blockHeight===o.blockHeight&&n.blockWidth===o.blockWidth&&n.maximumPyramidLevel===o.maximumPyramidLevel&&n.firstPyramidLevel===o.firstPyramidLevel&&n.pyramidBlockWidth===o.pyramidBlockWidth&&n.pyramidBlockHeight===o.pyramidBlockHeight&&n.pyramidScalingFactor===o.pyramidScalingFactor}function Be(e){return String(e.wkid??e.wkt??e.wkt2)}d([n({type:String,json:{write:!0}})],X.prototype,`datasetFormat`,void 0),d([n()],X.prototype,`tileType`,void 0),d([n()],X.prototype,`rasterFunction`,void 0),d([n()],X.prototype,`primaryRasters`,void 0),X=d([o(`esri.layers.raster.datasets.FunctionRaster`)],X);var Ve=1e3,He=r=>{let l=r,f=class extends l{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=H(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set(`multidimensionalDefinition`,e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()===`none`&&(e=void 0),this._set(`rasterFunction`,e),this.updateRasterFunction()}set url(e){this._set(`url`,c(e,y.getLogger(this)))}get renderer(){if(this.type!==`imagery-tile`)return this.internalRenderer;let{activePresetRendererName:e,presetRenderers:t}=this;return e?(t?.find(({name:t})=>t===e))?.renderer.clone():this.internalRenderer}set renderer(e){this.type===`imagery-tile`&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer(`override`):(this._set(`internalRenderer`,e),this.updateRenderer())}readRenderer(e,t,n){let r=t?.layerDefinition?.drawingInfo?.renderer;return me(r,n)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=v(ae,e).clone();let{serviceRasterInfo:r}=this;if(r==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`serviceRasterInfo must be specified`);let{geometry:i}=e;if(i==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`geometry must be specified`);let a=i,{spatialReference:o}=r;if(!i.spatialReference.equals(o)){await q();let e=i.type===`extent`?G(i,o):U(i,o);if(e==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`geometry cannot be projected to the data source`);a=e}let s=e.pixelSize??new _({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:o}),{extent:c,width:l,height:u}=Me(r,a,s),d=await this.fetchPixels(c,l,u,{...n,interpolation:`nearest`});if(d.pixelBlock==null)throw new t(`imagery-tile-mixin:compute-statistics-histograms`,`failed to fetch pixels`);let f=await J(d.pixelBlock,c,a),p=this._rasterJobHandler;return p?p.computeStatisticsHistograms({pixelBlock:f},n):I(f)}normalizeRasterFetchOptions(e){let{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(t==null)return e;let n=O({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:n,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type===`imagery-tile`&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){let{loaded:e,symbolizer:t,renderer:n}=this;if(!e||!t||!n)return;let{rasterInfo:r}=this.raster,i=N(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=i?.name,o=he(r,a);return this._updateSymbolizer(t,n,a,o)}async applyRenderer(e,t,n){let r=e?.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();let i=this.bandIds??[],{pixelBlock:a}=await this._symbolize({pixelData:e,simpleStretchParams:t,bandIds:i,symbolizer:this.symbolizer},n);return a}getRawDisplayBandIds(){let{bandIds:e,raster:t}=this;if(this.rasterFunction&&H(t)){let n=t.rasterFunction.rawInputBandIds;e=e?.length&&n?.length&&t.rasterInfo.bandCount!==1?e.map(e=>n[Math.min(e,n.length-1)]):n}return e&&e.length>3&&e.every((e,t)=>e===t)?null:e}getTileUrl(e,t,n){return this.raster.datasetFormat===`RasterTileServer`?`${this.url}/tile/${e}/${t}/${n}`:``}getCompatibleTileInfo(e,t,n=!1){if(!this.loaded||t==null)return null;if(n&&e.equals(this.spatialReference))return this.tileInfo;let r=u(e);return S.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,n,r={}){if(h(this),r.requestAsImageElement){let i=this.getTileUrl(e,t,n);return s(i,{responseType:`image`,query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(e=>e.data)}let{serviceRasterInfo:i}=this;if(i.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){let a=r.tileInfo||i.storageInfo.tileInfo,o=this.raster.getTileExtentFromTileInfo(e,t,n,a);if(o)return{extent:o,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type===`raster-shaded-relief`&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,n,r)}async fetchPixels(e,t,n,r={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),n=Math.round(n);let i=await this.raster.fetchPixels(e,t,n,r);return r.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(i.pixelBlock=i.pixelBlock?.extractBands(r.bandIds)),i}async getSamples(e,n){if(await this.load(),(e=v(ue,e).clone()).interpolation&&e.interpolation!==`nearest`)throw new t(`imagery-tile-mixin:get-samples`,`only nearest interpolation is currently supported`);let r=e.mosaicRule?.multidimensionalDefinition,i={...n,multidimensionalDefinition:r},a=(await this._getSampleLocations(e)).map(e=>this.identify(e,i).then(t=>(t.location=e,t))),o=(await Promise.all(a)).flatMap((e,t)=>this._convertRasterIdentifyResultToSample(e,t));return new pe({samples:o})}async identify(e,n={}){await this.load(),e=v(_,e).clone().normalize();let{raster:r,serviceRasterInfo:i}=this;if(i?.multidimensionalInfo!=null&&!(i.hasMultidimensionalTranspose&&!(!T(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};let a=this.multidimensionalSubset?.areaOfInterest;if(a&&!a.contains(e))throw new t(`imagery-tile-mixin:identify`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);let o;if(this.serviceRasterInfo?.storageInfo.isBsqTile){let e=H(r)?this.getRawDisplayBandIds():this.bandIds;o=e?.length?e:void 0}return r.identify(e,{...n,bandIds:o})}hasStandardTime(){let e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!==`standard-time`)return!1;let t=this.multidimensionalDefinition,n=t?.[0]?.variableName;return e.variables.some(e=>e.name===n&&(!t?.[0].dimensionName||e.dimensions.some(e=>e.name===`StdTime`)))}getStandardTimeValue(e){return new Date(j(e)).toISOString()}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo?.multidimensionalInfo;return D(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||=A(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}),this.rasterFunction&&H(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;h(this);let{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,H(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){let{geometry:n}=t;if(n.type===`point`)return[n];let{spatialReference:r,type:i}=n;if(i===`multipoint`)return n.points.map(e=>new _({x:e[0],y:e[1],spatialReference:r}));if(i===`polyline`){let i=n;if(t.sampleCount||t.sampleDistance){let r=await e(()=>import(`./densifyOperator-WG5sF5gR.js`),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13])),a=(await e(async()=>{let{execute:e}=await import(`./lengthOperator-DO2El8sG.js`);return{execute:e}},__vite__mapDeps([16,1,2,3,4,5,6,7,8,17,10,11,12,13]))).execute(n,{unit:`meters`}),o=Math.min(t.sampleCount||100,Ve),s=t.sampleDistance;s||=a/(o+(i.paths[0].length===2?1:0)),i=r.execute(n,s,{unit:`meters`})}return i.paths.flatMap(e=>e.map(e=>new _({x:e[0],y:e[1],spatialReference:r})))}let a=Math.min(t.sampleCount||100,Ve),o=n.type===`extent`,s=o?n:n.extent,c=Math.sqrt(s.width*s.height/a),l=s.height/c,u=s.width/c,{xmin:d,ymax:f}=s,p=[];for(let e=0;e<l;e++)for(let t=0;t<u;t++){let i=new _({x:d+(t+.5)*c,y:f-(e+.5)*c,spatialReference:r});(o||n.contains(i))&&p.push(i)}return p}_configDefaultInterpolation(){if(this.interpolation==null){h(this);let{raster:e}=this,t=se(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set(`interpolation`,t)}}_configDefaultRenderer(e=`no`){h(this);let{rasterInfo:t}=this.raster,n=N(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=n?.name,i=le({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=i?.bandIds??ve(t)),!this.renderer||e===`override`){let e=ce(this.raster),n=i?.renderer??de(t,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:e}),a=t.statistics,o=a&&a.length>0?a[0]:null,s=o?.max??0,c=o?.min??0;this.raster.datasetFormat===`WCSServer`&&n.type===`raster-stretch`&&(s>1e24||c<-1e24)&&(n.dynamicRangeAdjustment=!0,n.customStatistics=null,n.stretchType===`none`&&(n.stretchType=`min-max`)),this.renderer=n}let a=fe({...this.renderer.toJSON(),variableName:r}),o=he(t,r);this.symbolizer?(this.symbolizer.rendererJSON=a,this.symbolizer.rasterInfo=o):this.symbolizer=new L({rendererJSON:a,rasterInfo:o});let s=this.symbolizer.bind();if(s.success){if(e===`auto`){let{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(e!=null&&t.type===`raster-colormap`){let e=de(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer(`override`)}else if(t.type===`raster-stretch`){let e=this.bandIds?.length,n=t.customStatistics?.length;!t.dynamicRangeAdjustment&&n&&e&&n!==e&&this._configDefaultRenderer(`override`)}}}else y.getLogger(this).warn(`imagery-tile-mixin`,s.error||`The given renderer is not supported by the layer.`),e===`auto`&&this._configDefaultRenderer(`override`)}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&H(this.raster)){let e=this.raster.rasterFunction.toJSON();!this.rasterFunction&&e&&this._set(`rasterFunction`,ye.fromJSON(e));return}let e,t=this.raster,n=!1;H(t)?(e=t.primaryRasters.rasters,t=e[0],n=!0):e=[t];let{rasterFunction:r}=this;if(r){let n={raster:t};e.length>1&&e.forEach(e=>n[e.url]=e);let i=Ne(r.functionDefinition?.toJSON()??r.toJSON(),n),a=new X({rasterFunction:i});a.rasterJobHandler=this._rasterJobHandler,await a.open(),this.raster=a}else this.raster=t,await t.open();if(this._cachedRendererJson=void 0,!n&&!r)return;let{bandIds:i}=this,{bandCount:a}=this.raster.rasterInfo,o=i?.length?i.some(e=>e>=a):a>=3;i&&(o||this.renderer&&this.renderer.type!==`raster-stretch`)&&this._set(`bandIds`,null),this._configDefaultRenderer(`auto`)}_convertRasterIdentifyResultToSample(e,t){let{rasterInfo:n}=this.raster,r=n.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),i=(n.pixelSize.x+n.pixelSize.y)/2*r;if(!e.dataSeries?.length)return[new ge({location:e.location,pixelValue:e.value,locationId:t,resolution:i})];let a=[];return e.dataSeries.forEach(({value:n,multidimensionalDefinition:r},o)=>{let s={Variables:r[0].variableName,Dimensions:r.flatMap(({dimensionName:e})=>e).join(`,`)};for(let{dimensionName:e,values:t}of r){s[e]=Array.isArray(t[0])?t[0][0]:t[0];let n=t[t.length-1];s[`${e}_Max`]=Array.isArray(n)?n[n.length-1]:n}let c=new ge({location:e.location,pixelValue:n,rasterId:o,locationId:t,resolution:i,attributes:s});a.push(c)}),a}};function h(e){if(!e.raster||!e.serviceRasterInfo)throw new t(`imagery-tile`,`no raster`)}return d([n({clonable:!1})],f.prototype,`_cachedRasterFunctionJson`,void 0),d([n({clonable:!1})],f.prototype,`_compatibleFullExtent`,void 0),d([n({clonable:!1})],f.prototype,`_isConstructedFromFunctionRaster`,void 0),d([n({clonable:!1})],f.prototype,`_rasterFunctionUpdatePromise`,void 0),d([n({type:[p],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType===`Raster`||this.bandIds?.join(`,`)!==`0,1,2`}}}}})],f.prototype,`bandIds`,void 0),d([n({json:{origins:{service:{read:{source:`copyrightText`}}}}})],f.prototype,`copyright`,void 0),d([n({json:{read:!1}})],f.prototype,`fullExtent`,null),d([n({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType===`Raster`||this.interpolation!==`bilinear`}}}}}),a(R)],f.prototype,`interpolation`,void 0),d([n()],f.prototype,`ioConfig`,void 0),d([n({type:[k],json:{write:!0}})],f.prototype,`multidimensionalDefinition`,null),d([n({type:ie,json:{write:!0}})],f.prototype,`multidimensionalSubset`,void 0),d([n()],f.prototype,`raster`,void 0),d([n({type:ye})],f.prototype,`rasterFunction`,null),d([n()],f.prototype,`serviceRasterInfo`,void 0),d([n()],f.prototype,`sourceJSON`,void 0),d([n({readOnly:!0,type:b,json:{read:!1}})],f.prototype,`spatialReference`,void 0),d([n({type:S})],f.prototype,`tileInfo`,void 0),d([n(i)],f.prototype,`url`,null),d([n({types:_e})],f.prototype,`renderer`,null),d([n({types:_e,json:{name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy(){let e=this.renderer?.type===`raster-stretch`&&this.renderer.stretchType===`none`&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType===`Raster`||!e}}},origins:{"web-scene":{types:oe,name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy:e=>({enabled:e&&e.type!==`vector-field`})}}}}})],f.prototype,`internalRenderer`,null),d([m(`internalRenderer`)],f.prototype,`readRenderer`,null),d([n({clonable:!1})],f.prototype,`symbolizer`,void 0),f=d([o(`esri.layers.mixins.ImageryTileMixin`)],f),f};function Z(e,t){if(!e||!t)return[];let n=t;t.includes(`/`)?(n=t.slice(0,t.indexOf(`/`)),t=t.slice(t.indexOf(`/`)+1)):t=``;let r=[];if(t){let i=Z(e,n);for(let e=0;e<i.length;e++)Z(i[e],t).forEach(e=>r.push(e));return r}let i=e.getElementsByTagNameNS(`*`,n);if(!i||i.length===0)return[];for(let e=0;e<i.length;e++)r.push(i[e]||i.item(e));return r}function Q(e,t){if(!e||!t)return null;let n=t;t.includes(`/`)?(n=t.slice(0,t.indexOf(`/`)),t=t.slice(t.indexOf(`/`)+1)):t=``;let r=Z(e,n);return r.length>0?t?Q(r[0],t):r[0]:null}function $(e,t=null){let n=t?Q(e,t):e,r;return n?(r=n.textContent||n.nodeValue,r?r.trim():null):null}function Ue(e,t){let n=Z(e,t),r=[],i;for(let e=0;e<n.length;e++)i=n[e].textContent||n[e].nodeValue,i&&(i=i.trim(),i!==``&&r.push(i));return r}function We(e,t=null){return $(e,t)?.split(` `).map(e=>Number(e))??[]}function Ge(e,t){return Ue(e,t).map(e=>Number(e))}function Ke(e,t){let n=$(e,t);return Number(n)}function qe(e,t){let n=e?.nodeName?.toLowerCase(),r=t.toLowerCase();return n.slice(n.lastIndexOf(`:`)+1)===r}function Je(e){return e.nodeName.slice(e.nodeName.lastIndexOf(`:`)+1)}export{Z as a,$ as c,X as d,Y as f,Ue as i,Ge as l,Q as n,Ke as o,qe as r,We as s,Je as t,He as u};