import{A as e,cn as t,dn as n,et as r,in as i,k as a,kt as o,mn as s,nt as c,wn as l}from"./Point2D-7VmvyXN4.js";import{Kn as u,in as d,un as f,yn as p}from"./SpatialReference-HLIf1Z5k.js";import{n as m,t as h}from"./SimpleGeometryCursor-5wFw2ZZo.js";function g(e,t,n,r,a,o){if(e===null&&i(``),e.getDimension()<1&&i(``),a>0||i(``),s(e),t===0||e.isEmpty())return e;let c=new w(o);return c.m_bUseZ=e.hasAttribute(1),c.m_bUseM=e.hasAttribute(2),c.m_inputGeometry=e,c.m_distance=t,c.m_tolerance=a,c.m_joins=n,c.m_miterLimit=r>1?r:1,c.m_progressCounter=0,c.constructOffset()}var _=1.4142135623730951,v=.017453292519943295,y=256,b=512,x=1024,S=class e{static construct(t,n,r){let i=new e;return i.x=t.x,i.y=t.y,i.m_next=-1,i.m_prev=-1,i.z=n,i.m=r,i.type=0,i}clone(){let t=new e;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new o(this.x,this.y)}};function C(){return{pt:new S,bAtExistingPt:!1}}var w=class i{constructor(e){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=e}constructOffset(){let e=this.m_inputGeometry.getGeometryType();if(e===t.enumLine)return this.offsetLine();if(e===t.enumEnvelope)return this.offsetEnvelope();if(n(e)){let e=new f;return e.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=e,this.constructOffset()}if(e===t.enumPolyline){let e=new f;return this.offsetMultiPath(e),e}if(e===t.enumPolygon){let e=new p;return this.offsetMultiPath(e),e}l(``)}offsetLine(){let e=this.m_inputGeometry,t=e.getStartXY(),n=e.getEndXY(),r=new o;r.setSub(n,t),r.normalize(),r.leftPerpendicularThis(),r.scale(this.m_distance),t.addThis(r),n.addThis(r);let i=e.clone();return i.setStartXY(t),i.setEndXY(n),i}offsetEnvelope(){let e=this.m_inputGeometry;if(this.m_distance>0&&this.m_joins!==2){let t=new p;return t.addEnvelope(e,!1),this.m_inputGeometry=t,this.constructOffset()}let t=e.clone();return t.inflateCoords(this.m_distance,this.m_distance),t}progress(){}static buildPoint(e,t,n,r){r.x=e.x+t*Math.cos(n),r.y=e.y+t*Math.sin(n),r.type=e.type,r.z=e.z,r.m=e.m,r.m_next=-1,r.m_prev=-1}addPoint(e){this.m_offsetPts.push(e.clone()),this.m_offsetPtCount++}addPointEx(e,t){if(this.m_offsetPtCount===0)return void this.addPoint(e);let n=this.m_srcPtCount,r=this.m_srcPts[t===0?n-1:t-1],a=this.m_srcPts[t],o=i.dotSign(r,a,this.m_offsetPts[this.m_offsetPtCount-1],e);if(o>0)this.addPoint(e);else if(o<0)if(i.dotSign(r,a,a,this.m_offsetPts[this.m_offsetPtCount-1])>0){let a=new S,o;o=t===0?n-2:t===1?n-1:t-2;let s=this.m_srcPts[o],l=Math.atan2(r.y-s.y,r.x-s.x);if(i.buildPoint(r,this.m_distance,l-c,a),this.m_offsetPts[this.m_offsetPtCount-1]=a.clone(),this.m_joins===1||this.m_joins===2){a.x=.5*(a.x+r.x),a.y=.5*(a.y+r.y),this.addPoint(a),i.buildPoint(r,this.m_distance,this.m_a1+c,a);let e=a.clone();e.x=.5*(e.x+r.x),e.y=.5*(e.y+r.y),e.type|=y,this.addPoint(e),this.addPoint(a)}else i.buildPoint(r,this.m_distance,this.m_a1+c,a),a.type|=y,this.addPoint(a);this.addPointEx(e,t)}else{let e=new S;if(i.buildPoint(a,this.m_distance,this.m_a1+c,e),this.addPoint(e),this.m_joins===1||this.m_joins===2){e.x=.5*(e.x+a.x),e.y=.5*(e.y+a.y),this.addPoint(e),i.buildPoint(a,this.m_distance,this.m_a2-c,e);let t=e.clone();t.x=.5*(t.x+a.x),t.y=.5*(t.y+a.y),t.type|=y,this.addPoint(t),this.addPoint(e)}else i.buildPoint(a,this.m_distance,this.m_a2-c,e),e.type|=y,this.addPoint(e)}}buildOffset(){let t=new S,n=this.m_srcPtCount;this.m_offsetPtCount=0;let r=.5*this.m_tolerance,a=0,s=0;for(let l=0;l<n;l++){let u=this.m_srcPts[l],d=l===0?this.m_srcPts[n-1]:this.m_srcPts[l-1],f=l===n-1?this.m_srcPts[0]:this.m_srcPts[l+1],p,m,h=0;{let e=d.x-u.x,t=d.y-u.y,n=f.x-u.x,r=f.y-u.y;p=Math.atan2(t,e),m=Math.atan2(r,n),this.m_a1=p,this.m_a2=m,l===0&&(a=p,s=m),h=o.orientationRobust(u.asPoint2D(),d.asPoint2D(),f.asPoint2D())}let g=m;if(m<p&&(m+=e),!(Math.abs(Math.abs(p-m)-Math.PI)<1e-8))if(h*this.m_distance>0)if(this.m_joins===1||this.m_joins===2){i.buildPoint(u,this.m_distance,p+c,t),this.addPoint(t);let e=.001;t.x=u.x+(t.x-u.x)*e,t.y=u.y+(t.y-u.y)*e,this.addPoint(t),i.buildPoint(u,this.m_distance,m-c,t);let n=t.clone();n.x=u.x+(n.x-u.x)*e,n.y=u.y+(n.y-u.y)*e,n.type|=y,this.addPoint(n),this.addPoint(t)}else{let e=.5*(m-p),n=e===0?this.m_distance:this.m_distance/Math.abs(Math.sin(e));i.buildPoint(u,n,.5*(p+m),t),this.addPointEx(t,l)}else{if(u.type&b){let e=1-r/Math.abs(this.m_distance),n=1,a=this.m_distance<0?-Math.PI:Math.PI;if(e>-1&&e<1){let t=2*Math.acos(e);t<v&&(t=v),n=Math.trunc(Math.PI/t+1.5),n>1&&(a/=n)}n<=1&&(n=2,a/=2);let o=p+c;i.buildPoint(u,this.m_distance,o,t),l===0&&(t.type|=x),this.addPointEx(t,l);let s=this.m_distance/Math.cos(a/2);for(o+=a/2,i.buildPoint(u,s,o,t),t.type|=x,this.addPoint(t);--n>0;)o+=a,i.buildPoint(u,s,o,t),t.type|=x,this.addPoint(t);i.buildPoint(u,this.m_distance,m-c,t),t.type|=x,this.addPoint(t);continue}if(this.m_joins!==1){if(this.m_joins===0){let e=1-r/Math.abs(this.m_distance),n=1,a=m-c-(p+c);if(e>-1&&e<1){let t=2*Math.acos(e);t<v&&(t=v),n=Math.trunc(Math.abs(a)/t+1.5),n>1&&(a/=n)}let o=this.m_distance/Math.cos(.5*a),s=p+c+.5*a;for(i.buildPoint(u,o,s,t),this.addPointEx(t,l);--n>0;)s+=a,i.buildPoint(u,o,s,t),this.addPoint(t);continue}if(this.m_joins===2){let e=d.x-u.x,n=d.y-u.y,r=f.x-u.x,a=f.y-u.y,s=(e*r+n*a)/Math.sqrt(e*e+n*n)/Math.sqrt(r*r+a*a);if(s=Math.max(s,-1),s>.99999999){i.buildPoint(u,_*this.m_distance,m-.25*Math.PI,t),this.addPointEx(t,l),i.buildPoint(u,_*this.m_distance,m+.25*Math.PI,t),this.addPoint(t);continue}let c=Math.abs(this.m_distance/Math.sin(.5*Math.acos(s))),h=Math.abs(this.m_miterLimit*this.m_distance);if(c>h){let e=.5*(m-p),n=this.m_distance/Math.abs(Math.sin(e));i.buildPoint(u,n,.5*(p+m),t);let r=o.construct(t.x,t.y),a=o.construct(u.x,u.y),s=new o;s.setSub(r,a);let d=new o;d.setScaleAdd(h/s.length(),s,a);let f=Math.sqrt(c*c-this.m_distance*this.m_distance),g=(c-h)*Math.abs(this.m_distance)/f;this.m_distance>0?s.rightPerpendicularThis():s.leftPerpendicularThis(),s.scale(g/s.length());let _=new o;_.setAdd(d,s);let v=new o;v.setSub(d,s),t.x=_.x,t.y=_.y,this.addPointEx(t,l),t.x=v.x,t.y=v.y,this.addPoint(t);continue}let g=.5*(m-p),v=this.m_distance/Math.abs(Math.sin(g));i.buildPoint(u,v,.5*(p+m),t),this.addPointEx(t,l);continue}{let n;if(m=g,this.m_distance>0?(m>p&&(m-=e),n=p-m<c):(m<p&&(m+=e),n=m-p<c),n){let e=this.m_distance*_,n;n=e<0?p+.25*Math.PI:p+3*Math.PI*.25,i.buildPoint(u,e,n,t),this.addPointEx(t,l),n=e<0?m-.25*Math.PI:m-3*Math.PI*.25,i.buildPoint(u,e,n,t),this.addPoint(t)}else{let n=.5*(m-p),r=this.m_distance/Math.abs(Math.sin(n));m<p&&(m+=e),i.buildPoint(u,r,(p+m)/2,t),this.addPointEx(t,l)}}}else i.buildPoint(u,this.m_distance,p+c,t),this.addPointEx(t,l),i.buildPoint(u,this.m_distance,m-c,t),this.addPoint(t)}}return this.m_a1=a,this.m_a2=s,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let e=!1;for(let e=0;e<this.m_offsetPtCount;e++){let t=this.m_offsetPts[e];t.m_next=e+1,t.m_prev=e-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let t=0;for(let n=0;n<this.m_offsetPtCount;n++)if(this.m_offsetPts[t].type&y){let n=this.deleteClosedSeg(t);if(n===-1){e=!0;break}t=n}else t=this.m_offsetPts[t].m_next;return!e&&(this.compressOffsetArray(t),!0)}deleteClosedSeg(e){let t=this.m_offsetPtCount-1,n,r,i=e;for(let a=1;a<=t-2;a++){i=this.m_offsetPts[i].m_next,n=i,r=e;for(let e=1;e<=a;e++){if(r=this.m_offsetPts[r].m_prev,(this.m_offsetPts[r].type&y)===0&&(this.m_offsetPts[n].type&y)===0){let e=this.handleClosedIntersection(r,n);if(e!==-1)return e}n=this.m_offsetPts[n].m_prev}}return-1}handleClosedIntersection(e,t){let n=this.m_offsetPts[this.m_offsetPts[e].m_prev],r=this.m_offsetPts[e],i=this.m_offsetPts[this.m_offsetPts[t].m_prev],a=this.m_offsetPts[t];if(!this.sectGraphicRect(n,r,i,a))return-1;let o=C();if(((r.x-n.x)*(a.y-i.y)-(r.y-n.y)*(a.x-i.x))*this.m_distance<0&&this.findIntersection(n,r,i,a,o)&&!o.bAtExistingPt){let s=1e-8,c=Math.sqrt((r.x-n.x)*(r.x-n.x)+(r.y-n.y)*(r.y-n.y)),l=(r.x-n.x)/c,u=(r.y-n.y)/c,d=Math.sqrt((a.x-i.x)*(a.x-i.x)+(a.y-i.y)*(a.y-i.y)),f=(a.x-i.x)/d,p=(a.y-i.y)/d,m=!1,h=o.pt.clone();h.x+=(l+f)*s,h.y+=(u+p)*s;let g=i,_=o.pt,v=this.m_offsetPts[e].m_prev;for(;_.y>h.y!=g.y>h.y&&h.x<(g.x-_.x)*(h.y-_.y)/(g.y-_.y)+_.x&&(m=!m),g=_,v=this.m_offsetPts[v].m_next,v!==t;)_=this.m_offsetPts[v];if(m)return-1;let y=this.m_offsetPts[e].m_prev;return o.pt.type=r.type,o.pt.m_next=t,o.pt.m_prev=y,this.m_offsetPts[e]=o.pt,this.m_offsetPts[t].m_prev=e,t}return-1}sectGraphicRect(e,t,n,r){return Math.max(e.x,t.x)>=Math.min(n.x,r.x)&&Math.max(n.x,r.x)>=Math.min(e.x,t.x)&&Math.max(e.y,t.y)>=Math.min(n.y,r.y)&&Math.max(n.y,r.y)>=Math.min(e.y,t.y)}findIntersection(e,t,n,r,i){let a,o,s,c;return i.bAtExistingPt=!1,a=(t.y-e.y)*(r.x-n.x)-(t.x-e.x)*(r.y-n.y),o=(n.y-e.y)*(t.x-e.x)-(n.x-e.x)*(t.y-e.y),s=a===0?2:o/a,s>=0&&s<=1&&(c=s,a=(r.y-n.y)*(t.x-e.x)-(r.x-n.x)*(t.y-e.y),o=(e.y-n.y)*(r.x-n.x)-(e.x-n.x)*(r.y-n.y),s=a===0?2:o/a,s>=0&&s<=1)&&(i.pt.x=e.x+s*(t.x-e.x),i.pt.y=e.y+s*(t.y-e.y),this.m_bUseZ&&(i.pt.z=n.z+c*(r.z-n.z)),this.m_bUseM&&(i.pt.m=n.m+c*(r.m-n.m)),c!==0&&c!==1||s!==0&&s!==1||(i.bAtExistingPt=!0),!((c===0||c===1)&&s>0&&s<1||(s===0||s===1)&&c>0&&c<1))}compressOffsetArray(e){for(;this.m_offsetPts[e].m_prev<e;)e=this.m_offsetPts[e].m_prev;let t=0,n=e;do{let e=this.m_offsetPts[n].clone();this.m_offsetPts[t]=e,n=e.m_next,t++}while(n!==e);this.m_offsetPts[t]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=t+1}addPart(e,t){if(!(t<2))for(let n=0;n<t;n++){let t=this.m_offsetPts[e+n];if(n?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(t.x,t.y,t.z):this.m_resultPath.lineToCoords(t.x,t.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(t.x,t.y,t.z):this.m_resultPath.startPathCoords(t.x,t.y),this.m_bUseM){let e=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,e,0,t.m)}}}offsetMultiPath(e){let t=d(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),n=t.querySegmentIterator();n.resetToFirstPath();let r=-1;for(;n.nextPath();)r++,this.offsetPath(t,r,e)}offsetPath(e,t,n){let r=e.getPathStart(t),i=e.getPathEnd(t);if(this.m_resultPath=n,e.isClosedPath(t)){let t=e.getXY(r);for(;i>r&&e.getXY(i-1).equals(t);)i--;if(i-r>=2){this.m_srcPtCount=i-r,this.m_srcPts.length=this.m_srcPtCount;for(let t=r;t<i;t++)this.progress(),this.m_srcPts[t-r]=S.construct(e.getXY(t),this.m_bUseZ?e.getAttributeAsDbl(1,t,0):0,this.m_bUseM?e.getAttributeAsDbl(2,t,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{let t=e.getXY(r);for(;r<i-1&&e.getXY(r+1).equals(t);)r++;let n=e.getXY(i-1);for(;r<i-1&&e.getXY(i-2).equals(n);)i--;if(i-r>=2){this.m_srcPtCount=2*(i-r)-2,this.m_srcPts.length=this.m_srcPtCount;let n=S.construct(t,this.m_bUseZ?e.getAttributeAsDbl(1,r,0):0,this.m_bUseM?e.getAttributeAsDbl(2,r,0):0);n.type|=b+x,this.m_srcPts[0]=n;let a=1,o=this.m_srcPtCount-1;for(let t=r+1;t<i-1;t++,a++,o--)this.progress(),n=S.construct(e.getXY(t),this.m_bUseZ?e.getAttributeAsDbl(1,t,0):0,this.m_bUseM?e.getAttributeAsDbl(2,t,0):0),this.m_srcPts[a]=n.clone(),n.type|=x,this.m_srcPts[o]=n.clone();if(n=S.construct(e.getXY(i-1),this.m_bUseZ?e.getAttributeAsDbl(1,i-1,0):0,this.m_bUseM?e.getAttributeAsDbl(2,i-1,0):0),n.type|=b,this.m_srcPts[a]=n.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let e=-1,t=-1,n=(this.m_offsetPts[this.m_offsetPtCount-1].type&x)!==0;n||(e=0);for(let r=1;r<this.m_offsetPtCount;r++){this.progress();let i=(this.m_offsetPts[r].type&x)!==0;i?n||(t=r-1,t-e+1>1&&this.addPart(e,t-e+1)):n&&(e=r-1),n=i}n||(t=this.m_offsetPtCount-1,t-e+1>1&&this.addPart(e,t-e+1))}else{let e=this.m_offsetPtCount-1;e-0>=1&&this.addPart(0,e-0+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(e,t,n,i){let o=t.x-e.x,s=t.y-e.y,c=i.x-n.x,l=i.y-n.y,u=r(o,s,c,l);return a(u)}},T=class{getOperatorType(){return 10108}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t,n,r,i,a,o){return new E(e,t,n,r,i,a,o)}execute(e,t,n,r,i,a,o){return new E(null,t,n,r,i,a,o).offset(e)}},E=class extends m{constructor(e,t,n,r,i,a,o){super(),this.m_progressTracker=o,this.m_index=-1,this.m_inputGeoms=e,this.m_spatialReference=t,this.m_distance=n,this.m_joins=r,this.m_miterLimit=i,this.m_flattenError=a}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let e;for(;e=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(e);return null}getGeometryID(){return this.m_index}offset(e){let t;return s(e),t=this.m_flattenError<=0?u(this.m_spatialReference,e,!0).total():this.m_flattenError,g(e,this.m_distance,this.m_joins,this.m_miterLimit,t,this.m_progressTracker)}},D=new T;function O(e,t,n,r,i,a){return D.execute(e,t,n,r,i,a,null)}function k(e,t,n,r,i,a){let o=D.executeMany(new h(e),t,n,r,i,a,null);return Array.from(o)}export{O as n,k as t};