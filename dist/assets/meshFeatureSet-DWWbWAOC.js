import{CE as e,Lx as t,Od as n,Qn as r,ha as i,vE as a,vx as o}from"./index-BN8X5Ryz.js";import"./quatf64-D37SEdPg.js";import"./quat-C8PgLo31.js";import"./axisAngleDegrees-DzAS4tF-.js";import"./meshCloneUtils-BXMzy817.js";import"./MeshMaterialMetallicRoughness-Bdr2gXmV.js";import"./meshProperties-CbjLwdbT.js";import"./MeshComponent-BFk18JiH.js";import{t as s}from"./Mesh-CfQb5rZ2.js";import"./MeshLocalVertexSpace-vomIk0sx.js";import"./MeshTransform-BaPjlQwH.js";import"./MeshVertexAttributes-CBsb_nVo.js";import"./meshVertexSpaceUtils-s2jLb8qI.js";import"./earcut-CEMcWA4Z.js";import"./Indices-tJiSUK6w.js";import"./plane-Da5EsY0J.js";import"./vectorStacks-Cuo89CNO.js";import"./triangulationUtils-DNxIB1ux.js";import"./deduplicate-D-tDe87s.js";import"./projectPointToVector-BkRdoTqD.js";import"./computeTranslationToOriginAndRotation-0WDVmpJG.js";import"./BufferView-BW77W5ev.js";import"./Util-BQgFCZvD.js";import"./vec3-B5yu4INg.js";import"./vec4-BLZ_ZPtE.js";import"./vertexSpaceConversion-Dz87RqR7.js";import"./spatialReferenceEllipsoidUtils-qw9wv8RL.js";import{a as c,r as l}from"./External-C55iwtd6.js";import{n as u,t as d}from"./meshFeatureAttributes-DdbGwu_X.js";var f=()=>e.getLogger(`esri.rest.support.meshFeatureSet`);function p(e,r,a){let o=a.features;a.features=[],delete a.geometryType;let s=i.fromJSON(a);if(s.geometryType=`mesh`,!a.assetMaps)return s;let c=g(r,a.assetMaps),l=e.sourceSpatialReference??t.WGS84,u=a.globalIdFieldName,{outFields:d}=e,f=d!=null&&d.length>0?m(d.includes(`*`)?null:new Set(d)):()=>({});for(let e of o){let t=h(e,u,l,r,c);s.features.push(new n({geometry:t,attributes:f(e)}))}return s}function m(e){return({attributes:t})=>{if(!t)return{};if(!e)return t;for(let n in t)e.has(n)||delete t[n];return t}}function h(e,t,n,r,i){let a=e.attributes[t],c=i.get(a);if(c==null||!e.geometry)return null;let l=u(e.attributes,n,r.transformFieldRoles),f=o.fromJSON(e.geometry);f.spatialReference=n;let p=d(e.attributes,r.transformFieldRoles),m=n.isGeographic?`local`:`georeferenced`,h=_(c);return h?s.createWithExternalSource(l,h,{extent:f,transform:p,vertexSpace:m,unitConversionDisabled:!0}):s.createIncomplete(l,{extent:f,transform:p,vertexSpace:m})}function g(e,t){let n=new Map;for(let i of t){let t=i.parentGlobalId;if(t==null)continue;let o=i.assetName,s=i.assetType,c=i.assetHash,l=i.assetURL,u=i.conversionStatus,d=i.seqNo,p=r(s,e.supportedFormats);if(!p){f().error(`mesh-feature-set:unknown-format`,`Service returned an asset of type ${s}, but it does not list it as a supported type`);continue}let m=a(n,t,()=>({files:new Map}));a(m.files,o,()=>({name:o,type:s,mimeType:p,status:v(u),parts:[]})).parts[d]={hash:c,url:l}}return n}function _(e){let t=Array.from(e.files.values()),n=[];for(let e of t){if(e.status!==2)return null;let t=[];for(let n of e.parts){if(!n)return null;t.push(new c(n.url,n.hash))}n.push(new l(e.name,e.mimeType,t))}return{type:`service`,assets:n}}function v(e){switch(e){case`COMPLETED`:case`SUBMITTED`:return 2;case`INPROGRESS`:return 1;default:return 0}}export{g as assetMapFromAssetMapsJSON,h as extractMesh,p as meshFeatureSetFromJSON};