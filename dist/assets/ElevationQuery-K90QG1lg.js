import{$w as e,Ag as t,BT as n,Bx as r,DT as i,Fg as a,Gb as o,Jw as s,Lb as c,OT as l,QE as u,Rb as d,Xb as f,bg as p,cg as m,gD as h,mT as g,px as _,sv as v,tx as y,uE as b,wx as x,xx as S}from"./index-CzMixifc.js";import{t as C}from"./GeometryDescriptor-BbSGeosl.js";var w=class{constructor(e,t){this.layer=e,this.parameters=t}},ee=class extends w{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type=`geometry`}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(e=>e.tile=null);else{let{tileInfo:t,tilemapCache:n}=this.layer,r=D(t,n)[e].level;this.geometry.coordinates.forEach(e=>e.tile=t.tileAt(r,e.x,e.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(let e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(let t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(let t of this.geometry.coordinates){let n=t.tile?.id;t.tile=n?e[n]:null}}getTilesToFetch(){return u(this.geometry.coordinates.filter(({tile:e,elevationTile:t})=>e?.id&&!t),(e,t)=>e.tile?.id===t.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(let t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>t.tile=null)}},T=class extends w{constructor(e,t,n,r){super(e,n),this.maskExtents=r,this.type=`extent`,this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.clone().intersection(e.fullExtent)}selectTilesAtLOD(e,t){let n=this._maximumLodForRequests(t),r=Math.min(n,e);r<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(r)}_maximumLodForRequests(e){let{tileInfo:t,tilemapCache:n}=this.layer,r=D(t,n);if(!e)return r.length-1;let i=this.extent;if(i==null)return-1;for(let n=r.length-1;n>=0;n--){let a=r[n],o=a.resolution*t.size[0],s=a.resolution*t.size[1];if(Math.ceil(i.width/o)*Math.ceil(i.height/s)<=e)return n}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(let t of this._candidateTiles){let n=t.id&&e[t.id];n&&(this._fetchedCandidates.add(t),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=O(this._candidateTiles.map(t=>e[t.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){let n=this._candidateTiles;this._candidateTiles=[],n.forEach(n=>{if(this._fetchedCandidates.has(n))return void t?.(n);let r=!1;e(n,()=>r=!0),r?t?.(n):this._candidateTiles.push(n)}),this._candidateTiles=O(this._candidateTiles,t)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;let t=this.extent;if(t==null)return;let{tileInfo:n,tilemapCache:r}=this.layer,i=D(n,r)[e],a=n.tileAt(i.level,t.xmin,t.ymin),o=a.extent,s=i.resolution*n.size[0],c=i.resolution*n.size[1],l=Math.ceil((t.xmax-o[0])/s),u=Math.ceil((t.ymax-o[1])/c);for(let e=0;e<u;e++)for(let t=0;t<l;t++){let r=new p(a.level,a.row-e,a.col+t);n.updateTileInfo(r),this._tileIsMasked(r)||this._candidateTiles.push(r)}}_tileIsMasked(e){return this.maskExtents?.some(t=>c(t,e.extent))??!1}};function E(e){return e?.tileInfo!=null}function D(e,t){let n=e.lods;if(E(t)){let{effectiveMinLOD:e,effectiveMaxLOD:r}=t;return n.filter(t=>t.level>=e&&t.level<=r)}return n}function O(e,t){let n={},r=[];for(let i of e){let e=i.id;e&&!n[e]?(n[e]=i,r.push(i)):t?.(i)}let i=r.sort((e,t)=>e.level-t.level);return i.filter((e,n)=>{for(let r=0;r<n;r++){let n=i[r].extent;if(n&&c(n,e.extent))return t?.(e),!1}return!0})}var k=class{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}},A=class{constructor(e,t=null){if(this.key=e,t!=null){let n=e.extent;this._samplerData=new k(t,n)}}get zmin(){return this._samplerData==null?0:this._samplerData.data.minValue}get zmax(){return this._samplerData==null?0:this._samplerData.data.maxValue}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,t){if(this._samplerData==null)return;let{safeWidth:n,data:r,dx:i,dy:a,y1:o,x0:s}=this._samplerData,{width:c,values:l,noDataValue:u}=r,d=j(a*(o-t),0,n),f=j(i*(e-s),0,n),p=Math.floor(d),m=Math.floor(f),h=p*c+m,g=h+c,_=l[h],v=l[g],y=l[h+1],b=l[g+1];if(_!==u&&v!==u&&y!==u&&b!==u){let e=f-m,t=_+(y-_)*e;return t+(v+(b-v)*e-t)*(d-p)}}};function j(e,t,n){return e<t?t:e>n?n:e}var M=class extends v{queryElevation(e){let t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case`point`:return N(e,t,this);case`polyline`:return P(e,t,this);case`multipoint`:return F(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;let n=e.spatialReference;if(n.equals(t))return e;let r=S(e,t);return r||b.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),r}};function N(e,t,n){return e.hasZ=!0,e.z=n.elevationAt(t.x,t.y),e}function P(e,t,n){I.spatialReference=t.spatialReference;let r=e.hasM&&!e.hasZ;for(let i=0;i<e.paths.length;i++){let a=e.paths[i],o=t.paths[i];for(let e=0;e<a.length;e++){let t=a[e],i=o[e];I.x=i[0],I.y=i[1],r&&(t[3]=t[2]),t[2]=n.elevationAt(I.x,I.y)}}return e.hasZ=!0,e}function F(e,t,n){I.spatialReference=t.spatialReference;let r=e.hasM&&!e.hasZ;for(let i=0;i<e.points.length;i++){let a=e.points[i],o=t.points[i];I.x=o[0],I.y=o[1],r&&(a[3]=a[2]),a[2]=n.elevationAt(I.x,I.y)}return e.hasZ=!0,e}M=h([l(`esri.layers.support.ElevationSampler`)],M);var I=new _,L=class extends M{get spatialReference(){return this.extent.spatialReference}constructor(e){let t=e.noDataValue,n=`tiles`in e?e.tiles.map(n=>new R({tile:n,tileInfo:e.tileInfo,noDataValue:t})):e.samplers;super({noDataValue:t,samplers:n});let r=n[0];if(r){this.extent=r.extent.clone();let{min:e,max:t}=r.demResolution;this.demResolution={min:e,max:t};for(let e=1;e<n.length;e++){let t=n[e];this.extent.union(t.extent),this.demResolution.min=Math.min(this.demResolution.min,t.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,t.demResolution.max)}}else{let t=`tileInfo`in e?e.tileInfo:null;this.extent=f(y(),t?.spatialReference??x.WGS84),this.demResolution={min:0,max:0}}}elevationAt(e,t){let n;for(let r of this.samplers)if(r.containsAt(e,t)&&(n=r.elevationAt(e,t),n!==r.noDataValue))return n;return n??(b.getLogger(this).warn(`#elevationAt()`,`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}};h([i({constructOnly:!0})],L.prototype,`noDataValue`,void 0),h([i({constructOnly:!0})],L.prototype,`samplers`,void 0),L=h([l(`esri.layers.support.TileElevationSampler`)],L);var R=class extends M{get spatialReference(){return this.extent.spatialReference}constructor(e){super(e);let t=e.tile.key.extent;this.extent=f(t,e.tileInfo.spatialReference),this.extent.zmin=e.tile.zmin,this.extent.zmax=e.tile.zmax;let n=r(e.tileInfo.spatialReference),i=e.tileInfo.lodAt(e.tile.key.level).resolution*n;this.demResolution={min:i,max:i}}contains(e){let t=this.projectIfRequired(e,this.spatialReference);return t!=null&&this.containsAt(t.x,t.y)}containsAt(e,t){return d(this.tile.key.extent,e,t)}elevationAt(e,t){return this.containsAt(e,t)?this.tile.sample(e,t)??this.noDataValue:this.noDataValue}};h([i({constructOnly:!0})],R.prototype,`tile`,void 0),h([i({constructOnly:!0})],R.prototype,`noDataValue`,void 0),h([i({constructOnly:!0})],R.prototype,`tileInfo`,void 0),R=h([l(`esri.layers.support.TileElevationSampler.SingleTileElevationSampler`)],R);async function z(e,t,r){if(e=r?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice(),!e.length)throw new n($,`Elevation queries require at least one elevation layer to fetch tiles from`);let i=C.fromGeometry(t),a={...Z,...r,returnSampleInfo:!0},o=e.pop(),s=await B(o,i,a),c=await W(e,s,a);return c.geometry=c.geometry.export(),r?.returnSampleInfo||delete c.sampleInfo,c}async function B(e,t,r){if(!e)throw new n($,`Elevation queries require an elevation layer to fetch tiles from`);if(!t||!(t instanceof C)&&t.type!==`point`&&t.type!==`multipoint`&&t.type!==`polyline`)throw new n(`elevation-query:invalid-geometry`,`Only point, polyline and multipoint geometries can be used to query elevation`);let i={...Z,...r},a=new ee(e,t.spatialReference,i),o=i.signal;return await e.load({signal:o}),await te(a,t,o),await G(a,o),await Q(a,o),se(a),ce(a,o)}async function V(e,t,r){if(e=Array.isArray(e)?e:[e],(e=r?.ignoreInvisibleLayers?e.filter(e=>e.visible):e.slice()).length===0)throw new n($,`Elevation queries require at least one elevation layer to fetch tiles from`);if(!t||t.type!==`extent`)throw new n(`elevation-query:invalid-extent`,`Invalid or undefined extent`);let i={...Z,...r,returnSampleInfo:!0},a=H(e[e.length-1],t,i);return e.length===1?a:U(e,t,await a,i)}async function H(e,n,r,i){let o=r.signal;await e.load({signal:o});let s=n.spatialReference,c=e.tileInfo.spatialReference;s.equals(c)||(await t([{source:s,dest:c}],{signal:o}),n=a(n,c));let l=new T(e,n,r,i);await G(l,o),await Q(l,o);let u=l.elevationTiles,d=l.layer.tileInfo,f=l.parameters.noDataValue;return new L({noDataValue:f,tiles:u,tileInfo:d})}async function U(e,t,n,r){if(e.pop(),!e.length)return n;let i=n.samplers.filter(e=>!e.tile.hasNoDataValues).map(e=>o(e.extent)),a=await H(e[e.length-1],t,r,i);if(a.samplers.length===0)return n;let s=n.samplers.concat(a.samplers),c=r.noDataValue;return U(e,t,new L({samplers:s,noDataValue:c}),r)}async function W(e,t,n){let r=t.geometry.coordinates,i=t.sampleInfo;g(i);let a=[],o=[];for(let t=0;t<r.length;t++)i[t].demResolution<0&&e.length&&(a.push(r[t]),o.push(t));let s=e.pop();if(s==null||a.length===0)return t;let c=t.geometry.clone(a),l=await B(s,c,n),u=l.sampleInfo;if(!u)throw Error(`no sampleInfo`);return o.forEach((e,t)=>{r[e].z=l.geometry.coordinates[t].z,i[e].demResolution=u[t].demResolution,i[e].source=u[t].source}),W(e,t,n)}async function G(e,t){e.type===`geometry`&&ne(e);let r=e.parameters.demResolution;if(typeof r==`number`)ie(e,r);else if(r===`finest-contiguous`)await K(e,t);else{if(r!==`auto`)throw new n(`elevation-query:invalid-dem-resolution`,`Invalid dem resolution value '${r}', expected a number, "finest-contiguous" or "auto"`);await J(e,t)}}async function K(e,t){let{tileInfo:n,tilemapCache:r}=e.layer,i=X(n,r,e.parameters.minDemResolution);await q(e,i,t)}async function q(t,r,i){let a=t.layer;if(t.selectTilesAtLOD(r),r<0)return;let o=a.tilemapCache,c=t.getTilesToFetch();try{if(o&&!E(o))await e(Promise.all(c.map(e=>o.fetchAvailability(e.level,e.row,e.col,{signal:i}))),i);else if(await Q(t,i),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new n(`elevation-query:has-unavailable-tiles`,`Some elevation tiles are unavailable`)}catch(e){s(e),await q(t,r-1,i)}}async function J(t,n){ae(t),oe(t);let r=t.layer.tilemapCache;if(!r||E(r))return Y(t,n);let i=t.getTilesToFetch(),a={},o=i.map(async e=>{let t=new p(0,0,0),i=await m(r.fetchAvailabilityUpsample(e.level,e.row,e.col,t,{signal:n}));!1===i.ok?s(i.error):e.id!=null&&(a[e.id]=t)});await e(Promise.all(o),n),t.remapTiles(a)}async function Y(e,t){let n=e.layer.tileInfo;await Q(e,t);let r=!1;e.forEachTileToFetch((e,t)=>{n.upsampleTile(e)?r=!0:t()}),r&&await Y(e,t)}function X(e,t,n=0){let i=D(e,t),a=i.length-1;if(n>0){let t=n/r(e.spatialReference),o=i.findIndex(e=>e.resolution<t);o===0?a=0:o>0&&(a=o-1)}return a}var Z={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:`auto`,minDemResolution:0,signal:null};async function te(e,r,i){let o,s=e.layer.tileInfo.spatialReference;if(r instanceof C?o=await r.project(s,i):(await t([{source:r.spatialReference,dest:s}],{signal:i}),o=a(r,s)),!o)throw new n(`elevation-query:spatial-reference-mismatch`,`Cannot query elevation in '${r.spatialReference.wkid}' on an elevation service in '${s.wkid}'`);e.geometry=C.fromGeometry(o)}function ne(e){if(e.layer.fullExtent==null)return;let t=new A(new p(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;let n=e.layer.fullExtent;e.geometry.coordinates.forEach(e=>{let r=e.x,i=e.y;(r<n.xmin||r>n.xmax||i<n.ymin||i>n.ymax)&&(e.elevationTile=t)})}function re(e,t){let{tileInfo:n,tilemapCache:i}=e.layer,a=t/r(n.spatialReference),o=D(n,i),s=o[0],c=0;for(let e=1;e<o.length;e++){let t=o[e];Math.abs(t.resolution-a)<Math.abs(s.resolution-a)&&(s=t,c=e)}return c}function ie(e,t){let n=re(e,t);e.selectTilesAtLOD(n)}function ae(e){let{tileInfo:t,tilemapCache:n}=e.layer,r=X(t,n,e.parameters.minDemResolution);e.selectTilesAtLOD(r,e.parameters.maximumAutoTileRequests)}async function Q(t,n){let r=t.getTilesToFetch(),i={},a=t.parameters.cache,o=t.parameters.noDataValue,s={noDataValue:o,signal:n},c=r.map(async e=>{if(e.id==null)return;let n=`${t.layer.uid}:${e.id}:${o}`,r=a?.get(n),c=r??await t.layer.fetchTile(e.level,e.row,e.col,s);a?.put(n,c),i[e.id]=new A(e,c)});await e(Promise.allSettled(c),n),t.populateElevationTiles(i)}function oe(e){let t=e.layer.tileInfo,n=0,r={},i=e=>{e.id!=null&&(e.id in r?r[e.id]++:(r[e.id]=1,n++))},a=e=>{if(e.id==null)return;let t=r[e.id];t===1?(delete r[e.id],n--):r[e.id]=t-1};e.forEachTileToFetch(i,a);let o=!0;for(;o&&(o=!1,e.forEachTileToFetch(r=>{n<=e.parameters.maximumAutoTileRequests||(a(r),t.upsampleTile(r)&&(o=!0),i(r))},a),o););}function se(e){e.geometry.coordinates.forEach(t=>{let n=t.elevationTile,r=e.parameters.noDataValue;if(n){let e=n.sample(t.x,t.y);e==null?t.elevationTile=null:r=e}t.z=r})}async function ce(e,t){let n=await e.geometry.project(e.outSpatialReference,t);g(n);let r={geometry:n.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(r.sampleInfo=le(e)),e.geometry.coordinates.forEach(e=>{e.tile=null,e.elevationTile=null}),r}function le(e){let t=e.layer.tileInfo,n=r(t.spatialReference);return e.geometry.coordinates.map(r=>{let i=-1;return r.elevationTile&&r.elevationTile!==e.outsideExtentTile&&(i=t.lodAt(r.elevationTile.key.level).resolution*n),{demResolution:i,source:i===-1?void 0:e.layer}})}var $=`elevation-query:invalid-layer`;export{$ as InvalidLayerError,V as createSampler,Z as defaultOptions,X as getFinestLodIndex,B as query,z as queryAll};