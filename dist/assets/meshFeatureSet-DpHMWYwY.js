import{Qn as e,aE as t,ax as n,ha as r,uE as i,vd as a,wx as o}from"./index-CZ4oMP1N.js";import"./quatf64-BJJPhW0N.js";import"./quat-BszBv_-H.js";import"./axisAngleDegrees-B_kvpSNV.js";import"./meshCloneUtils-CCqUCHap.js";import"./MeshMaterialMetallicRoughness-Q-7oSOPc.js";import"./meshProperties-DH9aY28x.js";import"./MeshComponent-CbjVLVfh.js";import{t as s}from"./Mesh-DYiHRSOH.js";import"./MeshLocalVertexSpace-OEvelzSD.js";import"./MeshTransform-mXzx59gA.js";import"./MeshVertexAttributes-DnUp4IwU.js";import"./meshVertexSpaceUtils-CsTvVRUI.js";import"./earcut-BF1-mB58.js";import"./Indices-BME9aaDP.js";import"./plane-Bg1a5O73.js";import"./vectorStacks-FfDNcZoS.js";import"./triangulationUtils-BlqOiLV7.js";import"./deduplicate-DAw_n_cX.js";import"./projectPointToVector-HYpbaZqA.js";import"./computeTranslationToOriginAndRotation-Cm78hfIp.js";import"./BufferView-D7rgY_ku.js";import"./Util-BF0TzZHY.js";import"./vec3-DSOiDp9-.js";import"./vec4-utmnCg3f.js";import"./vertexSpaceConversion-Ca0tjp55.js";import"./spatialReferenceEllipsoidUtils-B0E4spY0.js";import{a as c,r as l}from"./External-2kZvgPV0.js";import{n as u,t as d}from"./meshFeatureAttributes-YR8sMkr_.js";var f=()=>i.getLogger(`esri.rest.support.meshFeatureSet`);function p(e,t,n){let i=n.features;n.features=[],delete n.geometryType;let s=r.fromJSON(n);if(s.geometryType=`mesh`,!n.assetMaps)return s;let c=g(t,n.assetMaps),l=e.sourceSpatialReference??o.WGS84,u=n.globalIdFieldName,{outFields:d}=e,f=d!=null&&d.length>0?m(d.includes(`*`)?null:new Set(d)):()=>({});for(let e of i){let n=h(e,u,l,t,c);s.features.push(new a({geometry:n,attributes:f(e)}))}return s}function m(e){return({attributes:t})=>{if(!t)return{};if(!e)return t;for(let n in t)e.has(n)||delete t[n];return t}}function h(e,t,r,i,a){let o=e.attributes[t],c=a.get(o);if(c==null||!e.geometry)return null;let l=u(e.attributes,r,i.transformFieldRoles),f=n.fromJSON(e.geometry);f.spatialReference=r;let p=d(e.attributes,i.transformFieldRoles),m=r.isGeographic?`local`:`georeferenced`,h=_(c);return h?s.createWithExternalSource(l,h,{extent:f,transform:p,vertexSpace:m,unitConversionDisabled:!0}):s.createIncomplete(l,{extent:f,transform:p,vertexSpace:m})}function g(n,r){let i=new Map;for(let a of r){let r=a.parentGlobalId;if(r==null)continue;let o=a.assetName,s=a.assetType,c=a.assetHash,l=a.assetURL,u=a.conversionStatus,d=a.seqNo,p=e(s,n.supportedFormats);if(!p){f().error(`mesh-feature-set:unknown-format`,`Service returned an asset of type ${s}, but it does not list it as a supported type`);continue}let m=t(i,r,()=>({files:new Map}));t(m.files,o,()=>({name:o,type:s,mimeType:p,status:v(u),parts:[]})).parts[d]={hash:c,url:l}}return i}function _(e){let t=Array.from(e.files.values()),n=[];for(let e of t){if(e.status!==2)return null;let t=[];for(let n of e.parts){if(!n)return null;t.push(new c(n.url,n.hash))}n.push(new l(e.name,e.mimeType,t))}return{type:`service`,assets:n}}function v(e){switch(e){case`COMPLETED`:case`SUBMITTED`:return 2;case`INPROGRESS`:return 1;default:return 0}}export{g as assetMapFromAssetMapsJSON,h as extractMesh,p as meshFeatureSetFromJSON};