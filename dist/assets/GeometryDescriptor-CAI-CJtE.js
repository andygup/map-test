import{Ag as e,Fg as t,Ov as n,Zv as r,px as i}from"./index-CZ4oMP1N.js";var a=class a{constructor(e){this.geometry=e,this.spatialReference=e.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){let t=new a(this.geometry);return t.spatialReference=this.spatialReference,t.coordinates=e??this.coordinates.map(e=>e.clone()),t._exporter=this._exporter,t}async project(n,i){if(this.spatialReference.equals(n))return this.clone();await e([{source:this.spatialReference,dest:n}],{signal:i});let a=new r({spatialReference:this.spatialReference,points:this.coordinates.map(e=>[e.x,e.y])}),o=t(a,n);if(!o)return null;let s=this.coordinates.map((e,t)=>{let n=e.clone(),r=o.points[t];return n.x=r[0],n.y=r[1],n}),c=this.clone(s);return c.spatialReference=n,c}static fromGeometry(e){let t=new a(e);if(e instanceof a)return t.coordinates=e.coordinates.map(e=>e.clone()),t._exporter=(t,n)=>{let r=e.clone(t);return r.spatialReference=n,r},t;switch(e.type){case`point`:{let n=e,{hasZ:r,hasM:a}=n;return t.coordinates=r&&a?[new o(n.x,n.y,n.z,n.m)]:r?[new o(n.x,n.y,n.z)]:a?[new o(n.x,n.y,null,n.m)]:[new o(n.x,n.y)],t._exporter=(t,n)=>e.hasM?new i(t[0].x,t[0].y,t[0].z,t[0].m,n):new i(t[0].x,t[0].y,t[0].z,n),t}case`multipoint`:{let n=e,{hasZ:i,hasM:a}=n;return t.coordinates=i&&a?n.points.map(e=>new o(e[0],e[1],e[2],e[3])):i?n.points.map(e=>new o(e[0],e[1],e[2])):a?n.points.map(e=>new o(e[0],e[1],null,e[2])):n.points.map(e=>new o(e[0],e[1])),t._exporter=(t,n)=>e.hasM?new r({points:t.map(e=>[e.x,e.y,e.z??0,e.m??0]),hasZ:!0,hasM:!0,spatialReference:n}):new r({points:t.map(e=>[e.x,e.y,e.z??0]),spatialReference:n}),t}case`polyline`:{let r=e,i=[],a=[],{hasZ:s,hasM:c}=e,l=0;for(let e of r.paths)if(a.push([l,l+e.length]),l+=e.length,s&&c)for(let t of e)i.push(new o(t[0],t[1],t[2],t[3]));else if(s)for(let t of e)i.push(new o(t[0],t[1],t[2]));else if(c)for(let t of e)i.push(new o(t[0],t[1],null,t[2]));else for(let t of e)i.push(new o(t[0],t[1]));return t.coordinates=i,t._exporter=(t,r)=>{let i=e.hasM?t.map(e=>[e.x,e.y,e.z??0,e.m??0]):t.map(e=>[e.x,e.y,e.z??0]),o=a.map(e=>i.slice(e[0],e[1]));return new n({paths:o,hasM:e.hasM,hasZ:!0,spatialReference:r})},t}}}},o=class e{constructor(e,t,n=null,r=null,i=null,a=null){this.x=e,this.y=t,this.z=n,this.m=r,this.tile=i,this.elevationTile=a}clone(){return new e(this.x,this.y,this.z,this.m)}};export{a as t};