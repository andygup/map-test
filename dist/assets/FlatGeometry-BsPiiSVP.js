import{$b as e,AD as t,AS as n,Av as r,Ay as i,Cy as a,DD as o,Ey as s,Iv as c,Iy as l,Lv as u,Lx as d,Mv as f,Ny as p,Oy as m,Py as h,_y as g,ab as _,ex as v,gy as y,jv as b,jy as x,yy as S}from"./index-BN8X5Ryz.js";import{i as C}from"./memoryEstimations-D_IbKyOk.js";import{t as w}from"./OptimizedGeometry-BQJ7w5VU.js";var T=class{constructor({type:e,spatialReference:t,vertexCount:n,vertexXY:r,vertexZ:i,vertexM:a,partCount:o,partOffsets:s,partFlags:c,segmentFlags:l,segmentIndices:u,segmentParams:d,segmentCountArc:f,segmentCountBezier:p}){this.segmentCountArc=0,this.segmentCountBezier=0,this.type=e,this.spatialReference=t,this.vertexCount=n,this.vertexXY=r,this.vertexZ=i,this.vertexM=a,this.partCount=o,this.partOffsets=s,this.partFlags=c,this.segmentFlags=l,this.segmentIndices=u,this.segmentParams=d,this.segmentCountArc=f,this.segmentCountBezier=p}get segmentParamCount(){return V(4)*this.segmentCountArc+V(2)*this.segmentCountBezier}get segmentCountLine(){let{segmentCount:e,segmentCountArc:t,segmentCountBezier:n}=this;return e&&e-t-n}get segmentCount(){return this.type===`polyline`?this.vertexCount-this.partCount:this.type===`polygon`?this.vertexCount:0}get hasZ(){return this.vertexZ!=null}get hasM(){return this.vertexM!=null}get hasCurves(){return this.segmentFlags!=null}get isMultipart(){return this.type===`polyline`||this.type===`polygon`}get usedMemory(){function e(e){return e?64+e.byteLength:0}return e(this.vertexXY)+e(this.vertexZ)+e(this.vertexM)+e(this.partOffsets)+e(this.partFlags)+e(this.segmentFlags)+e(this.segmentIndices)+e(this.segmentParams)}clone(){let{type:e,vertexCount:t,partCount:n,hasZ:r,hasM:i,hasCurves:a,segmentCountArc:o,segmentCountBezier:s}=this,c=U(e,t,n,r,i,a,o,s);c.spatialReference=this.spatialReference;let{vertexXY:l,vertexZ:u,vertexM:d}=this;c.vertexXY.set(l.subarray(0,2*t),0),c.vertexZ?.set(u.subarray(0,t),0),c.vertexM?.set(d.subarray(0,t),0);let{partOffsets:f,partFlags:p}=this;c.partFlags?.set(p.subarray(0,n+1)),c.partOffsets?.set(f.subarray(0,n+1));let{segmentFlags:m,segmentIndices:h,segmentParams:g,segmentParamCount:_}=this;return c.segmentFlags?.set(m.subarray(0,t),0),c.segmentIndices?.set(h.subarray(0,t),0),c.segmentParams?.set(g.subarray(0,_),0),c}equals(e){return this.equalsWithinTolerance(e,0)}equalsWithinTolerance(e,t){if(e==null)return!1;if(this===e)return!0;if(!n(this.spatialReference,e.spatialReference)||this.vertexCount!==e.vertexCount||this.partCount!==e.partCount||this.hasZ!==e.hasZ||this.hasM!==e.hasM||this.hasCurves!==e.hasCurves||this.segmentCountArc!==e.segmentCountArc||this.segmentCountBezier!==e.segmentCountBezier)return!1;let r=t===0?(e,t)=>e!==t||isNaN(e)!==isNaN(t):(e,n)=>Math.abs(e-n)>t||isNaN(e)!==isNaN(n);for(let t=0;t<this.vertexCount;++t)if(r(this.vertexXY[2*t],e.vertexXY[2*t])||r(this.vertexXY[2*t+1],e.vertexXY[2*t+1]))return!1;if(this.hasZ){for(let t=0;t<this.vertexCount;++t)if(r(this.vertexZ[t],e.vertexZ[t]))return!1}if(this.hasM){for(let t=0;t<this.vertexCount;++t)if(r(this.vertexM[t],e.vertexM[t]))return!1}for(let t=0;t<this.partCount;++t)if(this.partFlags[t]!==e.partFlags[t]||this.partOffsets[t]!==e.partOffsets[t])return!1;if(this.hasCurves){for(let t=0;t<this.vertexCount;++t)if(this.segmentFlags[t]!==e.segmentFlags[t]||this.segmentIndices[t]!==e.segmentIndices[t])return!1;for(let t=0;t<this.segmentParamCount;++t)if(r(this.segmentParams[t],e.segmentParams[t]))return!1}return!0}get parts(){return new E(this)}},E=class{constructor(e){this.geometry=e,this.value=new D(e)}get done(){return this.value.index>=this.geometry.partCount}next(){return++this.value.index,this}[Symbol.iterator](){return this}},D=class{constructor(e){this.geometry=e,this.index=-1,this._readVertex=B(e),this._segments=new O(this)}get segments(){return this._segments.reset(),this._segments}get startVertex(){return this._readVertex(this.geometry.partOffsets[this.index])}get vertexCount(){let e=this.geometry.partOffsets;return e[this.index+1]-e[this.index]}},O=class{constructor(e){this._part=e,this._partStart=0,this._partEnd=0,this._isPolygon=e.geometry.type===`polygon`,this.value=new k(e.geometry)}get done(){return this.value.indexOfStartVertex>this._partEnd}next(){++this.value.indexOfStartVertex;let e=this.value.indexOfStartVertex>=this._partEnd;return this.value.indexOfEndVertex=e&&this._isPolygon?this._partStart:this.value.indexOfStartVertex+1,this}[Symbol.iterator](){return this}reset(){let{index:e}=this._part,t=this._part.geometry.partOffsets;this._partStart=t[e],this._partEnd=t[e+1]-(this._isPolygon?1:2),this.value.indexOfStartVertex=this._partStart-1}},k=class{constructor(e){this.geometry=e,this.indexOfStartVertex=-1,this.indexOfEndVertex=-1,this._readVertex=B(e)}get xStart(){return this.geometry.vertexXY[2*this.indexOfStartVertex]}get yStart(){return this.geometry.vertexXY[2*this.indexOfStartVertex+1]}get zStart(){return this.geometry.vertexZ[this.indexOfStartVertex]}get mStart(){return this.geometry.vertexM[this.indexOfStartVertex]}get xEnd(){return this.geometry.vertexXY[2*this.indexOfEndVertex]}get yEnd(){return this.geometry.vertexXY[2*this.indexOfEndVertex+1]}get zEnd(){return this.geometry.vertexZ[this.indexOfEndVertex]}get mEnd(){return this.geometry.vertexM[this.indexOfEndVertex]}get start(){return this._readVertex(this.indexOfStartVertex)}get end(){return this._readVertex(this.indexOfEndVertex)}get curve(){let e=this.geometry.segmentFlags?.[this.indexOfStartVertex]??1;if(e===1)return this.end;let t=this.geometry.segmentParams,n=this.geometry.segmentIndices[this.indexOfStartVertex];if(e===2){let e=t[n++],r=t[n++],i=t[n++],a=t[n++];return{b:[this.end,[e,r],[i,a]]}}let r=t[n++],i=t[n++],a=t[n++],o=t[n++],s=t[n++],c=t[n++];n++,n++;let l=t[n++],u=t[n++];if(!(4&r)&&a===1)return{c:[this.end,[l,u]]};let d=2&r?0:1,f=1&r?0:1;return{a:[this.end,[s,c],d,f,o,i,a]}}};function A(e){let n,{hasCurves:r,vertexCount:i,vertexXY:a,vertexZ:s,vertexM:c}=e,l=z(e);if(r){let r={stack:[],error:void 0,hasError:!1};try{o(r,new R(e,[`vertexZ`,`vertexM`]),!1);let t=v();for(let n of e.parts){let e=n.startVertex;for(let{curve:r}of n.segments)y(t,e,r),e=m(r)}let[i,a,s,c]=t;n={xmin:i,ymin:a,xmax:s,ymax:c,spatialReference:l}}catch(e){r.error=e,r.hasError=!0}finally{t(r)}}else{let e,t,r,o;e=t=1/0,r=o=-1/0;for(let n=0;n<i;++n){let i=a[2*n],s=a[2*n+1];e=Math.min(e,i),r=Math.max(r,i),t=Math.min(t,s),o=Math.max(o,s)}n={xmin:e,ymin:t,xmax:r,ymax:o,spatialReference:l}}if(s){let e=1/0,t=-1/0;for(let n of s)e=Math.min(e,n),t=Math.max(t,n);n.zmin=e,n.zmax=t}if(c){let e=1/0,t=-1/0;for(let n of c)e=Math.min(e,n),t=Math.max(t,n);n.mmin=e,n.mmax=t}return n}function j(n,r){let i={stack:[],error:void 0,hasError:!1};try{return r??=v(),o(i,new R(n,[`vertexZ`,`vertexM`,`spatialReference`]),!1),e(r,A(n)),r}catch(e){i.error=e,i.hasError=!0}finally{t(i)}}function M(e){let t,n,o;if(u(e)){o=`point`;let{x:r,y:i,z:a,m:s}=e,c=[r,i];a!=null&&c.push(a),s!=null&&c.push(s),n=[[c]],t=1}else b(e)?(o=`multipoint`,n=[e.points],t=e.points.length):r(e)?(o=`polyline`,n=e.curvePaths??e.paths,t=n.reduce((e,t)=>e+t.length,0)):(o=`polygon`,n=e.curveRings??e.rings,t=n.reduce((e,t)=>e+t.length-H(t),0));let d=U(o,t,o.includes(`point`)?0:n.length,f(e),c(e),i(e));function v(e){d.vertexXY[2*C]=e[0],d.vertexXY[2*C+1]=e[1],d.hasZ&&(d.vertexZ[C]=e[2]),d.hasM&&(d.vertexM[C]=e[y]),++C}d.spatialReference=e.spatialReference??void 0;let y=d.hasZ?3:2,C=0;if(!d.isMultipart){if(!d.hasZ&&!d.hasM){for(let[e,t]of n[0])d.vertexXY[2*C]=e,d.vertexXY[2*C+1]=t,++C;return d}for(let e of n[0])v(e);return d}let w=d.type===`polygon`,T=0;if(!d.hasCurves){for(let e of n){d.partOffsets[T++]=C;let t=e.length;if(w&&(t-=H(e)),d.hasZ||d.hasM)for(let n=0;n<t;++n)v(e[n]);else for(let n=0;n<t;++n){let[t,r]=e[n];d.vertexXY[2*C]=t,d.vertexXY[2*C+1]=r,++C}}return d.partOffsets[T]=C,d}function E(e){let t=C-1;d.segmentFlags[t]=e;let n=V(e);d.segmentIndices[t]=n===0?G:D,e===4?++d.segmentCountArc:e===2&&++d.segmentCountBezier;let r=D+n;if(r<=(d.segmentParams?.length??0))return;let i=r*W;i=20*Math.ceil(i/20);let a=d.segmentParams;if(d.segmentParams=new Float64Array(i),a!=null)for(let e=0;e<a.length;++e)d.segmentParams[e]=a[e]}let D=0;for(let e of n){d.partOffsets[T++]=C,v(e[0]);let t=e.length;w&&(t-=H(e));for(let n=1;n<t;++n){let t=e[n];if(x(t)){E(4);let r=d.segmentParams,[i,[a,o],s,c,l,u,f]=t.a,p=4;c||(p|=1),s||(p|=2);let h=S(m(e[n-1]),t),[_,y]=g(h,.5);r[D++]=p,r[D++]=u,r[D++]=f,r[D++]=l,r[D++]=a,r[D++]=o,r[D++]=h.u2-h.u1,r[D++]=h.u1,r[D++]=_,r[D++]=y,v(i);continue}let r=h(t);if(s(t)||r){E(4);let i=d.segmentParams,o=m(t),s=r?l(m(e[n-1]),t):a(m(e[n-1]),t),{cx:c,cy:u,thetaStart:f,thetaEnd:p,radius:h}=s,g=r?0:4;f>p||(g|=1),Math.abs(p-f)<=Math.PI||(g|=2);let[y,b]=r?t.c[1]:_(s,.5);i[D++]=g,i[D++]=h,i[D++]=1,i[D++]=0,i[D++]=c,i[D++]=u,i[D++]=p-f,i[D++]=f,i[D++]=y,i[D++]=b,v(o);continue}if(p(t)){E(2);let e=d.segmentParams,[n,[r,i],[a,o]]=t.b;e[D++]=r,e[D++]=i,e[D++]=a,e[D++]=o,v(n);continue}E(1),v(t)}}return d.partOffsets[T]=C,d}function N(e){let t=B(e),{vertexCount:n,partCount:r,hasZ:i,hasM:a}=e,o=z(e);if(e.type===`point`){let[t,n]=e.vertexXY,r=e.vertexZ?.[0],i=e.vertexM?.[0];return{x:t,y:n,z:r,m:i,spatialReference:o}}let s=0;if(e.type===`multipoint`){let e=[];for(;s<n;)e.push(t(s++));return{points:e,spatialReference:o,hasZ:i,hasM:a}}let c=e.type===`polygon`;if(!e.hasCurves){let n=[];for(let i=0;i<r;++i){let r=e.partOffsets[i+1],a=[];for(;s<r;)a.push(t(s++));c&&a.length>0&&a.push(a[0]),n.push(a)}return c?{rings:n,hasZ:i,hasM:a,spatialReference:o}:{paths:n,hasZ:i,hasM:a,spatialReference:o}}let l=[];for(let{segments:t,startVertex:n}of e.parts){let e=[n];for(let{curve:n}of t)e.push(n);l.push(e)}return c?{rings:[],curveRings:l,hasZ:i,hasM:a,spatialReference:o}:{paths:[],curvePaths:l,hasZ:i,hasM:a,spatialReference:o}}function P(e,{lengths:t,coords:n,hasZ:r,hasM:i},a){let o=e.includes(`point`)?0:t.length,s=e===`polygon`,c=e===`point`?1:t.reduce((e,t)=>e+t,0)-(s?o:0);r??=!1,i??=!1;let l=U(e,c,o,r,i,!1,0,0);if(l.spatialReference=a??void 0,!l.isMultipart){for(let e=0,t=0;e<c;++e)l.vertexXY[2*e]=n[t++],l.vertexXY[2*e+1]=n[t++],r&&(l.vertexZ[e]=n[t++]),i&&(l.vertexM[e]=n[t++]);return l}let u=2+Number(r)+Number(i),d=0,f=0;l.partOffsets[0]=0;for(let e of t){let t=l.partOffsets[f],a=t+e-Number(s);l.partOffsets[++f]=a;for(let e=t;e<a;++e)l.vertexXY[2*e]=n[d++],l.vertexXY[2*e+1]=n[d++],r&&(l.vertexZ[e]=n[d++]),i&&(l.vertexM[e]=n[d++]);s&&(d+=u)}return l}function F({type:e,vertexCount:t,vertexXY:n,vertexZ:r,vertexM:i,partCount:a,partOffsets:o,hasZ:s,hasM:c}){let l=new w([],[],s,c);a=Math.max(a,1);let u=e===`polygon`,d=0;for(let e=0;e<a;++e){let a=o?.[e+1]??t,f=l.coords.length;for(let e=d;e<a;++e)l.coords.push(n[2*e],n[2*e+1]),s&&l.coords.push(r[e]),c&&l.coords.push(i[e]);if(u){let e=d;l.coords.push(n[2*e],n[2*e+1]),s&&l.coords.push(r[e]),c&&l.coords.push(i[e])}l.lengths.push((l.coords.length-f)/l.stride),d=a}return e===`point`&&(l.lengths.length=0),l}function I(e,t){return`getSpatialReference`in e&&(t=L(e.getSpatialReference()),e=e.getGeometry()),new T({...e.toFlatGeometry(),spatialReference:t})}function L(e){if(e==null)return;let t=e.getText()||void 0,n=e.isCustomWkid()?0:e.getOldID();if(n<=0)return{wkt:t};let r=e.getLatestID();(r<=0||r===n)&&(r=void 0);let i=e.getVCS();if(i==null)return{wkid:n,latestWkid:r,wkt:t};let a=i.isCustomWkid()?0:i.getOldID();if(a<=0)return{wkt:t};let o=e.getLatestVerticalID();return(o<=0||o===a)&&(o=void 0),{wkid:n,wkt:t,latestWkid:r,vcsWkid:a,latestVcsWkid:o}}var R=class{constructor(e,t){this.target=e,this.keys=t,this.oldValues=t.map(t=>e[t]);for(let n of t)e[n]=void 0}[Symbol.dispose](){this.keys.map((e,t)=>{this.target[e]=this.oldValues[t]})}};function z({spatialReference:e}){return e instanceof d?e.toJSON():e}function B({vertexXY:e,vertexZ:t,vertexM:n}){return t?n?r=>[e[2*r],e[2*r+1],t[r],n[r]]:n=>[e[2*n],e[2*n+1],t[n]]:n?t=>[e[2*t],e[2*t+1],n[t]]:t=>[e[2*t],e[2*t+1]]}function V(e){switch(e){case 1:return 0;case 4:return 10;case 2:return 4}}function H(e){if(e.length>0){let t=e[0],n=m(e.at(-1));return t.every((e,t)=>e===n[t])?1:0}return 0}function U(e,t,n,r,i,a,o,s){o??=0,s??=0;let c=new T({type:e,vertexCount:t,vertexXY:null,vertexZ:void 0,vertexM:void 0,partCount:n,partOffsets:void 0,partFlags:void 0,segmentFlags:void 0,segmentIndices:void 0,segmentParams:void 0,segmentCountArc:o,segmentCountBezier:s}),l=2*Float64Array.BYTES_PER_ELEMENT*t;r&&(l+=Float64Array.BYTES_PER_ELEMENT*t),i&&(l+=Float64Array.BYTES_PER_ELEMENT*t),c.isMultipart&&(l+=(n+1)*Int32Array.BYTES_PER_ELEMENT,l+=(n+1)*Int8Array.BYTES_PER_ELEMENT),a&&(l+=t*Int8Array.BYTES_PER_ELEMENT,l+=t*Int32Array.BYTES_PER_ELEMENT,l+=c.segmentParamCount*Float64Array.BYTES_PER_ELEMENT);let u=new ArrayBuffer(l),d=0;if(c.vertexXY=new Float64Array(u,d,2*t),d+=c.vertexXY.byteLength,r&&(c.vertexZ=new Float64Array(u,d,t),d+=c.vertexZ.byteLength),i&&(c.vertexM=new Float64Array(u,d,t),d+=c.vertexM.byteLength),a&&(c.segmentParams=new Float64Array(u,d,c.segmentParamCount),d+=c.segmentParams.byteLength,c.segmentIndices=new Int32Array(u,d,t),c.segmentIndices.fill(G),d+=c.segmentIndices.byteLength),c.isMultipart&&(c.partOffsets=new Int32Array(u,d,n+1),d+=c.partOffsets.byteLength,c.partFlags=new Int8Array(u,d,n+1),d+=c.partFlags.byteLength),a&&(c.segmentFlags=new Int8Array(u,d,t),c.segmentFlags.fill(1),d+=c.segmentFlags.byteLength),c.type===`polygon`)for(let e=0;e<n;++e)c.partFlags[e]=1;return c}var W=1.61803,G=-1;export{M as a,I as i,N as n,j as o,F as r,P as t};