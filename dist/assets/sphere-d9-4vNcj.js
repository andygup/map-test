import{Bl as e,C_ as t,Fl as n,Gb as r,Hl as i,Nl as a,Ol as o,Q as s,Rl as c,Ul as l,Vl as u,Wl as d,Xm as f,_l as p,hl as m,hw as h,kl as g,pl as _,vl as v,w_ as y,x_ as b,y_ as x,yw as S,zl as C}from"./index-BN8X5Ryz.js";import{k as w}from"./plane-Da5EsY0J.js";import{n as T,t as E}from"./vectorStacks-Cuo89CNO.js";import{s as D,t as O}from"./ray-LkJ58wpZ.js";import{t as k}from"./vec3-B94Y7ih2.js";function A(e){return e instanceof Float32Array&&e.length>=4}function j(e){return Array.isArray(e)&&e.length>=4}function M(e){return A(e)||j(e)}function N(e,t){let n=u(e),r=S(e[2]/n),i=Math.atan2(e[1]/n,e[0]/n);return c(t,n,r,i),t}var P=class n{constructor(e=0,n=0,r=0,i=0){this.radius=i,typeof e==`number`?this._center=b(e,n,r):k(e)||M(e)?(this._center=y(e),this.radius=e.length===4?e[3]:n):(this._center=t(e.center),this.radius=e.radius)}get isValid(){return this.radius>=0}invalidate(){this.radius=-1}get center(){return this._center}set center(e){i(this.center,e)}exactEquals(e){return v(this._center,e.center)&&this.radius===e.radius}copyFrom(e){return e!==this&&(i(this._center,e.center),this.radius=e.radius),this}clone(){return new n(this.center,this.radius)}toVec4(){return s(this.center[0],this.center[1],this.center[2],this.radius)}contains(e){return d(this.center,e)<=this.radius**2}intersectRay(e,t){if(e==null||!this._intersect(e,L))return!1;let{t0:n,t1:r}=L;if((n<0||r<n&&r>0)&&(n=r),n<0)return!1;if(t){let{origin:r,direction:i}=e;t[0]=r[0]+i[0]*n,t[1]=r[1]+i[1]*n,t[2]=r[2]+i[2]*n}return!0}intersectLine(t,n){let i=O(t,n);if(!this._intersect(i,L))return[];let{origin:a,direction:o}=i,{t0:s,t1:c}=L,l=t=>{let n=x();return e(n,a,o,t),this.projectPoint(n,n)};return Math.abs(s-c)<r()?[l(s)]:[l(s),l(c)]}_intersect(e,t){let{origin:n,direction:r}=e,i=R;i[0]=n[0]-this.center[0],i[1]=n[1]-this.center[1],i[2]=n[2]-this.center[2];let a=r[0]*r[0]+r[1]*r[1]+r[2]*r[2];if(a===0)return!1;let o=2*(r[0]*i[0]+r[1]*i[1]+r[2]*i[2]),s=o*o-4*a*(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]-this.radius**2);if(s<0)return!1;let c=Math.sqrt(s);return t.t0=(-o-c)/(2*a),t.t1=(-o+c)/(2*a),!0}projectPoint(e,t){let n=g(E.get(),e,this.center),r=a(E.get(),n,this.radius/u(n));return l(t,r,this.center)}closestPointOnSilhouette(e,t){let n=E.get(),r=T.get();o(n,e.origin,e.direction),o(t,n,e.origin),a(t,t,1/u(t)*this.radius);let i=this._angleToSilhouette(e.origin),s=w(e.origin,t);return f(r,s+i,n),m(t,t,r),t}frustumCoverage(e,t,n){let r=this.radius,i=r*r,a=e+.5*Math.PI,o=t*t+i-2*Math.cos(a)*t*r,s=Math.sqrt(o),c=o-i;if(c<=0)return .5;let l=Math.sqrt(c),u=Math.acos(l/s)-Math.asin(r/(s/Math.sin(a)));return Math.min(1,(u+.5*n)/n)}_angleToSilhouette(e){let t=g(E.get(),e,this.center),n=u(t),r=this.radius,i=r+Math.abs(r-n);return h(r/i)}union(e){let t=C(this._center,e.center),n=this.radius,r=e.radius;return t+r<n?this:t+n<r?(this.copyFrom(e),this):(p(this._center,this._center,e.center,(t+r-n)/(2*t)),this.radius=(t+n+r)/2,this)}toJSON(){return{center:this.center,radius:this.radius}}},F={create:e=>new P(e),copy:(e,t)=>t.copyFrom(e),setExtent:(e,t,n)=>n.copyFrom(e),getExtent:(e,t)=>t,elevate:(e,t,n)=>(n.copyFrom(e),n.radius+=t,n),axisAt(e,t,n,r){let i=g(z,t,e.center);switch(n){case 0:{let e=N(i,z)[2];return c(r,-Math.sin(e),Math.cos(e),0)}case 1:{let e=N(i,z),t=e[1],n=e[2],a=Math.sin(t);return c(r,-a*Math.cos(n),-a*Math.sin(n),Math.cos(t))}case 2:return _(r,i);default:return}},altitudeAt(e,t){let n=g(B,t,e.center);return u(n)-e.radius},setAltitudeAt(e,t,n,r){let i=F.altitudeAt(e,t),o=F.axisAt(e,t,2,B),s=a(B,o,n-i);return l(r,t,s)},intersectRay:(e,t,n)=>e.intersectRay(t,n),closestPoint:(e,t,n)=>e.intersectRay(t,n)?n:(D(t,e.center,n),e.projectPoint(n,n)),intersectRayClosestSilhouette(e,t,n){if(e.intersectRay(t,n))return n;let r=e.closestPointOnSilhouette(t,E.get());return l(n,t.origin,a(E.get(),t.direction,C(t.origin,r)/u(t.direction))),n},closestPointOnSilhouette:(e,t,n)=>e.closestPointOnSilhouette(t,n),distanceToSilhouette(e,t){let r=g(E.get(),t,e.center),i=n(r),a=e.radius**2;return Math.sqrt(Math.abs(i-a))}},I=new P,L={t0:0,t1:0},R=x(),z=x(),B=x();export{I as n,P as r,F as t};