const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/uploadAssets-CjYhUfyC.js","assets/index-CzMixifc.js","assets/index-CDgdHpAj.css","assets/quatf64-eO7UAs9K.js","assets/quat-XKFzqP_i.js","assets/MeshTransform-BGwY5MT4.js","assets/axisAngleDegrees-GaSk0_KM.js","assets/External-BGzO9MR2.js","assets/meshSpatialReferenceScaleUtils-BSjARk6_.js","assets/meshFeatureAttributes-BiaxiIdJ.js","assets/convertMeshVertexSpace-CDqx_s5c.js","assets/vec3-D13Z1xO0.js","assets/vec4-CJBDH7oG.js","assets/computeTranslationToOriginAndRotation-DwwRDWAD.js","assets/projectPointToVector-D72S8Uh5.js","assets/spatialReferenceEllipsoidUtils-b6wDfyu0.js","assets/MeshLocalVertexSpace-Dfv_NBsU.js","assets/MeshVertexAttributes-Dvo9ht5s.js","assets/meshProperties-DwrhStLW.js","assets/BufferView-BPABY7if.js","assets/Util-YNFIi00s.js","assets/meshCloneUtils-5rtyOBgA.js","assets/vertexSpaceConversion-WXuyjrGI.js","assets/meshVertexSpaceUtils-CrM2H6JB.js"])))=>i.map(i=>d[i]);
import{$i as e,BS as t,BT as n,DT as r,Gw as i,Hw as a,JE as o,Jw as s,KE as c,Kn as l,OT as u,Oh as d,PT as f,Qi as p,RS as m,SC as h,Vh as g,Xi as _,YS as v,Zi as y,_E as b,ax as x,eh as S,gD as C,nv as w,pD as T,rd as E,uE as D,ur as O,vE as k,va as A,wx as j}from"./index-CzMixifc.js";import{n as M}from"./MeshLocalVertexSpace-Dfv_NBsU.js";import{a as N}from"./meshVertexSpaceUtils-CrM2H6JB.js";import{s as P}from"./External-BGzO9MR2.js";import{r as F}from"./clientSideDefaults-4m0UtucK.js";import{a as I,i as L,n as R,o as z,r as B,s as V,t as H}from"./applyEditsUtils-CvqjBc8C.js";import{n as U}from"./executeQueryJSON-BmDY9cVm.js";import{t as W}from"./QueryTask-CVh9qxsU.js";var G=new f({originalAndCurrentFeatures:`original-and-current-features`,none:`none`}),K=new f({Started:`published`,Publishing:`publishing`,Stopped:`unavailable`}),q=class extends g{constructor(e){super(e),this.type=`feature-layer`,this.supportedSourceTypes=new Set([`Feature Layer`,`Oriented Imagery Layer`,`Table`,`Catalog Layer`]),this.refresh=a(async()=>{await this.load();let e=this.sourceJSON.editingInfo?.lastEditDate;if(e==null)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}let t=e!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}}),this._ongoingAssetUploads=new Map}load(e){let t=this.layer.sourceJSON,n=this._fetchService(t,{...e}).then(()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e)).then(()=>this._ensureLatestMetadata(e));return this.addResolvingPromise(n),Promise.resolve(this)}initialize(){this.addHandles([w(()=>{let e=this.layer;return e&&`lastEditsEventDate`in e?e.lastEditsEventDate:null},e=>this._handleLastEditsEventChange(e))])}destroy(){this._removeEditInterceptor()}get queryTask(){let{capabilities:e,parsedUrl:t,gdbVersion:n,spatialReference:r,fieldsIndex:i,uniqueIdFields:a}=this.layer,o=`infoFor3D`in this.layer?this.layer.infoFor3D:null,s=`dynamicDataSource`in this.layer?this.layer.dynamicDataSource:null,c=T(`featurelayer-pbf`)&&e?.query.supportsFormatPBF&&o==null;return new W({dynamicDataSource:s,fieldsIndex:i,gdbVersion:n,infoFor3D:o,pbfSupported:c,queryAttachmentsSupported:e?.operations?.supportsQueryAttachments??!1,sourceSpatialReference:r,uniqueIdFields:a,url:t.path})}async addAttachment(e,t){await this.load();let{layer:n}=this;await O(n,`editing`);let r=e.attributes[n.objectIdField],i=n.parsedUrl.path+`/`+r+`/addAttachment`,a=this._getLayerRequestOptions(),o=this._getFormDataForAttachment(t,a.query);try{let e=await m(i,{body:o});return R(e.data.addAttachmentResult)}catch(e){throw this._createAttachmentErrorResult(r,e)}}async updateAttachment(e,t,n){await this.load();let{layer:r}=this;await O(r,`editing`);let i=e.attributes[r.objectIdField],a=r.parsedUrl.path+`/`+i+`/updateAttachment`,o=this._getLayerRequestOptions({query:{attachmentId:t}}),s=this._getFormDataForAttachment(n,o.query);try{let e=await m(a,{body:s});return R(e.data.updateAttachmentResult)}catch(e){throw this._createAttachmentErrorResult(i,e)}}async applyEdits(t,r){await this.load();let{layer:i}=this;await O(i,`editing`);let a=`infoFor3D`in i?i.infoFor3D:null,s=a!=null,c=s||(r?.globalIdUsed??!1),l=s?await this._uploadMeshesAndGetAssetMapEditsJSON(t):null,u=t.addFeatures?.map(e=>z(this.layer,e,a))??[],d=(await Promise.all(u)).filter(o),f=t.updateFeatures?.map(e=>z(this.layer,e,a))??[],h=(await Promise.all(f)).filter(o),g=B(this.layer,t.deleteFeatures,c);A(d,h,i.spatialReference);let v=await L(this.layer,t),b=i.capabilities.editing.supportsAsyncApplyEdits&&s,x=r?.gdbVersion||i.gdbVersion,S={gdbVersion:x,rollbackOnFailure:r?.rollbackOnFailureEnabled,useGlobalIds:c,returnEditMoment:r?.returnEditMoment,usePreviousEditMoment:r?.usePreviousEditMoment,async:b};await y(this.layer.url,x,!0);let C=_(this.layer.url,x||null);if(await p(i.url,x,i.historicMoment))throw new n(`feature-layer-source:historic-version`,`Editing a historic version is not allowed`);r?.returnServiceEditsOption?(S.edits=JSON.stringify([{id:i.layerId,adds:d.length?d:null,updates:h.length?h:null,deletes:g.length?g:null,attachments:v,assetMaps:l}]),S.returnServiceEditsOption=G.toJSON(r?.returnServiceEditsOption),S.returnServiceEditsInSourceSR=r?.returnServiceEditsInSourceSR):(S.adds=d.length?JSON.stringify(d):null,S.updates=h.length?JSON.stringify(h):null,S.deletes=g.length?c?JSON.stringify(g):g.join(`,`):null,S.attachments=v&&JSON.stringify(v),S.assetMaps=l==null?void 0:JSON.stringify(l));let w=this._getLayerRequestOptions({method:`post`,query:S});C&&(w.authMode=`immediate`,w.query.returnEditMoment=!0,w.query.sessionId=e);let T=r?.returnServiceEditsOption?i.url:i.parsedUrl.path,E;try{E=b?await this._asyncApplyEdits(T+`/applyEdits`,w):await m(T+`/applyEdits`,w)}catch(e){if(!I(e))throw e;w.authMode=`immediate`,E=b?await this._asyncApplyEdits(T+`/applyEdits`,w):await m(T+`/applyEdits`,w)}return this._createEditsResult(E)}async deleteAttachments(e,t){await this.load();let{layer:n}=this;await O(n,`editing`);let r=e.attributes[n.objectIdField],i=n.parsedUrl.path+`/`+r+`/deleteAttachments`;try{return(await m(i,this._getLayerRequestOptions({query:{attachmentIds:t.join(`,`)},method:`post`}))).data.deleteAttachmentResults.map(R)}catch(e){throw this._createAttachmentErrorResult(r,e)}}fetchRecomputedExtents(e={}){let t=e.signal;return this.load({signal:t}).then(async()=>{let t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:n,url:r}=this.layer,{data:i}=await m(`${r}/${n}`,t),{id:a,extent:o,fullExtent:s,timeExtent:c}=i,l=o||s;return{id:a,fullExtent:l&&x.fromJSON(l),timeExtent:c&&d.fromJSON({start:c[0],end:c[1]})}})}async queryAttachments(e,t={}){await this.load();let n=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,n)}async queryFeatures(e,t){await this.load();let n=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});if(e.outStatistics?.length&&n.features.length){let t=new Map;if(n.features.forEach(n=>{let r=n.attributes;e.outStatistics?.forEach(({outStatisticFieldName:e})=>{if(e){let n=e.toLowerCase();n&&n in r&&e!==n&&(r[e]=r[n],delete r[n],t.set(n,e))}})}),n.fields!=null)for(let e of n.fields){let n=t.get(e.name.toLowerCase());n!=null&&(e.name=n)}}return n}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryPivot(e,t){return await this.load(),this.queryTask.executePivotQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryAttributeBins(e,t){return await this.load(),this.queryTask.executeAttributeBinsQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!v(this.layer.url))return`unavailable`;let e=h(this.layer.url,`status`),t=await m(e,{query:{f:`json`}});return K.fromJSON(t.data.status)}async uploadAssets(e,n){let{uploadAssets:r}=await t(async()=>{let{uploadAssets:e}=await import(`./uploadAssets-CjYhUfyC.js`);return{uploadAssets:e}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]));return r(e,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},n)}_handleLastEditsEventChange(e){let t=this.layer;if(e==null||!(`capabilities`in t)||!(`effectiveCapabilities`in t)||!(!t.capabilities?.operations?.supportsEditing&&t.effectiveCapabilities?.operations?.supportsEditing))return;let n=t.url;n!=null&&(`layerId`in t&&h(n,t.layerId.toString()),this._getOrCreateEditInterceptor(n).before=t=>{let n=t.requestOptions.method??`auto`;if(n===`auto`||n===`head`){let n=t.requestOptions.query??{};n._ts=e.getTime(),t.requestOptions.query=n}})}_getOrCreateEditInterceptor(e){return this._editInterceptor??(this._editInterceptor={urls:e},b.request.internalInterceptors.push(this._editInterceptor)),this._editInterceptor}_removeEditInterceptor(){this._editInterceptor!=null&&(c(b.request.internalInterceptors,this._editInterceptor),this._editInterceptor=null)}async _asyncApplyEdits(e,t){let r=(await m(e,t)).data.statusUrl;for(;;){let e=(await m(r,{query:{f:`json`},responseType:`json`})).data;switch(e.status){case`Completed`:return m(e.resultUrl,{query:{f:`json`},responseType:`json`});case`CompletedWithErrors`:throw new n(`async-applyEdits-failed`,`asynchronous applyEdits call failed.`);case`Failed ImportChanges`:case`InProgress`:case`Pending`:case`ExportAttachments`:case`ExportChanges`:case`ExportingData`:case`ExportingSnapshot`:case`ImportAttachments`:case`ProvisioningReplica`:case`UnRegisteringReplica`:break;default:throw new n(`async-applyEdits-failed`,`asynchronous applyEdits call failed (undefined response status)`)}await i(J)}}_createRequestQueryOptions(e){let t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){let n={};T(`featurelayer-advanced-symbols`)&&(n.returnAdvancedSymbols=!0),t?.cacheBust&&(n._ts=Date.now());let{data:r}=await m(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:n,signal:t?.signal}));e=r}this.layer.applyPreferredHost(e),this.sourceJSON=await this._patchServiceJSON(e,t?.signal);let r=e.type;if(!this.supportedSourceTypes.has(r))throw new n(`feature-layer-source:unsupported-type`,`Source type "${r}" is not supported`)}async _patchServiceJSON(e,t){if(e.type!==`Table`&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){let t=F(e.geometryType).renderer;k(`drawingInfo.renderer`,t,e)}if(e.geometryType===`esriGeometryMultiPatch`&&e.infoFor3D&&(e.geometryType=`mesh`),e.extent==null)try{let{data:n}=await m(this.layer.url,this._getLayerRequestOptions({signal:t}));n.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:n.spatialReference})}catch(e){s(e)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(e){let{addAssetFeatures:r}=e;if(!r?.length||await this._areAllAssetsAlreadyMapped(r))return null;let i=e.addFeatures.filter(e=>e.geometry);if(r.length!==i.length+e.updateFeatures.length)throw new n(`feature-layer-source:unsupported-mesh-edits`,`Mixing attribute only edits with mesh geometry edits is not currently supported`);let a=[],o=new Map;for(let e of r){let{geometry:n}=e,{vertexSpace:r}=n;if(N(r))a.push(n);else{let r=n.origin,{convertMeshVertexSpace:i}=await t(async()=>{let{convertMeshVertexSpace:e}=await import(`./convertMeshVertexSpace-CDqx_s5c.js`);return{convertMeshVertexSpace:e}},__vite__mapDeps([10,1,2,11,12,13,14,15,16,17,18,19,20,21,22,23])),s=await i(n,new M({origin:[r.x,r.y,r.z??0]}));o.set(s,n),e.geometry=s,a.push(s)}}await this.uploadAssets(a);for(let[e,t]of o)t.addExternalSources(e.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(r),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){let t=[],n=this.layer.globalIdField,r=this.layer.parsedUrl;for(let i of e){let e=i.geometry,{metadata:a}=e,o=a.getExternalSourcesOnService(r),s=i.getAttribute(n);if(o.length===0){D.getLogger(this).error(`Skipping feature ${s}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}let{source:c}=o.find(P)??o[0];for(let e of c.assets)e.parts.length===1?t.push({globalId:S(),parentGlobalId:s,assetName:e.assetName,assetHash:e.parts[0].partHash,flags:[]}):D.getLogger(this).error(`Skipping asset ${e.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){let t=e.data,{layerId:n}=this.layer,r=[],i=null;if(Array.isArray(t))for(let e of t)r.push({id:e.id,editedFeatures:e.editedFeatures}),e.id===n&&(i={addResults:e.addResults??[],updateResults:e.updateResults??[],deleteResults:e.deleteResults??[],attachments:e.attachments,editMoment:e.editMoment});else i=t;let a=V(i);if(r.length>0){a.editedFeatureResults=[];for(let e of r){let{editedFeatures:t}=e,n=t?.spatialReference?new j(t.spatialReference):null;a.editedFeatureResults.push({layerId:e.id,editedFeatures:H(t,n)})}}return a}_createAttachmentErrorResult(e,t){let r=t.details.messages?.[0]||t.message,i=t.details.httpStatus||t.details.messageCode;return{objectId:e,globalId:null,error:new n(`feature-layer-source:attachment-failure`,r,{code:i})}}_getFormDataForAttachment(e,t){let n=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(n)for(let e in t){let r=t[e];r!=null&&(n.set?n.set(e,r):n.append(e,r))}return n}_getLayerRequestOptions(e={}){let{layer:t,layer:{parsedUrl:n,gdbVersion:r}}=this;return{...e,query:{gdbVersion:r,layer:`dynamicDataSource`in t&&t.dynamicDataSource?JSON.stringify({source:t.dynamicDataSource}):void 0,...n.query,f:`json`,...this._createRequestQueryOptions(e)},responseType:`json`}}async _areAllAssetsAlreadyMapped(e){let{layer:t}=this,{globalIdField:n,parsedUrl:r}=t,i=`infoFor3D`in t?t.infoFor3D:null;if(i==null||n==null)return!1;let a=l(i);if(a==null)return!1;let s=h(r.path,`../${a.id}`),c=[];for(let t of e){if(!(t.geometry.metadata.getExternalSourcesOnService(r).length>0))return!1;c.push(t)}let u=c.map(e=>e.getAttribute(n)).filter(o);if(u.length===0)return!1;let{assetMapFieldRoles:{parentGlobalId:d,assetHash:f}}=i,p=new E({where:`${d} IN (${u.map(e=>`'${e}'`)})`,outFields:[f,d],returnGeometry:!1}),m=await U(s,p),{features:g}=m;return g.length!==0&&!c.some(e=>{let t=e.getAttribute(n);if(!t)return!0;let{metadata:i}=e.geometry,a=g.filter(e=>e.getAttribute(d)===t);if(a.length===0)return!0;let o=a.map(e=>e.getAttribute(f));return i.getExternalSourcesOnService(r).flatMap(({source:e})=>e.assets.flatMap(e=>e.parts.map(e=>e.partHash))).some(e=>o.every(t=>e!==t))})}};C([r()],q.prototype,`type`,void 0),C([r({constructOnly:!0})],q.prototype,`layer`,void 0),C([r({constructOnly:!0})],q.prototype,`supportedSourceTypes`,void 0),C([r({readOnly:!0})],q.prototype,`queryTask`,null),q=C([u(`esri.layers.graphics.sources.FeatureLayerSource`)],q);var J=1e3;export{q as t};