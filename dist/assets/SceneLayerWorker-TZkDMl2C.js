const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/projectBuffer-BRPhOnis.js","assets/index-CZ4oMP1N.js","assets/index-CDgdHpAj.css","assets/projectionUtils-BJCEkxxu.js","assets/projectMeshVertexPositions-QvrwOvsH.js","assets/vec3-DSOiDp9-.js","assets/vec4-utmnCg3f.js","assets/computeTranslationToOriginAndRotation-Cm78hfIp.js","assets/projectPointToVector-HYpbaZqA.js","assets/spatialReferenceEllipsoidUtils-B0E4spY0.js","assets/MeshLocalVertexSpace-OEvelzSD.js","assets/BufferView-D7rgY_ku.js","assets/Util-BF0TzZHY.js","assets/projectMeshVertexPositions-DD7Pub3p.js","assets/vertexSpaceConversion-Ca0tjp55.js","assets/meshVertexSpaceUtils-CsTvVRUI.js"])))=>i.map(i=>d[i]);
import{BS as e,LS as t,Lf as n,Pf as r,c_ as i,ew as a,oT as o,wx as s}from"./index-CZ4oMP1N.js";import{n as c,t as l}from"./MeshLocalVertexSpace-OEvelzSD.js";import"./projectPointToVector-HYpbaZqA.js";import{n as u,o as d}from"./vec3-DSOiDp9-.js";import"./dehydratedPoint-rdg1UAtQ.js";import"./projectVectorToVector-DX3Yd1qf.js";import"./WorkerHandle-BLUb_Jly.js";function f(){return m??=(async()=>await(await e(()=>import(`./i3s-Ub7XgTMA.js`),[])).default({locateFile:e=>t(`esri/libs/i3s/${e}`)}))(),m}function p(){m=null}var m,h=class{constructor(e,t,n,r,i,a){this.layout=e,this.interleavedVertexData=t,this.indices=n,this.hasColors=r,this.hasModifications=i,this.positionData=a}},g=class{constructor(e,t,n,r,i,a,o){this.componentOffsets=e,this.featureIds=t,this.anchorIds=n,this.anchors=r,this.transformedGeometry=i,this.globalTrafo=a,this.obb=o}};new o({deallocator:null}),i();async function _(e){E=await P();let t=[e.geometryBuffer];return{result:O(E,e,t),transferList:t}}async function v(e){E=await P();let t=[e.geometryBuffer],{geometryBuffer:n}=e,r=n.byteLength,i=E._malloc(r),a=new Uint8Array(E.HEAPU8.buffer,i,r);a.set(new Uint8Array(n));let o=E.dracoDecompressPointCloudData(i,a.byteLength);if(E._free(i),o.error.length>0)throw Error(`i3s.wasm: ${o.error}`);let s=o.featureIds?.length>0?o.featureIds.slice():null,c=o.positions.slice();return s&&t.push(s.buffer),t.push(c.buffer),{result:{positions:c,featureIds:s},transferList:t}}async function y(e){await P(),A(e);let t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function b(e){await P(),D(e)}async function x(e){E=await P(),E.setLegacySchema(e.context,e.jsonSchema)}async function S(t){let{localMatrix:i,origin:a,positions:o,vertexSpace:u}=t,d=s.fromJSON(t.inSpatialReference),f=s.fromJSON(t.outSpatialReference),p=i?n(i):void 0,m=r(a),h,[{projectBuffer:g},{initializeProjection:_}]=await Promise.all([e(()=>import(`./projectBuffer-BRPhOnis.js`),__vite__mapDeps([0,1,2])),e(()=>import(`./projectionUtils-BJCEkxxu.js`),__vite__mapDeps([3,1,2]))]);await _(d,f);let v=[0,0,0];if(!g(m,d,0,v,f,0))throw Error(`Failed to project`);if(u.type===`georeferenced`&&u.origin==null){if(h=new Float64Array(o.length),!g(o,d,0,h,f,0,h.length/3))throw Error(`Failed to project`)}else{let t=u.type===`georeferenced`?c.fromJSON(u):l.fromJSON(u),{projectMeshVertexPositions:n}=await e(async()=>{let{projectMeshVertexPositions:e}=await import(`./projectMeshVertexPositions-QvrwOvsH.js`);return{projectMeshVertexPositions:e}},__vite__mapDeps([4,5,1,2,6,7,8,9,10,11,12,13,14,15])),r=n({vertexAttributes:{position:o},transform:p?{localMatrix:p}:void 0,vertexSpace:t,spatialReference:d},f);if(!r)throw Error(`Failed to project`);h=r}let y=h.length,[b,x,S]=v;for(let e=0;e<y;e+=3)h[e]-=b,h[e+1]-=x,h[e+2]-=S;return{result:{projected:h,original:o,projectedOrigin:v},transferList:[h.buffer,o.buffer]}}async function C({normalMatrix:e,normals:t}){let n=new Float32Array(t.length);return d(n,t,e),a(e)&&u(n,n),{result:{transformed:n,original:t},transferList:[n.buffer,t.buffer]}}function w(e){j(e)}var T,E;function D(e){if(!E)return;let t=e.modifications,n=E._malloc(8*t.length),r=new Float64Array(E.HEAPU8.buffer,n,t.length);for(let e=0;e<t.length;++e)r[e]=t[e];E.setModifications(e.context,n,t.length,e.isGeodetic),E._free(n)}function O(e,t,n){let{context:r,globalTrafo:i,mbs:a,obbData:o,layouts:s,needNormals:c,elevationOffset:l,geometryBuffer:u,geometryDescriptor:d,indexToVertexProjector:f,vertexToRenderProjector:p,normalReferenceFrame:m}=t,_=e._malloc(u.byteLength),v=e._malloc(33*Float64Array.BYTES_PER_ELEMENT),y=new Uint8Array(e.HEAPU8.buffer,_,u.byteLength);y.set(new Uint8Array(u));let b=new Float64Array(e.HEAPU8.buffer,v,33);M(b,[NaN,NaN,NaN],0);let x=3;M(b,i,x),x+=16,M(b,a.center,x),x+=3,b[x++]=a.radius,o&&M(b,o,x++);let S={isDraco:!1,isLegacy:!1,color:s.some(e=>e.some(e=>e.name===`color`)),normal:c&&s.some(e=>e.some(e=>e.name===`normalCompressed`)),uv0:s.some(e=>e.some(e=>e.name===`uv0`)),uvRegion:s.some(e=>e.some(e=>e.name===`uvRegion`)),featureIndex:d.featureIndex},C=e.process(r,!!o,_,y.byteLength,d,S,v,l,f,p,m);if(e._free(v),e._free(_),C.error.length>0)throw Error(`i3s.wasm: ${C.error}`);if(C.discarded)return null;let w=C.componentOffsets.length>0?C.componentOffsets.slice():null,T=C.featureIds.length>0?C.featureIds.slice():null,E=C.anchorIds.length>0?Array.from(C.anchorIds):null,D=C.anchors.length>0?Array.from(C.anchors):null,O=C.interleavedVertedData.slice().buffer,k=C.indicesType===1?new Uint16Array(C.indices.buffer,C.indices.byteOffset,C.indices.byteLength/2).slice():new Uint32Array(C.indices.buffer,C.indices.byteOffset,C.indices.byteLength/4).slice(),A=C.positions.slice(),{buffer:j,byteOffset:N,byteLength:P}=C.positionIndices,F=C.positionIndicesType===1?new Uint16Array(j,N,P/2).slice():new Uint32Array(j,N,P/4).slice(),I=new h(t.layouts[0],O,k,C.hasColors,C.hasModifications,{data:A,indices:F});return T&&n.push(T.buffer),w&&n.push(w.buffer),n.push(O),n.push(k.buffer),n.push(A.buffer),n.push(F.buffer),new g(w,T,E,D,I,i,C.obb)}function k(e){return e===0?0:e===1?1:e===2?2:3}function A(e){if(!E)return;let{context:t,buffer:n}=e,r=E._malloc(n.byteLength),i=n.byteLength/Float64Array.BYTES_PER_ELEMENT,a=new Float64Array(E.HEAPU8.buffer,r,i),o=new Float64Array(n);a.set(o),E.filterOBBs(t,r,i),o.set(a),E._free(r)}function j(e){E&&E.destroy(e)===0&&(E=null,T=null,p())}function M(e,t,n){for(let r=0;r<t.length;++r)e[r+n]=t[r]}async function N(){E||await P()}async function P(){return E||=await(T??=f()),E}var F={transform:(e,t)=>E&&O(E,e,t),destroy:j};export{w as destroyContext,v as dracoDecompressPointCloudData,y as filterObbsForModifications,A as filterObbsForModificationsSync,N as initialize,k as interpretObbModificationResults,_ as process,S as project,x as setLegacySchema,b as setModifications,D as setModificationsSync,F as test,C as transformNormals};