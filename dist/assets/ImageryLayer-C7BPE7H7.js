const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/imageryUtils-CkENtvf8.js","assets/index-BN8X5Ryz.js","assets/index-CWJhHB6-.css","assets/originUtils-CJnuu7mB.js","assets/datasetUtils-QzMOwZxx.js","assets/utils-BnryXVma.js","assets/saveUtils-CEfw3trS.js"])))=>i.map(i=>d[i]);
import{$S as e,$T as t,A as n,Ai as r,BT as i,Bv as a,CE as o,Di as s,Du as c,Dv as l,En as u,Eu as d,Ex as f,FE as p,GT as m,Ii as h,JT as g,L as _,Li as v,Lx as y,M as b,Ni as ee,O as te,Od as ne,Rh as re,Rv as x,TS as ie,Tu as S,UT as C,Ua as ae,VT as w,WT as T,ZS as E,_ as oe,_E as se,aS as ce,ai as le,ba as ue,bd as de,ca as fe,cp as pe,fE as me,ha as he,hd as ge,iw as D,j as _e,kC as ve,kD as O,kv as k,kw as A,mE as j,pE as ye,pS as be,pa as xe,pd as Se,pv as Ce,qT as we,sT as Te,tT as Ee,uS as De,ua as Oe,vx as ke,xa as Ae,xu as je,y as Me,zh as Ne,zi as Pe}from"./index-BN8X5Ryz.js";import"./memoryEstimations-D_IbKyOk.js";import"./OptimizedGeometry-BQJ7w5VU.js";import"./OptimizedFeatureSet-CLjmRHYn.js";import"./urlUtils-CW4cnJ3W.js";import"./_commonjsHelpers-YBF0zzdz.js";import{n as Fe}from"./imageBitmapUtils-CLE9aRyR.js";import"./memoize-Dl61_jt0.js";import{o as Ie,p as Le,t as Re}from"./elevationInfoUtils-uoMH3ofe.js";import"./generateRendererUtils-DGV_dTnd.js";import"./pbf-CO6WFbVS.js";import"./pbfQueryUtils-CmJPTrN7.js";import"./queryUtils-8f7b9mi_.js";import"./query-BXrgTHrc.js";import{n as ze,r as Be,t as Ve}from"./executeForIds-Dq7stXFh.js";import{n as He}from"./executeQueryJSON-DJO3NDvM.js";import{t as Ue}from"./isImageryGraphicOrigin-b14Iy_JD.js";import{a as We,n as Ge,o as Ke,p as qe,r as Je}from"./multidimensionalUtils-CoDZYrcG.js";import{B as Ye,E as Xe,H as Ze,L as Qe,M as $e,N as et,O as tt,T as nt,U as rt,V as it,k as at,t as ot,z as st}from"./RasterSymbolizer-C04g1f48.js";import{l as ct,t as lt}from"./PixelBlock-D0vUlFM9.js";import{C as ut,o as dt}from"./vectorFieldUtils-BkGOIhR4.js";import{_ as ft,a as pt,c as mt,d as ht,h as gt,i as _t,l as vt,m as yt,n as bt,o as xt,s as St,t as Ct,u as wt,v as M,y as N}from"./RasterJobHandlerMixin-v7ic83Yl.js";import"./colorUtils-CzajW9E7.js";import{a as Tt,c as Et,d as Dt,f as Ot,i as kt,l as At,n as jt,o as Mt,p as Nt,r as Pt,s as Ft,t as It,u as Lt}from"./rasterFieldUtils-D1_HkZOo.js";import"./datasetUtils-QzMOwZxx.js";import"./cimSymbolUtils-CLt57XQ8.js";import"./utils-BGjabRH0.js";import{i as Rt,n as zt,r as Bt,t as Vt}from"./RasterPresetRendererMixin-CKxP1IOk.js";import"./dataUtils-CwkEyGtp.js";var Ht,Ut=class extends ue{get[(Ht=Ue,Ae)](){return this.layer}constructor(e){super(),this[Ht]=!0,this.type=`imagery`,this.layer=e}get id(){return this.layer.id}},Wt={StretchFunction:{arguments:{ComputeGamma:{isDataset:!1,isPublic:!1,name:`ComputeGamma`,type:`RasterFunctionVariable`,value:!1},DRA:{isDataset:!1,isPublic:!1,name:`DRA`,type:`RasterFunctionVariable`,value:!1},EstimateStatsHistogram:{isDataset:!1,isPublic:!1,name:`EstimateStatsHistogram`,type:`RasterFunctionVariable`,value:!1},Gamma:{displayName:`Gamma`,isDataset:!1,isPublic:!1,name:`Gamma`,type:`RasterFunctionVariable`},Histograms:{isDataset:!1,isPublic:!1,name:`Histograms`,type:`RasterFunctionVariable`},Max:{isDataset:!1,isPublic:!1,name:`Max`,type:`RasterFunctionVariable`,value:255},MaxPercent:{isDataset:!1,isPublic:!1,name:`MaxPercent`,type:`RasterFunctionVariable`,value:.5},Min:{isDataset:!1,isPublic:!1,name:`Min`,type:`RasterFunctionVariable`,value:0},MinPercent:{isDataset:!1,isPublic:!1,name:`MinPercent`,type:`RasterFunctionVariable`,value:.25},NumberOfStandardDeviations:{isDataset:!1,isPublic:!1,name:`NumberOfStandardDeviation`,type:`RasterFunctionVariable`,value:2},Raster:{isDataset:!0,isPublic:!1,name:`Raster`,type:`RasterFunctionVariable`},SigmoidStrengthLevel:{isDataset:!1,isPublic:!1,name:`SigmoidStrengthLevel`,type:`RasterFunctionVariable`,value:2},Statistics:{isDataset:!1,isPublic:!1,name:`Statistics`,type:`RasterFunctionVariable`},StretchType:{isDataset:!1,isPublic:!1,name:`StretchType`,type:`RasterFunctionVariable`,value:0},type:`StretchFunctionArguments`,UseGamma:{isDataset:!1,isPublic:!1,name:`UseGamma`,type:`RasterFunctionVariable`,value:!1}},description:`Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.`,function:{description:`Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.`,name:`Stretch`,pixelType:`UNKNOWN`,type:`StretchFunction`},functionType:0,name:`Stretch`,thumbnail:``},RemapFunction:{name:`Remap`,description:`Changes pixel values by assigning new values to ranges of pixel values or using an external table.`,function:{type:`RemapFunction`,pixelType:`UNKNOWN`,name:`Remap`,description:`Changes pixel values by assigning new values to ranges of pixel values or using an external table.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},UseTable:{name:`UseTable`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},InputRanges:{name:`InputRanges`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`Input Ranges`},OutputValues:{name:`OutputValues`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`Output Values`},NoDataRanges:{name:`NoDataRanges`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`,displayName:`NoData Ranges`},Table:{name:`Table`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},InputField:{name:`InputField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},OutputField:{name:`OutputField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},InputMaxField:{name:`InputMaxField`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},RemapTableType:{name:`RemapTableType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},AllowUnmatched:{name:`AllowUnmatched`,isPublic:!1,isDataset:!1,value:!0,type:`RasterFunctionVariable`},type:`RemapFunctionArguments`},functionType:0,thumbnail:``},ColormapFunction:{name:`Colormap`,description:`Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.`,function:{type:`ColormapFunction`,pixelType:`UNKNOWN`,name:`Colormap`,description:`Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ColorSchemeType:{name:`ColorSchemeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},Colormap:{name:`Colormap`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},ColormapName:{name:`ColormapName`,isPublic:!1,isDataset:!1,value:`Gray`,type:`RasterFunctionVariable`},ColorRamp:{name:`ColorRamp`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},type:`ColormapFunctionArguments`},functionType:0,thumbnail:``},ShadedReliefFunction:{name:`Shaded Relief`,description:`Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.`,function:{type:`ShadedReliefFunction`,pixelType:`UNKNOWN`,name:`Shaded Relief`,description:`Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ColorSchemeType:{name:`ColorSchemeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ColorRamp:{name:`ColorRamp`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},HillshadeType:{name:`HillshadeType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},Colormap:{name:`Colormap`,isPublic:!1,isDataset:!1,type:`RasterFunctionVariable`},Azimuth:{name:`Azimuth`,isPublic:!1,isDataset:!1,value:315,type:`RasterFunctionVariable`},Altitude:{name:`Altitude`,isPublic:!1,isDataset:!1,value:45,type:`RasterFunctionVariable`},SlopeType:{name:`SlopeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ZFactor:{name:`ZFactor`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},PSPower:{name:`PSPower`,isPublic:!1,isDataset:!1,value:.664,type:`RasterFunctionVariable`},PSZFactor:{name:`PSZFactor`,isPublic:!1,isDataset:!1,value:.024,type:`RasterFunctionVariable`},RemoveEdgeEffect:{name:`RemoveEdgeEffect`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},type:`ShadedReliefFunctionArguments`},functionType:0,thumbnail:``},HillshadeFunction:{name:`Hillshade`,description:`Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image`,function:{type:`HillshadeFunction`,pixelType:`UNKNOWN`,name:`Hillshade`,description:`Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image`},arguments:{DEM:{name:`DEM`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},HillshadeType:{name:`HillshadeType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},Azimuth:{name:`Azimuth`,isPublic:!1,isDataset:!1,value:315,type:`RasterFunctionVariable`},Altitude:{name:`Altitude`,isPublic:!1,isDataset:!1,value:45,type:`RasterFunctionVariable`},SlopeType:{name:`SlopeType`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},ZFactor:{name:`ZFactor`,isPublic:!1,isDataset:!1,value:1,type:`RasterFunctionVariable`},PSPower:{name:`PSPower`,isPublic:!1,isDataset:!1,value:.664,type:`RasterFunctionVariable`},PSZFactor:{name:`PSZFactor`,isPublic:!1,isDataset:!1,value:.024,type:`RasterFunctionVariable`},RemoveEdgeEffect:{name:`RemoveEdgeEffect`,isPublic:!1,isDataset:!1,value:!1,type:`RasterFunctionVariable`},type:`HillshadeFunctionArguments`},functionType:0,thumbnail:``},ResampleFunction:{name:`Resample`,description:`Changes the cell size of a raster.`,function:{type:`ResampleFunction`,pixelType:`UNKNOWN`,name:`Resample`,description:`Changes the cell size of a raster.`},arguments:{Raster:{name:`Raster`,isPublic:!1,isDataset:!0,type:`RasterFunctionVariable`},ResamplingType:{name:`ResamplingType`,isPublic:!1,isDataset:!1,value:0,type:`RasterFunctionVariable`},InputCellSize:{name:`InputCellsize`,isPublic:!1,isDataset:!1,value:{x:0,y:0},type:`RasterFunctionVariable`},OutputCellSize:{name:`OutputCellsize`,isPublic:!1,isDataset:!1,value:{x:0,y:0},type:`RasterFunctionVariable`},type:`ResampleFunctionArguments`},functionType:0,thumbnail:``}},Gt=new Set([`u1`,`u2`,`u4`,`u8`,`s8`,`u16`,`s16`]),Kt={simple_scalar:`Simple Scalar`,wind_barb:`Wind Barb`,single_arrow:`Single Arrow`,beaufort_kn:`Beaufort Wind (Knots)`,beaufort_m:`Beaufort Wind (MetersPerSecond)`,ocean_current_m:`Ocean Current (MetersPerSecond)`,ocean_current_kn:`Ocean Current (Knots)`},qt=new Set([`raster-stretch`,`unique-value`,`class-breaks`,`raster-shaded-relief`,`vector-field`,`raster-colormap`]);function Jt(e){return qt.has(e.type)}function Yt(e,t){if(!e||!t)return p(e||t);let n=p(e);if(n.functionDefinition&&t.rasterFunctionDefinition){let e=t.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=void 0),Xt(n.functionDefinition.arguments,t),n.rasterFunctionDefinition=n.functionDefinition.toJSON()}else t.functionName?.toLowerCase()!==`none`&&(Qt(n.functionArguments).Raster=t);return n}function Xt(e,t){for(let n in e)n.toLowerCase()===`raster`&&(e[n].type===`RasterFunctionVariable`?(e[n]=t.rasterFunctionDefinition,e[n].type=`RasterFunctionTemplate`):e[n].type===`RasterFunctionTemplate`&&Xt(e[n].arguments,t))}function P(e){let t=p(Wt[e.functionName+`Function`]),n=e.functionArguments;for(let e in n)e.toLowerCase()===`raster`?(t.arguments[e]=P(n[e]),t.arguments[e].type=`RasterFunctionTemplate`):e.toLowerCase()===`colormap`?(t.arguments[e].value=un(n[e]),t.arguments.ColorSchemeType.value=0):t.arguments[e].value=n[e];return t}function Zt(e,t){switch(t||={},e.type){case`raster-stretch`:return nn(e,t);case`class-breaks`:return rn(e,t);case`unique-value`:return sn(e,t);case`raster-colormap`:return ln(e,t);case`vector-field`:return en(e,t);case`raster-shaded-relief`:return tn(e,t);case`flow`:throw Error(`Unsupported rendering rule.`)}}function Qt(e){let t=e?.Raster??e?.raster;return t&&t.declaredClass===`esri.layers.support.RasterFunction`?Qt(t.functionArguments):e}var $t={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function en(e,t){let n=new N;n.functionName=`VectorFieldRenderer`;let{dataType:r,bandNames:i}=t,a=r===`vector-uv`,o,s;if(i?.length===2){let e=i.map(e=>e.toLowerCase());o=e.indexOf(`magnitude`),s=e.indexOf(`direction`)}o!==-1&&o!==null||(o=0,s=1);let c=e.rotationType===`arithmetic`?1:2,l=e.flowRepresentation===`flow-from`?0:1,u=e.visualVariables?e.visualVariables.find(e=>e.field===`Magnitude`):new le;n.functionArguments={magnitudeBandID:o,directionBandID:s,isUVComponents:a,referenceSystem:c,massFlowAngleRepresentation:l,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:`Vector Average`,symbologyName:Kt[e.style.toLowerCase().replace(`-`,`_`)],minimumMagnitude:u.minDataValue,maximumMagnitude:u.maxDataValue,minimumSymbolSize:u.minSize,maximumSymbolSize:u.maxSize};let d=P(n);return t.convertToRFT?N.fromJSON({rasterFunctionDefinition:d}):n}function tn(e,t){let n=t.convertToRFT;if(t.dataType!==`elevation`&&(t.dataType!==`generic`||t.bandCount!==1||t.pixelType!==`s16`&&t.pixelType!==`s32`&&t.pixelType!==`f32`&&t.pixelType!==`f64`))return new N;let r=new N;r.functionName=`Hillshade`;let i=e.hillshadeType===`traditional`?0:1,a=e.scalingType===`none`?1:3,o={HillshadeType:i,SlopeType:a,ZFactor:e.zFactor};return i===0&&(o.Azimuth=e.azimuth,o.Altitude=e.altitude),a===3&&(o.PSPower=e.pixelSizePower,o.PSZFactor=e.pixelSizeFactor),r.functionArguments=o,r.variableName=`Raster`,e.colorRamp&&(r.functionName=`ShadedRelief`,n?o.ColorRamp=$e(e.colorRamp):o.Colormap=at(e.colorRamp)),n?new N({rasterFunctionDefinition:P(r)}):r}function nn(e,t){let n=t.convertToRFT,r=new N;r.functionName=`Stretch`;let i=$t[tt.toJSON(e.stretchType)],a=e.customStatistics?.map(e=>[e.min,e.max,e.avg??0,e.stddev??1]),o={StretchType:i,Statistics:a,DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(e.outputMin!=null&&(o.Min=e.outputMin),e.outputMax!=null&&(o.Max=e.outputMax),i===$t.standardDeviation?(o.NumberOfStandardDeviations=e.numberOfStandardDeviations,r.outputPixelType=`u8`):i===$t.percentClip?(o.MinPercent=e.minPercent,o.MaxPercent=e.maxPercent,r.outputPixelType=`u8`):i===$t.minMax?r.outputPixelType=`u8`:i===$t.sigmoid&&(o.SigmoidStrengthLevel=e.sigmoidStrengthLevel),r.functionArguments=o,r.variableName=`Raster`,e.colorRamp){let i=e.colorRamp,a=new N;if(n)a.functionArguments={ColorRamp:$e(i)};else{let n=Qe(i,!0);if(n)a.functionArguments={colorRampName:n};else if(!t.convertColorRampToColormap||i.type!==`algorithmic`&&i.type!==`multipart`){let t=e.colorRamp.toJSON();t.type===`algorithmic`?t.algorithm=t.algorithm||`esriCIELabAlgorithm`:t.type===`multipart`&&t.colorRamps?.length&&t.colorRamps.forEach(e=>e.algorithm=e.algorithm||`esriCIELabAlgorithm`),a.functionArguments={colorRamp:t}}else a.functionArguments={Colormap:at(i)}}return a.variableName=`Raster`,a.functionName=`Colormap`,a.functionArguments.Raster=r,n?new N({rasterFunctionDefinition:P(a)}):a}return n?new N({rasterFunctionDefinition:P(r)}):r}function rn(e,t){let n=[],r=[],i=[],a=[],o=1e-4,{pixelType:s,rasterAttributeTable:c}=t,l=c==null?null:c.features,u=on(c);if(u&&l&&Array.isArray(l)&&e.classBreakInfos){e.classBreakInfos.forEach((t,n)=>{let r=t.symbol?.color,i;r?.a&&t.minValue!=null&&t.maxValue!=null&&l.forEach(o=>{t.minValue!=null&&t.maxValue!=null&&(i=o.attributes[e.field],(i>=t.minValue&&i<t.maxValue||n===e.classBreakInfos.length-1&&i>=t.minValue)&&a.push([o.attributes[u],r.r,r.g,r.b]))})});let n=s?an(a,s):a,r=new N;return r.functionName=`Colormap`,r.functionArguments={},r.functionArguments.Colormap=n,r.variableName=`Raster`,t.convertToRFT?new N({rasterFunctionDefinition:P(r)}):r}e.classBreakInfos.forEach((e,t)=>{if(e.minValue==null||e.maxValue==null)return;let s=e.symbol&&e.symbol.color;s?.a?(t===0?n.push(e.minValue,e.maxValue+o):n.push(e.minValue+o,e.maxValue+o),r.push(t),a.push([t,s.r,s.g,s.b])):i.push(e.minValue,e.maxValue)});let d=s?an(a,s):a,f=new N;f.functionName=`Remap`,f.functionArguments={InputRanges:n,OutputValues:r,NoDataRanges:i},f.variableName=`Raster`;let p=new N;return p.functionName=`Colormap`,p.functionArguments={Colormap:d,Raster:f},t.convertToRFT?new N({rasterFunctionDefinition:P(p)}):p}function an(e,t){let n=Gt.has(t)?ct(t):null;return n&&e.push([Math.floor(n[0]-1),0,0,0],[Math.ceil(n[1]+1),0,0,0]),e}function on(e){if(e==null)return;let{fields:t}=e;return t?.find(e=>e?.name&&e.name.toLowerCase()===`value`)?.name}function sn(e,t){let n=[],{pixelType:r,rasterAttributeTable:i}=t,a=i==null?null:i.features,o=on(i),s=e.defaultSymbol?.color?.toRgb(),c=e.uniqueValueInfos;if(c)if(a){if(o){let t=new Map;c.forEach(e=>{let n=e.value,r=cn(e);n!=null&&r?.a&&t.set(String(n),r.toRgb())});let r=e.field;r&&a.forEach(({attributes:e})=>{let i=String(e[r]),a=e[o],c=t.get(i);c?n.push([a,...c]):s&&n.push([a,...s])})}}else for(let e=0;e<c.length;e++){let t=c[e],r=cn(t),i=+t.value;if(r?.a){if(isNaN(i))return null;n.push([i,r.r,r.g,r.b])}}let l=r?an(n,r):n,u=new N;return u.functionName=`Colormap`,u.functionArguments={},u.functionArguments.Colormap=l,u.variableName=`Raster`,t.convertToRFT?new N({rasterFunctionDefinition:P(u)}):u}function cn(e){return e.symbol?.type===`polygon-3d`?e.symbol.symbolLayers?.find(e=>e.type===`fill`)?.material?.color:e.symbol?.color}function ln(e,t){let n=e.extractColormap();if(!n||n.length===0)return null;let{pixelType:r}=t,i=r?an(n,r):n,a=new N;return a.functionName=`Colormap`,a.functionArguments={},a.functionArguments.Colormap=i,t.convertToRFT?new N({rasterFunctionDefinition:P(a)}):a}function un(e){let t=[],n=[];return e.forEach(e=>{t.push(e[0]),n.push(et([...e.slice(1),255]))}),{type:`RasterColormap`,values:t,colors:n}}var F=class extends D{constructor(){super(...arguments),this.layer=null,this.requestRawData=!1,this.compression=void 0,this.lercVersion=2}get adjustAspectRatio(){return this.layer.adjustAspectRatio}writeAdjustAspectRatio(e,t,n){this.layer.version<10.3||(t[n]=e)}get bandIds(){return this.layer.bandIds}get compressionQuality(){return this.layer.compressionQuality}writeCompressionQuality(e,t,n){this.format&&this.format.toLowerCase().includes(`jpg`)&&e!=null&&(t[n]=e)}get compressionTolerance(){return this.layer.compressionTolerance}writeCompressionTolerance(e,t,n){this.format===`lerc`&&e!=null&&(t[n]=e)}get format(){return this.requestRawData||this.layer.renderer?.type===`vector-field`?`lerc`:this.layer.format}get interpolation(){return this.layer.interpolation}get noData(){return this.layer.noData}get noDataInterpretation(){return this.layer.noDataInterpretation}get pixelType(){let{layer:e}=this;return e.pixelType===e.serviceRasterInfo.pixelType?void 0:e.pixelType}writeLercVersion(e,t,n){this.format===`lerc`&&this.layer.version>=10.5&&(t[n]=e)}get version(){let e=this.layer;return e.commitProperty(`bandIds`),e.commitProperty(`format`),e.commitProperty(`compressionQuality`),e.commitProperty(`compressionTolerance`),e.commitProperty(`interpolation`),e.commitProperty(`noData`),e.commitProperty(`noDataInterpretation`),e.commitProperty(`mosaicRule`),e.commitProperty(`rasterFunction`),e.commitProperty(`adjustAspectRatio`),e.commitProperty(`pixelFilter`),e.commitProperty(`pixelType`),e.commitProperty(`definitionExpression`),e.commitProperty(`multidimensionalSubset`),(this._get(`version`)||0)+1}set version(e){this._set(`version`,e)}get mosaicRule(){let e=this.layer,t=e.mosaicRule,n=e.definitionExpression;return t?n&&n!==t.where&&(t=t.clone(),t.where=n):n&&(t=new M({where:n})),t}get rasterFunction(){let e=this.layer,{rasterFunction:t}=e,n=e.pixelFilter,r=!e.format||e.format.includes(`jpg`)||e.format.includes(`png`);this.requestRawData||(t=this._addResampleRasterFunction(t));let i=e.multidimensionalSubset?.areaOfInterest;return i&&(t=dn(t,i)),this.requestRawData||!r||n||e.renderer?.type===`vector-field`||(t=this.combineRendererWithRenderingRule(t)),t}combineRendererWithRenderingRule(e){let t=this.layer,{rasterInfo:n,renderer:r}=t;return e||=t.rasterFunction,!r||!Jt(r)?e:Yt(Zt(r,{rasterAttributeTable:n.attributeTable,pixelType:n.pixelType,dataType:n.dataType,bandNames:n.bandInfos.map(({name:e})=>e),convertColorRampToColormap:t.version<10.6,convertToRFT:!!e?.rasterFunctionDefinition,bandCount:n.bandCount}),e)}_addResampleRasterFunction(e){if(this.layer.renderer?.type!==`vector-field`||e?.functionName===`Resample`)return e;let t=this.layer.serviceDataType===`esriImageServiceDataTypeVector-UV`?7:10,n=this.layer.serviceRasterInfo.pixelSize,r=new N({functionName:`Resample`,functionArguments:{ResamplingType:t,InputCellSize:n}});return r=e?.rasterFunctionDefinition?new N({rasterFunctionDefinition:P(r)}):r,Yt(r,e)}};function dn(e,t){let n=new N({functionName:`Clip`,functionArguments:{ClippingGeometry:t.toJSON(),ClippingType:1}});return Yt(n,e)}O([i()],F.prototype,`layer`,void 0),O([i()],F.prototype,`requestRawData`,void 0),O([i({json:{write:!0}})],F.prototype,`adjustAspectRatio`,null),O([C(`adjustAspectRatio`)],F.prototype,`writeAdjustAspectRatio`,null),O([i({json:{write:!0}})],F.prototype,`bandIds`,null),O([i({json:{write:!0}})],F.prototype,`compression`,void 0),O([i({json:{write:!0}})],F.prototype,`compressionQuality`,null),O([C(`compressionQuality`)],F.prototype,`writeCompressionQuality`,null),O([i({json:{write:!0}})],F.prototype,`compressionTolerance`,null),O([C(`compressionTolerance`)],F.prototype,`writeCompressionTolerance`,null),O([i({json:{write:!0}})],F.prototype,`format`,null),O([i({type:String,json:{read:{reader:st.read},write:{writer:st.write}}})],F.prototype,`interpolation`,null),O([i({json:{write:!0}})],F.prototype,`noData`,null),O([i({type:String,json:{read:{reader:Ye.read},write:{writer:Ye.write}}})],F.prototype,`noDataInterpretation`,null),O([i({type:it.apiValues,json:{read:it.read,write:it.write}})],F.prototype,`pixelType`,null),O([i({json:{write:!0}})],F.prototype,`lercVersion`,void 0),O([C(`lercVersion`)],F.prototype,`writeLercVersion`,null),O([i({type:Number})],F.prototype,`version`,null),O([i({json:{write:!0}})],F.prototype,`mosaicRule`,null),O([i({json:{write:!0,name:`renderingRule`}})],F.prototype,`rasterFunction`,null),F=O([w(`esri.layers.support.ExportImageServiceParameters`)],F);var I=class extends A(D){constructor(e){super(e),this.fromGeometry=null,this.toGeometry=null,this.objectIds=null,this.where=null,this.maxCount=null}};O([i({type:f,json:{read:!0}})],I.prototype,`fromGeometry`,void 0),O([i({type:f,json:{read:!0,write:!0}})],I.prototype,`toGeometry`,void 0),O([i({json:{write:!0}})],I.prototype,`objectIds`,void 0),O([i({type:String,json:{write:!0}})],I.prototype,`where`,void 0),O([i({type:Number,json:{write:!0}})],I.prototype,`maxCount`,void 0),I=O([w(`esri.rest.support.FindImagesParameters`)],I);var fn=e=>{let t=e,n=class extends t{constructor(){super(...arguments),this.make=null,this.model=null,this.focalLength=null,this.pixelSize=null,this.rows=null,this.cols=null}};return O([i({json:{write:!0}})],n.prototype,`make`,void 0),O([i({json:{write:!0}})],n.prototype,`model`,void 0),O([i({json:{write:!0}})],n.prototype,`focalLength`,void 0),O([i({json:{write:!0}})],n.prototype,`pixelSize`,void 0),O([i({json:{write:!0}})],n.prototype,`rows`,void 0),O([i({json:{write:!0}})],n.prototype,`cols`,void 0),n=O([w(`esri.rest.support.CameraInfoMixin`)],n),n},L=class extends fn(D){constructor(){super(...arguments),this.id=null,this.referenceUri=null,this.acquisitionDate=null,this.cameraID=null,this.center=null,this.perspectiveCenter=null,this.orientation=null}writeAcquisitionDate(e,t){t.acquisitionDate=e?.getTime()}};O([i({json:{write:!0}})],L.prototype,`id`,void 0),O([i({json:{name:`uri`,write:!0}})],L.prototype,`referenceUri`,void 0),O([i({type:Date,json:{write:!0}})],L.prototype,`acquisitionDate`,void 0),O([C(`acquisitionDate`)],L.prototype,`writeAcquisitionDate`,null),O([i({json:{write:!0}})],L.prototype,`cameraID`,void 0),O([i({type:f,json:{write:!0}})],L.prototype,`center`,void 0),O([i({type:f,json:{write:!0}})],L.prototype,`perspectiveCenter`,void 0),O([i({json:{write:!0}})],L.prototype,`orientation`,void 0),L=O([w(`esri.rest.support.ImageInspectionInfo`)],L);var pn=L,mn=class extends D{constructor(e){super(e),this.images=null}};O([i({type:[pn],json:{write:!0}})],mn.prototype,`images`,void 0),mn=O([w(`esri.rest.support.FindImagesResult`)],mn);var hn,gn=hn=class extends D{constructor(e){super(e),this.angleNames=null,this.point=null,this.spatialReference=null,this.rasterId=null}clone(){return new hn(p({angleNames:this.angleNames,point:this.point,spatialReference:this.spatialReference,rasterId:this.rasterId}))}};O([i({type:[String],json:{name:`angleName`,write:!0}})],gn.prototype,`angleNames`,void 0),O([i({type:f,json:{write:!0}})],gn.prototype,`point`,void 0),O([i({type:y,json:{write:!0}})],gn.prototype,`spatialReference`,void 0),O([i({type:se,json:{write:!0}})],gn.prototype,`rasterId`,void 0),gn=hn=O([w(`esri.rest.support.ImageAngleParameters`)],gn);var _n=class extends D{constructor(e){super(e),this.north=null,this.up=null,this.spatialReference=null}};O([i({type:Number,json:{write:!0}})],_n.prototype,`north`,void 0),O([i({type:Number,json:{write:!0}})],_n.prototype,`up`,void 0),O([i({type:y,json:{write:!0}})],_n.prototype,`spatialReference`,void 0),_n=O([w(`esri.rest.support.ImageAngleResult`)],_n);var R=new we({esriMensurationPoint:`point`,esriMensurationCentroid:`centroid`,esriMensurationDistanceAndAngle:`distance-and-angle`,esriMensurationAreaAndPerimeter:`area-and-perimeter`,esriMensurationHeightFromBaseAndTop:`base-and-top`,esriMensurationHeightFromBaseAndTopShadow:`base-and-top-shadow`,esriMensurationHeightFromTopAndTopShadow:`top-and-top-shadow`,esriMensurationPoint3D:`point-3D`,esriMensurationCentroid3D:`centroid-3D`,esriMensurationDistanceAndAngle3D:`distance-and-angle-3D`,esriMensurationAreaAndPerimeter3D:`area-and-perimeter-3D`}),z=class extends D{constructor(e){super(e),this.type=null,this.measureOperation=null,this.mosaicRule=null,this.pixelSize=null,this.raster=void 0}};O([i()],z.prototype,`type`,void 0),O([i({type:R.apiValues,json:{read:R.read,write:R.write}})],z.prototype,`measureOperation`,void 0),O([i({type:M,json:{write:!0}})],z.prototype,`mosaicRule`,void 0),O([i({type:f,json:{write:!0}})],z.prototype,`pixelSize`,void 0),O([i({json:{write:!0}})],z.prototype,`raster`,void 0),z=O([w(`esri.rest.support.BaseImageMeasureParameters`)],z);var vn,B=vn=class extends z{constructor(e){super(e),this.type=`area-perimeter`,this.geometry=null,this.is3D=!1,this.linearUnit=`meters`,this.areaUnit=`square-meters`}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=e.toJSON())}get measureOperation(){return this.is3D?`area-and-perimeter-3D`:`area-and-perimeter`}clone(){return new vn(p({geometry:this.geometry,is3D:this.is3D,linearUnit:this.linearUnit,areaUnit:this.areaUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};O([i({types:l,json:{name:`fromGeometry`,read:!0,write:!0}})],B.prototype,`geometry`,void 0),O([C(`geometry`)],B.prototype,`writeGeometry`,null),O([i({type:R.apiValues,json:{write:R.write}})],B.prototype,`measureOperation`,null),O([i({json:{read:!0}})],B.prototype,`is3D`,void 0),O([i({type:String,json:{read:be.read,write:be.write}})],B.prototype,`linearUnit`,void 0),O([i({type:String,json:{read:De.read,write:De.write}})],B.prototype,`areaUnit`,void 0),B=vn=O([w(`esri.rest.support.ImageAreaParameters`)],B);var V=class extends D{constructor(e){super(e),this.name=null,this.sensorName=null}};O([i({type:String,json:{read:!0,write:!0}})],V.prototype,`name`,void 0),O([i({type:String,json:{read:!0,write:!0}})],V.prototype,`sensorName`,void 0),V=O([w(`esri.rest.support.BaseImageMeasureResult`)],V);var H=class extends D{constructor(){super(...arguments),this.value=null,this.displayValue=null,this.uncertainty=null}};O([i({type:String})],H.prototype,`unit`,void 0),O([i({type:Number,json:{read:!0,write:!0}})],H.prototype,`value`,void 0),O([i({type:String,json:{read:!0,write:!0}})],H.prototype,`displayValue`,void 0),O([i({type:Number,json:{read:!0,write:!0}})],H.prototype,`uncertainty`,void 0),H=O([w(`esri.rest.support.BaseImageMeasureResultValue`)],H);var yn=class extends H{constructor(){super(...arguments),this.unit=null}};O([i({json:{read:De.read,write:De.write}})],yn.prototype,`unit`,void 0),yn=O([g(`esri.rest.support.ImageMeasureResultAreaValue`)],yn);var bn=class extends H{constructor(){super(...arguments),this.unit=null}};O([i({json:{read:be.read,write:be.write}})],bn.prototype,`unit`,void 0),bn=O([w(`esri.rest.support.ImageMeasureResultLengthValue`)],bn);var xn=class extends V{constructor(e){super(e),this.area=null,this.perimeter=null}};O([i({type:yn,json:{read:!0,write:!0}})],xn.prototype,`area`,void 0),O([i({type:bn,json:{read:!0,write:!0}})],xn.prototype,`perimeter`,void 0),xn=O([w(`esri.rest.support.ImageAreaResult`)],xn);var Sn=class extends A(D){constructor(e){super(e),this.outSpatialReference=null}};O([i({type:y,json:{name:`outSR`,write:!0}})],Sn.prototype,`outSpatialReference`,void 0),Sn=O([w(`esri.rest.support.ImageBoundaryParameters`)],Sn);var Cn=class extends D{constructor(e){super(e),this.area=null,this.geometry=null}readGeometry(e,t){return e==null?null:e.rings?a.fromJSON(e):ke.fromJSON(e)}};O([i({type:Number,json:{write:!0}})],Cn.prototype,`area`,void 0),O([i({types:l,json:{name:`shape`,write:!0}})],Cn.prototype,`geometry`,void 0),O([T(`geometry`)],Cn.prototype,`readGeometry`,null),Cn=O([w(`esri.rest.support.ImageBoundaryResult`)],Cn);var wn,U=wn=class extends z{constructor(e){super(e),this.type=`distance-angle`,this.fromGeometry=null,this.toGeometry=null,this.is3D=!1,this.linearUnit=`meters`,this.angularUnit=`degrees`}writeFromGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=e.toJSON())}get measureOperation(){return this.is3D?`distance-and-angle-3D`:`distance-and-angle`}clone(){return new wn(p({fromGeometry:this.fromGeometry,toGeometry:this.toGeometry,is3D:this.is3D,linearUnit:this.linearUnit,angularUnit:this.angularUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};O([i({type:f,json:{read:!0,write:!0}})],U.prototype,`fromGeometry`,void 0),O([C(`fromGeometry`)],U.prototype,`writeFromGeometry`,null),O([i({type:f,json:{read:!0,write:!0}})],U.prototype,`toGeometry`,void 0),O([i({type:R.apiValues,json:{write:R.write}})],U.prototype,`measureOperation`,null),O([i({json:{read:!0}})],U.prototype,`is3D`,void 0),O([i({type:String,json:{read:be.read,write:be.write}})],U.prototype,`linearUnit`,void 0),O([i({type:String,json:{read:ce.read,write:ce.write}})],U.prototype,`angularUnit`,void 0),U=wn=O([w(`esri.rest.support.ImageDistanceParameters`)],U);var Tn=class extends H{constructor(){super(...arguments),this.unit=null}};O([i({json:{read:ce.read,write:ce.write}})],Tn.prototype,`unit`,void 0),Tn=O([w(`esri.rest.support.ImageMeasureResultAngleValue`)],Tn);var En=class extends V{constructor(e){super(e),this.distance=null,this.azimuthAngle=null,this.elevationAngle=null}};O([i({type:bn,json:{read:!0,write:!0}})],En.prototype,`distance`,void 0),O([i({type:Tn,json:{read:!0,write:!0}})],En.prototype,`azimuthAngle`,void 0),O([i({type:Tn,json:{read:!0,write:!0}})],En.prototype,`elevationAngle`,void 0),En=O([w(`esri.rest.support.ImageDistanceResult`)],En);var W=class extends A(D){constructor(e){super(e),this.geometry=null,this.objectIds=null,this.spatialRelationship=`intersects`,this.timeExtent=null,this.where=null}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=JSON.stringify(e.toJSON()))}};O([i({types:l,json:{read:k,write:!0}})],W.prototype,`geometry`,void 0),O([C(`geometry`)],W.prototype,`writeGeometry`,null),O([i({json:{write:!0}})],W.prototype,`objectIds`,void 0),O([m(ge,{ignoreUnknown:!1,name:`spatialRel`})],W.prototype,`spatialRelationship`,void 0),O([i({type:Ne,json:{name:`time`,write:!0}})],W.prototype,`timeExtent`,void 0),O([i({type:String,json:{write:!0}})],W.prototype,`where`,void 0),W=O([w(`esri.rest.support.ImageGPSInfoParameters`)],W);var Dn=class extends fn(D){constructor(){super(...arguments),this.id=null}};O([i({json:{write:!0}})],Dn.prototype,`id`,void 0),Dn=O([w(`esri.rest.support.CameraInfo`)],Dn);var On=Dn,G=class extends D{constructor(){super(...arguments),this.id=null,this.name=null,this.acquisitionDate=null,this.cameraID=null,this.center=null,this.gps=null,this.orientation=null}writeAcquisitionDate(e,t){t.acquisitionDate=e?.getTime()}};O([i({json:{write:!0}})],G.prototype,`id`,void 0),O([i({json:{write:!0}})],G.prototype,`name`,void 0),O([i({type:Date,json:{write:!0}})],G.prototype,`acquisitionDate`,void 0),O([C(`acquisitionDate`)],G.prototype,`writeAcquisitionDate`,null),O([i({json:{write:!0}})],G.prototype,`cameraID`,void 0),O([i({type:f,json:{write:!0}})],G.prototype,`center`,void 0),O([i({json:{write:!0}})],G.prototype,`gps`,void 0),O([i({json:{write:!0}})],G.prototype,`orientation`,void 0),G=O([w(`esri.rest.support.ImageGPSInfo`)],G);var kn=G,An=class extends D{constructor(e){super(e),this.images=null,this.cameras=null}};O([i({type:[kn],json:{write:!0}})],An.prototype,`images`,void 0),O([i({type:[On],json:{write:!0}})],An.prototype,`cameras`,void 0),An=O([w(`esri.rest.support.ImageGPSInfoResult`)],An);var jn,K=jn=class extends z{constructor(e){super(e),this.type=`height`,this.fromGeometry=null,this.toGeometry=null,this.operationType=`base-and-top`,this.linearUnit=`meters`}writeFromGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=e.toJSON())}get measureOperation(){return this.operationType}clone(){return new jn(p({fromGeometry:this.fromGeometry,toGeometry:this.toGeometry,operationType:this.operationType,linearUnit:this.linearUnit,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};O([i({type:f,json:{read:!0}})],K.prototype,`fromGeometry`,void 0),O([C(`fromGeometry`)],K.prototype,`writeFromGeometry`,null),O([i({type:f,json:{read:!0,write:!0}})],K.prototype,`toGeometry`,void 0),O([i({type:R.apiValues,json:{write:R.write}})],K.prototype,`measureOperation`,null),O([i({json:{read:!0}})],K.prototype,`operationType`,void 0),O([i({type:String,json:{read:be.read,write:be.write}})],K.prototype,`linearUnit`,void 0),K=jn=O([w(`esri.rest.support.ImageHeightParameters`)],K);var Mn=class extends V{constructor(e){super(e),this.height=null}};O([i({type:bn,json:{read:!0,write:!0}})],Mn.prototype,`height`,void 0),Mn=O([w(`esri.rest.support.ImageHeightResult`)],Mn);var Nn,q=Nn=class extends D{constructor(e){super(e),this.geometry=null,this.rasterFunctions=null,this.pixelSize=null,this.returnGeometry=!0,this.returnCatalogItems=!0,this.returnPixelValues=!0,this.maxItemCount=null,this.timeExtent=null,this.raster=void 0,this.viewId=void 0,this.processAsMultidimensional=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=JSON.stringify(e.toJSON()))}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=M.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set(`mosaicRule`,t)}writeMosaicRule(e,t,n){e!=null&&(t[n]=JSON.stringify(e.toJSON()))}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=N.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set(`rasterFunction`,t)}writeRasterFunction(e,t,n){e!=null&&(t[n]=JSON.stringify(e.toJSON())),e.rasterFunctionDefinition&&(t[n]=JSON.stringify(e.rasterFunctionDefinition))}writeRasterFunctions(e,t,n){e!=null&&(t[n]=JSON.stringify(e.map(e=>e.rasterFunctionDefinition||e.toJSON())))}writePixelSize(e,t,n){e!=null&&(t[n]=JSON.stringify(e))}writeTimeExtent(e,t,n){if(e!=null){let r=e.start==null?null:e.start.getTime(),i=e.end==null?null:e.end.getTime();t[n]=r==null?null:i==null?`${r}`:`${r},${i}`}}clone(){return new Nn(p({geometry:this.geometry,mosaicRule:this.mosaicRule,rasterFunction:this.rasterFunction,rasterFunctions:this.rasterFunctions,pixelSize:this.pixelSize,returnGeometry:this.returnGeometry,returnCatalogItems:this.returnCatalogItems,returnPixelValues:this.returnPixelValues,maxItemCount:this.maxItemCount,processAsMultidimensional:this.processAsMultidimensional,raster:this.raster,viewId:this.viewId,timeExtent:this.timeExtent}))}};O([i({types:l,json:{write:!0}})],q.prototype,`geometry`,void 0),O([C(`geometry`)],q.prototype,`writeGeometry`,null),O([i({type:M,json:{write:!0}})],q.prototype,`mosaicRule`,null),O([C(`mosaicRule`)],q.prototype,`writeMosaicRule`,null),O([i({type:N,json:{write:!0,name:`renderingRule`}})],q.prototype,`rasterFunction`,null),O([C(`rasterFunction`)],q.prototype,`writeRasterFunction`,null),O([i({type:[N],json:{write:!0,name:`renderingRules`}})],q.prototype,`rasterFunctions`,void 0),O([C(`rasterFunctions`)],q.prototype,`writeRasterFunctions`,null),O([i({type:f,json:{write:!0}})],q.prototype,`pixelSize`,void 0),O([C(`pixelSize`)],q.prototype,`writePixelSize`,null),O([i({type:Boolean,json:{write:!0}})],q.prototype,`returnGeometry`,void 0),O([i({type:Boolean,json:{write:!0}})],q.prototype,`returnCatalogItems`,void 0),O([i({type:Boolean,json:{write:!0}})],q.prototype,`returnPixelValues`,void 0),O([i({type:Number,json:{write:!0}})],q.prototype,`maxItemCount`,void 0),O([i({type:Ne,json:{write:{target:`time`}}})],q.prototype,`timeExtent`,void 0),O([C(`timeExtent`)],q.prototype,`writeTimeExtent`,null),O([i({json:{write:!0}})],q.prototype,`raster`,void 0),O([i({json:{write:!0}})],q.prototype,`viewId`,void 0),O([i({type:Boolean,json:{write:!0}})],q.prototype,`processAsMultidimensional`,void 0),q=Nn=O([w(`esri.rest.support.ImageIdentifyParameters`)],q);var J=class extends D{constructor(e){super(e),this.catalogItemVisibilities=null,this.catalogItems=null,this.location=null,this.name=null,this.objectId=null,this.processedValues=null,this.properties=null,this.value=null}};O([i({json:{write:!0}})],J.prototype,`catalogItemVisibilities`,void 0),O([i({type:he,json:{write:!0}})],J.prototype,`catalogItems`,void 0),O([i({type:f,json:{write:!0}})],J.prototype,`location`,void 0),O([i({json:{write:!0}})],J.prototype,`name`,void 0),O([i({json:{write:!0}})],J.prototype,`objectId`,void 0),O([i({json:{write:!0}})],J.prototype,`processedValues`,void 0),O([i({json:{write:!0}})],J.prototype,`properties`,void 0),O([i({json:{write:!0}})],J.prototype,`value`,void 0),J=O([w(`esri.rest.support.ImageIdentifyResult`)],J);var Pn,Fn=Pn=class extends D{constructor(e){super(e),this.geometries=null,this.rasterId=null}writeGeometry(e,t,n){t.geometries={geometryType:`esriGeometryPoint`,geometries:e.map(e=>e.toJSON())}}clone(){return new Pn({geometries:this.geometries?.map(e=>e.clone())??[],rasterId:this.rasterId})}};O([i({type:[f],json:{write:!0}})],Fn.prototype,`geometries`,void 0),O([C(`geometries`)],Fn.prototype,`writeGeometry`,null),O([i({type:se,json:{write:!0}})],Fn.prototype,`rasterId`,void 0),Fn=Pn=O([w(`esri.rest.support.ImagePixelLocationParameters`)],Fn);var In=class extends D{constructor(e){super(e),this.geometries=null}};O([i({json:{write:!0}})],In.prototype,`geometries`,void 0),In=O([w(`esri.rest.support.ImagePixelLocationResult`)],In);var Ln,Rn=Ln=class extends z{constructor(e){super(e),this.type=`point`,this.geometry=null,this.is3D=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=e.toJSON())}get measureOperation(){let{is3D:e,geometry:t}=this;return t.type===`point`?e?`point-3D`:`point`:e?`centroid-3D`:`centroid`}clone(){return new Ln(p({geometry:this.geometry,is3D:this.is3D,mosaicRule:this.mosaicRule,pixelSize:this.pixelSize,raster:this.raster}))}};O([i({types:l,json:{name:`fromGeometry`,read:k}})],Rn.prototype,`geometry`,void 0),O([C(`geometry`)],Rn.prototype,`writeGeometry`,null),O([i({type:R.apiValues,json:{read:R.read,write:R.write}})],Rn.prototype,`measureOperation`,null),O([i({json:{read:!0}})],Rn.prototype,`is3D`,void 0),Rn=Ln=O([w(`esri.rest.support.ImagePointParameters`)],Rn);var zn=class extends V{constructor(e){super(e),this.point=null}};O([i({type:f,json:{name:`point.value`,read:!0,write:!0}})],zn.prototype,`point`,void 0),zn=O([w(`esri.rest.support.ImagePointResult`)],zn);var Bn=class extends A(D){constructor(e){super(e),this.geometries=[],this.rasterIds=null,this.outSpatialReference=null}writeGeometries(e,t,n){t.geometries=e?.length?{geometryType:x(e[0]),geometries:e.map(e=>({...e.toJSON(),spatialReference:void 0}))}:null}};O([i({types:[l]})],Bn.prototype,`geometries`,void 0),O([C(`geometries`)],Bn.prototype,`writeGeometries`,null),O([i({type:[se],json:{write:!0}})],Bn.prototype,`rasterIds`,void 0),O([i({type:y,json:{name:`outSR`,write:!0}})],Bn.prototype,`outSpatialReference`,void 0),Bn=O([w(`esri.rest.support.ImageToMapMultirayParameters`)],Bn);var Y=class extends A(D){constructor(e){super(e),this.geometry=null,this.rasterId=null,this.outSpatialReference=null,this.depthOffset=0,this.adjust=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]={...e.toJSON(),spatialReference:void 0})}};O([i({types:l,json:{read:k,write:!0}})],Y.prototype,`geometry`,void 0),O([C(`geometry`)],Y.prototype,`writeGeometry`,null),O([i({json:{write:!0}})],Y.prototype,`rasterId`,void 0),O([i({type:y,json:{name:`outSR`,write:!0}})],Y.prototype,`outSpatialReference`,void 0),O([i({json:{name:`options.DOff`,write:!0}})],Y.prototype,`depthOffset`,void 0),O([i({json:{name:`options.Adjust`,write:!0}})],Y.prototype,`adjust`,void 0),Y=O([w(`esri.rest.support.ImageToMapParameters`)],Y);var Vn=class extends A(D){constructor(e){super(e),this.referenceUri=null,this.rasterId=null}};O([i({type:String,json:{name:`uri`,write:!0}})],Vn.prototype,`referenceUri`,void 0),O([i({type:Number,json:{write:!0}})],Vn.prototype,`rasterId`,void 0),Vn=O([w(`esri.rest.support.ImageUrlParameters`)],Vn);var Hn=class extends D{constructor(e){super(e),this.url=null}};O([i({json:{name:`imageURL`,write:!0}})],Hn.prototype,`url`,void 0),Hn=O([w(`esri.rest.support.ImageUrlResult`)],Hn);var Un=new we({0:`constant`,1:`plane`,2:`minimum`,3:`maximum`,4:`average`},{useNumericKeys:!0}),X=class extends A(D){constructor(){super(...arguments),this.geometries=[],this.mosaicRule=null,this.pixelSize=null,this.constantZ=null,this.baseType=`plane`}writeGeometries(e,t,n){e?.length&&(t.geometryType=x(e[0]),t.geometries=e.map(e=>e.toJSON()))}};O([i({types:[l]})],X.prototype,`geometries`,void 0),O([C(`geometries`)],X.prototype,`writeGeometries`,null),O([i({type:M,json:{write:!0}})],X.prototype,`mosaicRule`,void 0),O([i({type:f,json:{write:!0}})],X.prototype,`pixelSize`,void 0),O([i({json:{write:!0}})],X.prototype,`constantZ`,void 0),O([i({type:Un.apiValues,json:{read:Un.read,write:Un.write}})],X.prototype,`baseType`,void 0),X=O([w(`esri.rest.support.ImageVolumeParameters`)],X);var Z=class extends D{constructor(){super(...arguments),this.area=null,this.cut=null,this.fill=null,this.maxZ=null,this.minZ=null,this.meanZ=null,this.cutCellCount=null,this.fillCellCount=null}};O([i({json:{write:!0}})],Z.prototype,`area`,void 0),O([i({json:{write:!0}})],Z.prototype,`cut`,void 0),O([i({json:{write:!0}})],Z.prototype,`fill`,void 0),O([i({json:{name:`maxz`,write:!0}})],Z.prototype,`maxZ`,void 0),O([i({json:{name:`minz`,write:!0}})],Z.prototype,`minZ`,void 0),O([i({json:{name:`meanz`,write:!0}})],Z.prototype,`meanZ`,void 0),O([i({json:{write:!0}})],Z.prototype,`cutCellCount`,void 0),O([i({json:{write:!0}})],Z.prototype,`fillCellCount`,void 0),Z=O([w(`esri.rest.support.ImageVolume`)],Z);var Wn=Z,Gn=class extends D{constructor(e){super(e),this.volumes=[]}};O([i({type:[Wn],json:{write:!0}})],Gn.prototype,`volumes`,void 0),Gn=O([w(`esri.rest.support.ImageVolumeResult`)],Gn);var Kn=class extends A(D){constructor(e){super(e),this.geometry=null,this.rasterId=null,this.visibleOnly=!1}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]=JSON.stringify(e))}};O([i({types:l,json:{read:k,write:!0}})],Kn.prototype,`geometry`,void 0),O([C(`geometry`)],Kn.prototype,`writeGeometry`,null),O([i({json:{write:!0}})],Kn.prototype,`rasterId`,void 0),O([i({json:{name:`options.VisibleOnly`,write:!0}})],Kn.prototype,`visibleOnly`,void 0),Kn=O([w(`esri.rest.support.MapToImageParameters`)],Kn);var qn=class extends D{constructor(e){super(e),this.geometry=null,this.length=null,this.area=null,this.center=null}readCenter(e,t){return e.spatialReference||(e={...e,spatialReference:t.Shape.spatialReference}),f.fromJSON(e)}};O([i({types:l,json:{name:`Shape`,read:k,write:!0}})],qn.prototype,`geometry`,void 0),O([i({json:{name:`Length`,write:!0}})],qn.prototype,`length`,void 0),O([i({json:{name:`Area`,write:!0}})],qn.prototype,`area`,void 0),O([i({type:f,json:{name:`Center`,write:!0}})],qn.prototype,`center`,void 0),O([T(`center`)],qn.prototype,`readCenter`,null),qn=O([w(`esri.rest.support.MeasureAreaFromImageResult`)],qn);var Jn,Yn=Jn=class extends D{constructor(e){super(e),this.geometry=null,this.rasterId=void 0}writeGeometry(e,t,n){e!=null&&(t.geometryType=x(e),t[n]={...e.toJSON(),spatialReference:void 0})}clone(){let e=p({geometry:this.geometry,rasterId:this.rasterId});return new Jn(e)}};O([i({types:l,json:{name:`fromGeometry`,read:k,write:!0}})],Yn.prototype,`geometry`,void 0),O([C(`geometry`)],Yn.prototype,`writeGeometry`,null),O([i({json:{write:!0}})],Yn.prototype,`rasterId`,void 0),Yn=Jn=O([w(`esri.rest.support.MeasureFromImageParameters`)],Yn);var Xn=class extends D{constructor(e){super(e),this.geometry=null,this.length=null}};O([i({types:l,json:{name:`Shape`,read:k,write:!0}})],Xn.prototype,`geometry`,void 0),O([i({json:{name:`Length`,write:!0}})],Xn.prototype,`length`,void 0),Xn=O([w(`esri.rest.support.MeasureLengthFromImageResult`)],Xn);function Zn(e){let t=e?.time;if(t&&(t.start!=null||t.end!=null)){let n=[];t.start!=null&&n.push(t.start),t.end==null||n.includes(t.end)||n.push(t.end),e.time=n.join(`,`)}}async function Qn(e,t,n){t=j(pt,t);let r=S(e),i=t.geometry?[t.geometry]:[],a=await je(i),o=t.toJSON();Zn(o);let s=a?.[0];s!=null&&(o.geometry=Q(s));let l=c({...r.query,f:`json`,...o});return d(l,n)}async function $n(e,t,n){let r=(t=j(X,t)).toJSON();r.geometries=JSON.stringify(r.geometries);let i=S(e),a=c({...i.query,f:`json`,...r}),o=d(a,n),{data:s}=await E(`${i.path}/calculateVolume`,o);return Gn.fromJSON({volumes:s.results})}async function er(e,t,n){let r=j(gn,t),i=r.toJSON();i.angleName!=null&&(i.angleName=i.angleName.join(`,`)),r?.point?.spatialReference?.imageCoordinateSystem&&(i.point.spatialReference=mr(r.point.spatialReference)),r?.spatialReference?.imageCoordinateSystem&&(i.spatialReference=hr(r.spatialReference));let a=S(e),o=c({...a.query,f:`json`,...i}),s=d(o,n),{data:l}=await E(`${a.path}/computeAngles`,s);return l.spatialReference=l.spatialReference?l.spatialReference.geodataXform==null?y.fromJSON(l.spatialReference):new y({wkid:0,imageCoordinateSystem:l.spatialReference}):null,l.north===`NaN`&&(l.north=null),l.up===`NaN`&&(l.up=null),new _n(l)}async function tr(e,t,n){let r=(t=j(Fn,t)).toJSON(),{geometries:i}=t;if(i)for(let e=0;e<i.length;e++)i[e].spatialReference?.imageCoordinateSystem&&(r.geometries.geometries[e].spatialReference=mr(i[e].spatialReference));let a=S(e),o=c({...a.query,f:`json`,...r}),s=d(o,n),{data:l}=await E(`${a.path}/computePixelLocation`,s);return In.fromJSON(l)}async function nr(e,t,n){let r=await Qn(e,t,n),i=S(e),{data:a}=await E(`${i.path}/computeStatisticsHistograms`,r),{statistics:o}=a;return o?.length&&o.forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),{statistics:o,histograms:a.histograms}}async function rr(e,t,n){let r=await Qn(e,t,n),i=S(e),{data:a}=await E(`${i.path}/computeHistograms`,r);return{histograms:a.histograms}}async function ir(e,t,n){let r=(t=j(_t,t)).toJSON();Zn(r),r.outFields?.length&&(r.outFields=r.outFields.join(`,`));let i=await je(t.geometry),a=i?.[0];a!=null&&(r.geometry=Q(a));let o=S(e),s=c({...o.query,f:`json`,...r}),l=d(s,n),{data:u}=await E(`${o.path}/getSamples`,l),f=u.samples.map(e=>{let t=e.value===`NaN`||e.value===``?null:e.value.split(` `).map(e=>Number(e));return{...e,pixelValue:t}});return bt.fromJSON({samples:f})}async function ar(e,t,n){t=j(q,t);let r=S(e),i=t.geometry?[t.geometry]:[];return je(i).then(e=>{let i=t.toJSON(),a=e?.[0];a!=null&&(i.geometry=JSON.stringify(Q(a)));let o=c({...r.query,f:`json`,...i}),s=d(o,n);return E(r.path+`/identify`,s)}).then(e=>J.fromJSON(e.data))}async function or(e,t,n){let r=j(K,t),i=await ur(e,r,[r.fromGeometry,r.toGeometry],n);return Mn.fromJSON(i)}async function sr(e,t,n){let r=j(B,t),i=await ur(e,r,[r.geometry],n);return xn.fromJSON(i)}async function cr(e,t,n){let r=j(Rn,t),i=await ur(e,r,[r.geometry],n);return zn.fromJSON(i)}async function lr(e,t,n){let r=j(U,t),i=await ur(e,r,[r.fromGeometry,r.toGeometry],n);return En.fromJSON(i)}async function ur(e,t,n,r){let i=S(e),a=await je(n),o=t.toJSON();a[0]!=null&&(o.fromGeometry=JSON.stringify(Q(a[0]))),a[1]!=null&&(o.toGeometry=JSON.stringify(Q(a[1])));let s=c({...i.query,f:`json`,...o}),l=d(s,r),{data:u}=await E(i.path+`/measure`,l);return u}async function dr(e,t,n){let r=await pr(e,t,n);return Xn.fromJSON(r)}async function fr(e,t,n){let r=await pr(e,t,n);return qn.fromJSON(r)}async function pr(e,t,n){t=j(Yn,t);let r=S(e),i=t.toJSON(),a=c({...r.query,f:`json`,...i}),o=d(a,n),{data:s}=await E(r.path+`/measureFromImage`,o);return s}function Q(e){let t=e.toJSON();return e.spatialReference?.imageCoordinateSystem&&(t.spatialReference=mr(e.spatialReference)),t}function mr(e){let{imageCoordinateSystem:t}=e;if(t){let{id:e,referenceServiceName:n}=t;return e==null?{ics:t}:n?{icsid:e,icsns:n}:{icsid:e}}return e.toJSON()}function hr(e,t){if(!e.imageCoordinateSystem)return ie(e);let n=mr(e),{icsid:r,icsns:i}=n;return r==null||i!=null&&!t?.toLowerCase().includes(`/`+i.toLowerCase()+`/`)?JSON.stringify(n):`0:${r}`}async function gr(e,t,n){t=j(Sn,t);let r=S(e),i=t.toJSON();t.outSpatialReference&&(i.outSR=hr(t.outSpatialReference));let a=c({...r.query,f:`json`,...i}),o=d(a,n),{data:s}=await E(r.path+`/queryBoundary`,o);return Cn.fromJSON(s)}async function _r(e,t,n){let r=(t=j(W,t)).toJSON();Zn(r),r.objectIds?.length&&(r.objectIds=r.objectIds.join(`,`)),r.geometry||r.objectIds||r.time||r.where||(r.where=`1=1`);let i=await je(t.geometry),a=i?.[0];a!=null&&(r.geometry=Q(a));let o=a?.spatialReference??t.geometry?.spatialReference;o&&(r.inSR=hr(o));let s=S(e),l=c({...s.query,f:`json`,...r}),u=d(l,n),{data:f}=await E(`${s.path}/queryGPSInfo`,u);return An.fromJSON(f)}async function vr(e,t,n){let r=(t=j(Y,t)).toJSON();t.geometry.spatialReference.imageCoordinateSystem&&(r.geometry=Q(t.geometry)),t.depthOffset&&t.adjust||delete r.options;let i=S(e),a=c({...i.query,f:`json`,...r}),o=d(a,n),{data:s}=await E(`${i.path}/imageToMap`,o);return k(s)}async function yr(e,t,n){let r=(t=j(Bn,t)).toJSON();t.rasterIds?.length&&(r.rasterIds=t.rasterIds.join(`,`));let i=S(e),a=c({...i.query,f:`json`,...r}),o=d(a,n),{data:s}=await E(`${i.path}/imageToMapMultiray`,o);return k(s)}async function br(e,t,n){let r=(t=j(Kn,t)).toJSON(),i=await je(t.geometry),a=i?.[0];a!=null&&(r.geometry=Q(a)),t.visibleOnly||delete r.options;let o=a?.spatialReference??t.geometry?.spatialReference;o&&(r.inSR=hr(o));let s=S(e),l=c({...s.query,f:`json`,...r}),u=d(l,n),{data:f}=await E(`${s.path}/mapToImage`,u);return k(f)}async function xr(e,t,n){let r=(t=j(Vn,t)).toJSON(),i=S(e),a=c({...i.query,f:`json`,...r}),o=d(a,n),{data:s}=await E(`${i.path}/getImageUrl`,o);return Hn.fromJSON(s)}async function Sr(e,t,n){let r=(t=j(I,t)).toJSON(),i=await je([t.fromGeometry,t.toGeometry]);i[0]!=null&&(r.fromGeometry=Q(i[0]),i[0].spatialReference&&(r.inSR=hr(i[0].spatialReference))),i[1]!=null&&(r.toGeometry=Q(i[1])),t.objectIds?.length&&(r.objectIds=r.objectIds.join(`,`));let a=S(e),o=c({...a.query,f:`json`,...r}),s=d(o,n),{data:l}=await E(`${a.path}/find`,s);return mn.fromJSON(l)}async function Cr(e,t,n){let r=S(e),i=c({...r?.query,f:`json`}),a=d(i,n),o=`${r?.path}/${t}/info`,s=E(`${o}`,a),l=E(`${o}/keyProperties`,a),u=await Promise.allSettled([s,l]),p=u[0].status===`fulfilled`?u[0].value.data:null,m=u[1].status===`fulfilled`?u[1].value.data:null,h=null;p.statistics?.length&&(h=p.statistics.map(e=>({min:e[0],max:e[1],avg:e[2],stddev:e[3]})));let g=ke.fromJSON(p.extent),_=Math.ceil(g.width/p.pixelSizeX-.1),v=Math.ceil(g.height/p.pixelSizeY-.1),y=g.spatialReference,b=new f({x:p.pixelSizeX,y:p.pixelSizeY,spatialReference:y}),ee=p.histograms?.length?p.histograms:null,te=new Xe({origin:p.origin,blockWidth:p.blockWidth,blockHeight:p.blockHeight,firstPyramidLevel:p.firstPyramidLevel,maximumPyramidLevel:p.maxPyramidLevel});return new nt({width:_,height:v,bandCount:p.bandCount,extent:g,spatialReference:y,pixelSize:b,pixelType:p.pixelType.toLowerCase(),statistics:h,histograms:ee,keyProperties:m,storageInfo:te})}var wr=new Set([`png`,`png8`,`png24`,`png32`,`jpg`,`bmp`,`gif`,`jpgpng`,`lerc`,`tiff`]),Tr=ye(me,{min:0,max:255});function Er(e){let t=JSON.stringify(e),n=t.includes(`"rasterFunctionDefinition":{`),r=n?t.match(/"type":"(.*?FunctionArguments")/gi):t.match(/"rasterFunction":"(.*?")/gi),i=r?.map(e=>n?e.slice(8,-18):e.slice(18,-1));return i?i.join(`/`):null}var Dr=e=>{let n=e,r=class extends n{constructor(){super(...arguments),this._functionRasterInfos={},this._serviceSupportsMosaicRule=null,this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType=`polygon`,this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set(`exportImageServiceParameters`,new F({layer:this}))}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get _rasterFunctionNamesIndex(){let e=new Map;return!this.rasterFunctionInfos||this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.length<1||this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.forEach(t=>{e.set(t.name.toLowerCase().replaceAll(/ /gi,`_`),t.name)}),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every(e=>typeof e==`number`))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,n){e!=null&&this.format!==`lerc`&&(t[n]=e)}writeCompressionTolerance(e,t,n){this.format===`lerc`&&e!=null&&(t[n]=e)}readDefaultMosaicRule(e,t){return this._serviceSupportsMosaicRule?M.fromJSON(t):null}get fieldsIndex(){return this.fields?new u(this.fields):null}set format(e){e&&wr.has(e.toLowerCase())&&this._set(`format`,e.toLowerCase())}readFormat(e,t){return t.serviceDataType===`esriImageServiceDataTypeVector-UV`||t.serviceDataType===`esriImageServiceDataTypeVector-MagDir`||this.pixelFilter!=null?`lerc`:`jpgpng`}readMinScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}readMaxScale(e,t){return t.minLOD!=null&&t.maxLOD!=null?e:0}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=M.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set(`mosaicRule`,t)}readMosaicRule(e,t){let n=e||t.mosaicRule;return n?M.fromJSON(n):this._isMosaicRuleSupported(t)?M.fromJSON(t):null}writeMosaicRule(e,t,n){let{mosaicRule:r}=this;this._isValidCustomizedMosaicRule(r)&&(t[n]=r.toJSON())}writeNoData(e,t,n){e!=null&&typeof e==`number`&&(t[n]=Tr(e))}readObjectIdField(e,t){return e||=t.fields.find(e=>e.type===`esriFieldTypeOID`||e.type===`oid`)?.name,e}get parsedUrl(){return ve(this.url)}readSourceType(e,t){return this._isMosaicDataset(t)?`mosaic-dataset`:`raster-dataset`}get renderer(){let{activePresetRendererName:e,presetRenderers:t}=this;return e?(t?.find(({name:t})=>t===e))?.renderer.clone():this.internalRenderer}set renderer(e){this.activePresetRendererName=null,this.internalRenderer=e}set internalRenderer(e){this.loaded&&(e=this._configRenderer(e)),this._set(`internalRenderer`,e)}readRenderer(e,t,n){let r=t?.layerDefinition?.drawingInfo?.renderer,i=xt(r,n);return i==null?null:(i.type===`vector-field`&&t.symbolTileSize&&!r.symbolTileSize&&(i.symbolTileSize=t.symbolTileSize),Jt(i)||o.getLogger(this).warn(`ArcGISImageService`,`Imagery layer doesn't support given renderer type.`),i)}writeRenderer(e,t,n){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),e.type===`vector-field`&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){let e=this.fields?.map(e=>e.clone())??[];e.push(Dt()),this.sourceType===`mosaic-dataset`&&this.fields?.length&&e.push(At()),this.version>=10.4&&this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.some(({name:e})=>e.toLowerCase()===`none`)&&e.push(Tt()),this.rasterFunctionInfos!=null&&this.rasterFunctionInfos.filter(({name:e})=>e.toLowerCase()!==`none`).forEach(({name:t})=>e.push(Ft(t)));let{rasterInfo:t}=this;if(this._isVectorDataSet()){let n=t?.multidimensionalInfo?.variables[0].unit?.trim(),r=Mt(n),i=It();e.push(r,i)}if(t?.multidimensionalInfo&&this.sourceType===`raster-dataset`){let n=Ot(t.multidimensionalInfo);e.push(...n)}let n=t?.attributeTable;if(n!=null){let t=Nt(n);e.push(...t)}return e}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=N.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set(`rasterFunction`,t)}readRasterFunction(e,t){let n=t.rasterFunctionInfos;return t.renderingRule||n?.length&&n[0].name!==`None`?this._isRFTJson(t.renderingRule)?N.fromJSON({rasterFunctionDefinition:t.renderingRule}):N.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}readSpatialReference(e,t){let n=e||t.extent.spatialReference;return n?y.fromJSON(n):null}writePixelType(e,t,n){this.serviceRasterInfo!=null&&this.pixelType===this.serviceRasterInfo.pixelType||(t[n]=it.toJSON(e))}readVersion(e,t){let n=t.currentVersion;return n||=t.hasOwnProperty(`fields`)||t.hasOwnProperty(`timeInfo`)?10:9.3,n}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let n=e,{renderer:r,symbolizer:i,pixelFilter:a}=this,{isRawData:o}=e;if(o&&this.format!==`lerc`&&(r??=vt(this.rasterInfo,{bandIds:this.bandIds,variableName:this.rasterFunction?null:this.mosaicRule?.multidimensionalDefinition?.[0].variableName}),i||=(this.symbolizer=new ot({rendererJSON:r.toJSON(),rasterInfo:this.rasterInfo}),this.symbolizer)),(o||!this._isPicture())&&r&&i&&!a){await this._updateSymbolizer(i,r);let{bandIds:a}=this;n=await this._symbolize({pixelData:e,bandIds:a,symbolizer:i},t)}return n}async highlightPixels(e,t){let n=e.highlightOptions.map(e=>{let t={...e},n=`bandId`in t?[t.bandId??0]:[t.xBandId,t.yBandId];for(let e=0;e<n.length;e++){let t=n[e];if(t==null)return;let r=this.bandIds?.length?this.bandIds.indexOf(t):t;if(r<0||r>2)return;n[e]=r}return`bandId`in t?t.bandId=n[0]:(t.xBandId=n[0],t.yBandId=n[1]),t}).filter(e=>e!=null);if(n.length===0)return;let r=this._rasterJobHandler;r?await r.highlightPixels({...e,highlightOptions:n},t):ut({...e,highlightOptions:n})}destroy(){this._shutdownJobHandler()}async calculateVolume(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsCalculateVolume)throw new t(`imagery-layer:compute-pixel-space-locations`,`this operation is not supported on the input image service`);return e=p(e),this.mosaicRule&&e.mosaicRule==null&&(e.mosaicRule=this.mosaicRule),$n(this.url,e,this._getRequestOptions(n))}async computeAngles(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsComputeAngles)throw new t(`imagery-layer:compute-angles`,`this operation is not supported on the input image service`);return er(this.url,e,this._getRequestOptions(n))}async computePixelSpaceLocations(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsComputePixelLocation)throw new t(`imagery-layer:compute-pixel-space-locations`,`this operation is not supported on the input image service`);return tr(this.url,e,this._getRequestOptions(n))}async computeHistograms(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsComputeHistograms)throw new t(`imagery-layer:compute-histograms`,`this operation is not supported on the input image service`);return e=p(e),this._applyMosaicAndRenderingRules(e),rr(this.url,e,this._getRequestOptions(n))}async computeStatisticsHistograms(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsComputeStatisticsHistograms)throw new t(`imagery-layer:compute-statistics-histograms`,`this operation is not supported on the input image service`);return e=p(e),this._applyMosaicAndRenderingRules(e),nr(this.url,e,this._getRequestOptions(n))}async measureHeight(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(e.operationType===`base-and-top`?r.mensuration.supportsHeightFromBaseAndTop:e.operationType===`base-and-top-shadow`?r.mensuration.supportsHeightFromBaseAndTopShadow:r.mensuration.supportsHeightFromTopAndTopShadow))throw new t(`imagery-layer:measure-height`,`this operation is not supported on the input image service`);return e=p(e),this._applyMosaicRule(e),or(this.url,e,this._getRequestOptions(n))}async measureAreaAndPerimeter(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(r.mensuration.supportsAreaAndPerimeter&&(!e.is3D||r.mensuration.supports3D)))throw new t(`imagery-layer:measure-area-and-perimeter`,`this operation is not supported on the input image service`);return e=p(e),this._applyMosaicRule(e),sr(this.url,e,this._getRequestOptions(n))}async measureDistanceAndAngle(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(r.mensuration.supportsDistanceAndAngle&&(!e.is3D||r.mensuration.supports3D)))throw new t(`imagery-layer:measure-distance-and-angle`,`this operation is not supported on the input image service`);return e=p(e),this._applyMosaicRule(e),lr(this.url,e,this._getRequestOptions(n))}async measurePointOrCentroid(e,n){let r=await this._fetchCapabilities(n?.signal);if(!(r.mensuration.supportsPointOrCentroid&&(!e.is3D||r.mensuration.supports3D)))throw new t(`imagery-layer:measure-point-or-centroid`,`this operation is not supported on the input image service`);return e=p(e),this._applyMosaicRule(e),cr(this.url,e,this._getRequestOptions(n))}async measureLengthFromImage(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsMeasureFromImage)throw new t(`imagery-layer:measure-length-from-image`,`this operation is not supported on the input image service`);if(e.geometry.type!==`polyline`)throw new t(`imagery-layer:measure-length-from-image`,`this input geometry must be a polyline`);return dr(this.url,e,this._getRequestOptions(n))}async measureAreaFromImage(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsMeasureFromImage)throw new t(`imagery-layer:measure-area-from-image`,`this operation is not supported on the input image service`);if(e.geometry.type!==`polygon`)throw new t(`imagery-layer:measure-area-from-image`,`this input geometry must be a polygon`);return fr(this.url,e,this._getRequestOptions(n))}getField(e){let{fieldsIndex:t}=this;return t?.get(e)}getFieldDomain(e,t){let n=this.getField(e);return n?n.domain:null}async internalFetchImage(e,t,n,r={}){await this._updateCurrentRasterInfo();let{exportImageServiceParameters:i}=this,a=!1;r.requestRawData&&(await this._initJobHandler(),i.requestRawData||this.format===`lerc`||(a=!0,i.requestRawData=!0));let o=this.getExportImageServiceParameters(e,t,n,r.timeExtent);if(a&&(i.requestRawData=!1),o==null){if(r.requestAsImageElement&&this._canRequestImageElement(this.format)){let e=document.createElement(`canvas`);return e.width=t,e.height=n,r.returnImageBitmap?{imageBitmap:await Fe(e,`${s(this.parsedUrl)}/exportImage`,r.signal)}:{imageOrCanvasElement:e}}let{bandIds:i,rasterInfo:a}=this,o=(i?.length||a.bandCount)??0,c=t*n,l=a.pixelType,u=[];for(let e=0;e<o;e++)u.push(lt.createEmptyBand(l,c));return{pixelData:{pixelBlock:new lt({width:t,height:n,pixels:u,mask:new Uint8Array(c),pixelType:l}),extent:e}}}let c=!!r.requestAsImageElement&&!this.pixelFilter,l=c&&!!r.returnImageBitmap,u={imageServiceParameters:o,imageProps:{extent:e,width:t,height:n,format:this.format},requestAsImageElement:c,returnImageBitmap:l,signal:r.signal};return this._requestArrayBuffer(u)}async fetchPixels(e,t,n,r={}){await this._initJobHandler(),r.applyRendering&&this._updateCurrentRasterInfo();let i=r.applyRendering?void 0:new F({layer:this,requestRawData:!0,interpolation:r.interpolation??`nearest`,bandIds:r.bandIds??[]}),a=this.getExportImageServiceParameters(e,t,n,r.timeExtent,i);if(a==null)return{extent:e,pixelBlock:null};delete a.pixelType,r.bandIds||delete a.bandIds,delete a.compressionQuality;let o={imageServiceParameters:a,imageProps:{extent:e,width:t,height:n,format:this.format},requestAsImageElement:!1,returnImageBitmap:!1,signal:r.signal},{pixelData:s}=await this._requestArrayBuffer(o);return s??{extent:e,pixelBlock:null}}fetchKeyProperties(e){return E(s(this.parsedUrl)+`/keyProperties`,{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then(e=>e.data)}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new t(`#fetchRasterAttributeTable()`,`Failed to get rasterAttributeTable`)):E(s(this.parsedUrl)+`/rasterAttributeTable`,{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then(e=>he.fromJSON(e.data))}getCatalogItemRasterInfo(e,t){let n={...t,query:this._getQueryParams()};return Cr(s(this.parsedUrl),e,n)}async getCatalogItemICSInfo(e,t){let{data:n}=await E(s(this.parsedUrl)+`/`+e+`/info/ics`,{query:this._getQueryParams(),...t}),r=n?.ics;if(!r)return;let i=null;try{i=(await E(s(this.parsedUrl)+`/`+e+`/info`,{query:this._getQueryParams(),...t})).data.extent}catch{}if(!i?.spatialReference)return{ics:r,icsToPixelTransform:null,icsExtent:null,northDirection:null};let a=this.version>=10.7?E(s(this.parsedUrl)+`/`+e+`/info/icstopixel`,{query:this._getQueryParams(),...t}).then(e=>e.data).catch(()=>({})):{},o=i.spatialReference,c={geometries:JSON.stringify({geometryType:`esriGeometryEnvelope`,geometries:[i]}),inSR:ie(o),outSR:`0:`+e},l=E(s(this.parsedUrl)+`/project`,{query:this._getQueryParams(c),...t}).then(e=>e.data).catch(()=>({})),u=(i.xmin+i.xmax)/2,d=(i.ymax-i.ymin)/6,f=i.ymin+d,p=[];for(let e=0;e<5;e++)p.push({x:u,y:f+d*e});let m={geometries:JSON.stringify({geometryType:`esriGeometryPoint`,geometries:p}),inSR:ie(o),outSR:`0:`+e},h=E(s(this.parsedUrl)+`/project`,{query:this._getQueryParams(m),...t}).then(e=>e.data).catch(()=>({})),g=await Promise.all([a,l,h]),_=g[0].ipxf;if(_==null){let e=r.geodataXform?.xf_0;e?.name?.toLowerCase()===`topup`&&e?.coefficients?.length===6&&(_={affine:{name:`ics [sensor: Frame] to pixel (column, row) transformation`,coefficients:e.coefficients,cellsizeRatio:0,type:`GeometricXform`}})}let v=ke.fromJSON(g[1]?.geometries?.[0]);v&&(v.spatialReference=new y({wkid:0,imageCoordinateSystem:r}));let b=g[2].geometries?g[2].geometries.filter(e=>e?.x!=null&&e.y!=null&&e.x!==`NaN`&&e.y!==`NaN`):[],ee=b.length;if(ee<3)return{ics:r,icsToPixelTransform:_,icsExtent:v,northDirection:null};let te=0,ne=0,re=0,x=0;for(let e=0;e<ee;e++)te+=b[e].x,ne+=b[e].y,re+=b[e].x*b[e].x,x+=b[e].x*b[e].y;let S=(ee*x-te*ne)/(ee*re-te*te),C=0,ae=b[4].x>b[0].x,w=b[4].y>b[0].y;return S===1/0?C=w?90:270:S===0?C=ae?0:180:S>0?C=ae?180*Math.atan(S)/Math.PI:180*Math.atan(S)/Math.PI+180:S<0&&(C=w?180+180*Math.atan(S)/Math.PI:360+180*Math.atan(S)/Math.PI),{ics:r,icsToPixelTransform:_,icsExtent:v,northDirection:C}}async generateRasterInfo(e,n){e=j(N,e);let r={...n,query:this._getQueryParams()};if(!e||e.functionName?.toLowerCase()===`none`||this._isVectorFieldResampleFunction(e))return this.serviceRasterInfo??Bt(s(this.parsedUrl),this.sourceJSON,r);let i=Er(e);if(!i)throw new t(`imagery-layer:generate-raster-info`,`the rendering rule is not supported`);if(this._functionRasterInfos[i])return this._functionRasterInfos[i];let a=Rt(s(this.parsedUrl),e,r);this._functionRasterInfos[i]=a;try{return await a}catch(e){throw this._functionRasterInfos[i]=null,e}}getExportImageServiceParameters(e,t,n,r,i){e=e.clone().shiftCentralMeridian();let a=hr(e.spatialReference,s(this.parsedUrl));i??=this.exportImageServiceParameters;let o=i.toJSON(),{bandIds:c,noData:l}=o,{renderingRule:u}=o,d=this.rasterFunction?.rasterFunctionDefinition,f=this.renderer?.type,p=!f||f===`raster-stretch`||f===`raster-colormap`||f===`unique-value`||f===`class-breaks`||f===`raster-shaded-relief`;if(c?.length&&this._hasRasterFunction(this.rasterFunction)&&!d&&p){let e={rasterFunction:`ExtractBand`,rasterFunctionArguments:{BandIds:c}};if(u.rasterFunction===`Stretch`)e.rasterFunctionArguments.Raster=u.rasterFunctionArguments.Raster,u.rasterFunctionArguments.Raster=e;else if(u.rasterFunction===`Colormap`){let t=u.rasterFunctionArguments.Raster;t?.rasterFunction===`Stretch`?(e.rasterFunctionArguments.Raster=t.rasterFunctionArguments.Raster,t.rasterFunctionArguments.Raster=e):(e.rasterFunctionArguments.Raster=t,u.rasterFunctionArguments.Raster=e)}else e.rasterFunctionArguments.Raster=u,u=e;o.bandIds=void 0}else o.bandIds=c?.join(`,`);Array.isArray(l)&&l.length>0&&(o.noData=l.join(`,`));let m=this._processMultidimensionalIntersection(null,r,i.mosaicRule);if(m.isOutSide)return null;o.mosaicRule=m.mosaicRule==null?null:JSON.stringify(m.mosaicRule),r=m.timeExtent,o.renderingRule=this._getRenderingRuleString(N.fromJSON(u));let h={};if(r!=null){let{start:e,end:t}=r.toJSON();e&&t&&e===t?h.time=``+e:e==null&&t==null||(h.time=`${e??`null`},${t??`null`}`)}return{bbox:e.xmin+`,`+e.ymin+`,`+e.xmax+`,`+e.ymax,bboxSR:a,imageSR:a,size:t+`,`+n,...o,...h}}async getSamples(e,n){if(!(await this._fetchCapabilities(n?.signal))?.operations.supportsGetSamples)throw new t(`imagery-layer:get-samples`,`getSamples operation is not supported on the input image service`);e=p(e);let{raster:r}=this;return r&&e.raster==null&&(e.raster=r),ir(this.url,e,this._getRequestOptions(n))}async identify(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsIdentify)throw new t(`imagery-layer:identify`,`identify operation is not supported on the input image service`);e=p(e),this.version<10.91&&e.geometry?.type===`extent`&&(e.geometry=a.fromExtent(e.geometry));let r=this._processMultidimensionalIntersection(e.geometry,e.timeExtent,e.mosaicRule||this.mosaicRule);if(r.isOutSide)throw new t(`imagery-layer:identify`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);e.timeExtent=r.timeExtent,e.mosaicRule=r.mosaicRule;let{raster:i,rasterFunction:o}=this;return o&&e.rasterFunction==null&&(e.rasterFunction=o),i&&e.raster==null&&(e.raster=i),ar(this.url,e,this._getRequestOptions(n))}async imageToMap(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsImageToMap)throw new t(`imagery-layer:image-to-map`,`imageToMap operation is not supported on the input image service`);return vr(s(this.parsedUrl),e,this._getRequestOptions(n))}async imageToMapMultiray(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsImageToMapMultiray)throw new t(`imagery-layer:image-to-map-multiray`,`imageToMapMultiray operation is not supported on the input image service`);return yr(s(this.parsedUrl),e,this._getRequestOptions(n))}async mapToImage(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsMapToImage)throw new t(`imagery-layer:map-to-image`,`mapToImage operation is not supported on the input image service`);return br(s(this.parsedUrl),e,this._getRequestOptions(n))}async findImages(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsFindImages)throw new t(`imagery-layer:find-images`,`findImages operation is not supported on the input image service`);return Sr(s(this.parsedUrl),e,this._getRequestOptions(n))}async getImageUrl(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsGetImageUrl)throw new t(`imagery-layer:get-image-url`,`getImageUrl operation is not supported on the input image service`);return xr(s(this.parsedUrl),e,this._getRequestOptions(n))}createQuery(){return new Se({outFields:[`*`],returnGeometry:!0,where:this.definitionExpression||`1=1`})}async queryBoundary(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsQueryBoundary)throw new t(`imagery-layer:query-boundary`,`queryBoundary operation is not supported on the input image service`);return e??={outSpatialReference:this.spatialReference},gr(s(this.parsedUrl),e,this._getRequestOptions(n))}async queryExtent(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),ze(this.url,e,t)}async queryRasters(e,t){({query:e,requestOptions:t}=await this._prepareForQuery(e,t));let n=await He(this.url,e,t),r=this.graphicOrigin;return n.features.forEach(e=>{e.layer=this,e.origin=r}),n}async queryObjectIds(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Ve(this.url,e,t)}async queryGPSInfo(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsQueryGPSInfo)throw new t(`imagery-layer:query-gps-info`,`queryGPSInfo operation is not supported on the input image service`);return e??={where:`1=1`},_r(s(this.parsedUrl),e,this._getRequestOptions(n))}async queryRasterCount(e,t){return{query:e,requestOptions:t}=await this._prepareForQuery(e,t),Be(this.url,e,t)}async queryVisibleRasters(e,n){if(!e)throw new t(`imagery-layer: query-visible-rasters`,`missing query parameter`);await this.load();let{pixelSize:r,returnDomainValues:i,returnTopmostRaster:o,showNoDataRecords:s}=n||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1},c=!1,l=null,u=null,d=Et.servicePixelValue.toLowerCase(),f=this._rasterFunctionNamesIndex;if(e.outFields!=null&&(c=e.outFields.some(e=>!e.toLowerCase().startsWith(d)),this.version>=10.4)){let t=e.outFields.filter(e=>e.toLowerCase().startsWith(d)&&e.length>d.length).map(e=>{let t=e.slice(d.length+1);return[this._updateRenderingRulesFunctionName(t,f),t]});l=t.map(e=>new N({functionName:e[0]})),u=t.map(e=>e[1]);let{rasterFunction:n}=this;l.length===0?n?.functionName?(l.push(n),u.push(n.functionName)):l=null:n?.functionName&&!l.some(e=>e.functionName===n.functionName)&&(l.push(n),u.push(n.functionName))}let p=e.outSpatialReference==null||e.outSpatialReference.equals(this.spatialReference),{multidimensionalSubset:m}=this,h=e.timeExtent||this.timeExtent;if(m){let{isOutside:n,intersection:r}=We(m,{geometry:e.geometry,timeExtent:e.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(n)throw new t(`imagery-layer:query-visible-rasters`,`the request cannot be fulfilled when falling outside of the multidimensional subset`);r?.timeExtent!=null&&(h=r.timeExtent)}let g=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,h),_=e.geometry;this.version<10.91&&_?.type===`extent`&&(_=a.fromExtent(_));let v=this._getQueryParams({geometry:_,timeExtent:h,mosaicRule:g,rasterFunction:this.version<10.4?this.rasterFunction:null,rasterFunctions:l,pixelSize:r,returnCatalogItems:c,returnGeometry:p,raster:this.raster,maxItemCount:o?1:null});delete v.f;let y=new q(v);try{await this._generateRasterInfo(this.rasterFunction);let t=await ar(this.url,y,{signal:n?.signal,query:{...this.customParameters}}),r=e.outFields,a=t.value!=null&&t.value.toLowerCase().includes(`nodata`),o=c&&!p&&t?.catalogItems?.features.length&&(s||!a),l=this.multidimensionalInfo&&this.sourceType===`raster-dataset`?Ke({rasterInfo:this.rasterInfo,multidimensionalDefinition:g?.multidimensionalDefinition,timeExtent:h,multidimensionalSubset:this.multidimensionalSubset}):null;if(!o)return this._processVisibleRastersResponse(t,{returnDomainValues:i,templateRRFunctionNames:u,showNoDataRecords:s,templateFields:r,effectiveMultidimensionalDefinition:l});let d=this.objectIdField||`ObjectId`,f=t.catalogItems?.features??[],m=f.map(e=>e.attributes?.[d]),_=new Se({objectIds:m,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[d]}),v=await this.queryRasters(_);return v?.features?.length&&v.features.forEach(t=>{f.forEach(n=>{n.attributes[d]===t.attributes[d]&&t.geometry&&(n.geometry=t.geometry.clone(),e.outSpatialReference!=null&&(n.geometry.spatialReference=e.outSpatialReference))})}),this._processVisibleRastersResponse(t,{returnDomainValues:i,templateRRFunctionNames:u,showNoDataRecords:s,templateFields:r,effectiveMultidimensionalDefinition:l})}catch{throw new t(`imagery-layer:query-visible-rasters`,`encountered error when querying visible rasters`)}}async fetchVariableStatisticsHistograms(e,t){let n=E(s(this.parsedUrl)+`/statistics`,{query:this._getQueryParams({variable:e}),signal:t}).then(e=>e.data?.statistics),r=E(s(this.parsedUrl)+`/histograms`,{query:this._getQueryParams({variable:e}),signal:t}).then(e=>e.data?.histograms),i=await Promise.all([n,r]);return i[0]&&i[0].forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),{statistics:i[0]||null,histograms:i[1]||null}}getMultidimensionalSubsetVariables(e){let t=e??this.serviceRasterInfo.multidimensionalInfo;return Ge(this.multidimensionalSubset,t)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||=this.serviceRasterInfo;let t=this.sourceJSON,n=this.serviceRasterInfo==null?Bt(s(this.parsedUrl),t,{signal:e,query:this._getQueryParams()}).then(e=>(this._set(`serviceRasterInfo`,e),this._set(`multidimensionalInfo`,e.multidimensionalInfo),zt(e,t),e)):Promise.resolve(this.serviceRasterInfo),r=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:e}):null,i=this._getRasterFunctionInfos();return Promise.all([n,r,i]).then(e=>{e[1]?this._set(`rasterInfo`,e[1]):this._set(`rasterInfo`,e[0]),e[2]&&this._set(`rasterFunctionInfos`,e[2]),this.internalRenderer&&!this._isSupportedRenderer(this.internalRenderer)&&(this._set(`internalRenderer`,null),o.getLogger(this).warn(`ArcGISImageService`,`Switching to the default renderer. Renderer applied is not valid for this Imagery Layer`)),this._set(`internalRenderer`,this._configRenderer(this.renderer)),this.addHandles([Ce(()=>this.rasterFunction,e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then(e=>{e&&(this.rasterInfo=e)})})]);let{serviceRasterInfo:t}=this;t.multidimensionalInfo!=null&&this._updateMultidimensionalDefinition(t)})}_combineMosaicRuleWithTimeExtent(e,t){let n=this.timeInfo,{multidimensionalInfo:r}=this.serviceRasterInfo;if(e==null||r==null||t==null||n?.startField==null)return e;let{startField:i}=n,a=r.variables.some(e=>e.dimensions.some(e=>e.name===i))?i:`StdTime`;if(e=e.clone(),this.sourceType===`mosaic-dataset`)return e.multidimensionalDefinition=e.multidimensionalDefinition?.filter(e=>e.dimensionName!==a),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];let o=e.multidimensionalDefinition.filter(e=>e.dimensionName===a),s=t.start==null?null:t.start.getTime(),c=t.end==null?null:t.end.getTime(),l=s==null||c==null||s===c,u=l?[s||c]:[[s,c]],d=this.version>=10.8;if(o.length)o.forEach(e=>{e.dimensionName===a&&(d?(e.dimensionName=null,e.isSlice=!1,e.values=[]):(e.isSlice=l,e.values=u))});else if(!d){let t=e.multidimensionalDefinition.filter(e=>e.variableName!=null&&e.dimensionName==null);t.length?t.forEach(e=>{e.dimensionName=a,e.isSlice=l,e.values=u}):e.multidimensionalDefinition.push(new qe({variableName:``,dimensionName:a,isSlice:l,values:u}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return e==null?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter(e=>!(!e.variableName&&!e.dimensionName)),e.multidimensionalDefinition.length===0&&(e.multidimensionalDefinition=null)),this.sourceType!==`mosaic-dataset`&&e.multidimensionalDefinition==null?null:e)}async _prepareForQuery(e,n){if(!(await this._fetchCapabilities(n?.signal)).operations.supportsQuery)throw new t(`imagery-layer:query-rasters`,`query operation is not supported on the input image service`);let r=e==null?this.createQuery():j(Se,e);return n=this._getRequestOptions(n),this.raster&&(n.query={...n.query,raster:this.raster}),{query:r,requestOptions:n}}_isSupportedRenderer(e){let{rasterInfo:t,rasterFunction:n}=this;return e.type===`unique-value`&&this._hasRasterFunction(n)&&t?.bandCount===1&&[`u8`,`s8`].includes(t.pixelType)||t!=null&&e!=null&&ht(t).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){let n=this.sourceJSON;if(!n){let{data:t,ssl:r}=await E(s(this.parsedUrl),{query:this._getQueryParams(),signal:e});n=t,this.sourceJSON=n,r&&(this.url=this.url.replace(/^http:/i,`https:`))}if(n.capabilities?.toLowerCase().split(`,`).map(e=>e.trim()).indexOf(`tilesonly`)>-1)throw new t(`imagery-layer:fetch-service-info`,`use ImageryTileLayer to open tiles-only image services`);this.read(n,{origin:`service`,url:this.parsedUrl})}_isMosaicDataset(e){return e.serviceSourceType?e.serviceSourceType===`esriImageServiceSourceTypeMosaicDataset`:e.fields?.length>0}_isMosaicRuleSupported(e){if(!e)return!1;let t=this._isMosaicDataset(e),n=e.currentVersion>=10.71&&e.hasMultidimensions&&!(e.fields?.length>1);return t||n}_isVectorFieldResampleFunction(e){if(e==null)return!1;let{functionName:t,functionArguments:n}=e,r=t?.toLowerCase()===`resample`,i=n?.ResampleType||n?.resampleType;return r&&(i===7||i===10)}_isPicture(){return!this.format||this.format.includes(`jpg`)||this.format.includes(`png`)}_configRenderer(e){let t=this._isPicture(),{rasterInfo:n}=this;if(!t&&!this.pixelFilter||this._isVectorDataSet()){let t=this.mosaicRule?.multidimensionalDefinition?.[0].variableName,r=gt({variableName:t,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>=3){let e=r?.bandIds??wt(n);!e||n.bandCount===3&&e[0]===0&&e[1]===1&&e[2]===2||(this.bandIds=e)}e||=r?.renderer??vt(n,{bandIds:this.bandIds,variableName:this.rasterFunction?null:t});let i=yt(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=i,this.symbolizer.rasterInfo=n):this.symbolizer=new ot({rendererJSON:i,rasterInfo:n}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return e==null?e:{extent:e.extent&&e.extent.clone(),pixelBlock:e.pixelBlock==null?null:e.pixelBlock.clone()}}_getQueryParams(e){e?.renderingRule!=null&&typeof e.renderingRule!=`string`&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));let{raster:t,viewId:n}=this;return{raster:t,viewId:n,f:`json`,...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e?.query,...this.customParameters}}}_decodePixelBlock(e,t,n){return this._rasterJobHandler?this._rasterJobHandler.decode({data:e,options:t}):rt(e,t,n)}async _getRasterFunctionInfos(e){let t=this.sourceJSON.rasterFunctionInfos;return this.loaded?t:t&&this.version>=10.3?t.length===1&&t[0].name.toLowerCase()===`none`?t:(await E(s(this.parsedUrl)+`/rasterFunctionInfos`,{query:this._getQueryParams(),signal:e})).data?.rasterFunctionInfos:null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes(`png`))}async _requestArrayBuffer(e){let{imageProps:n,requestAsImageElement:r,returnImageBitmap:i,signal:a}=e;if(r&&this._canRequestImageElement(n.format)){let t=`${s(this.parsedUrl)}/exportImage`,{data:r}=await E(t,{responseType:i?`blob`:`image`,query:this._getQueryParams({f:`image`,...this.refreshParameters,...e.imageServiceParameters}),signal:a});return r instanceof Blob?{imageBitmap:await Fe(r,t,a),params:n}:{imageOrCanvasElement:r,params:n}}let o=this._initJobHandler(),c=E(s(this.parsedUrl)+`/exportImage`,{responseType:`array-buffer`,query:this._getQueryParams({f:`image`,...e.imageServiceParameters}),signal:a}),l=(await Promise.all([c,o]))[0].data,u=n.format||`jpgpng`,d=u;if(d!==`bsq`&&d!==`bip`&&(d=Ze(l)),!d)throw new t(`imagery-layer:fetch-image`,`unsupported format signature `+String.fromCharCode.apply(null,new Uint8Array(l)));let f={signal:a};return{pixelData:{pixelBlock:await(u===`gif`||u===`bmp`||u.includes(`png`)&&(d===`png`||d===`jpg`)?rt(l,{useCanvas:!0,...n},f):this._decodePixelBlock(l,{width:n.width,height:n.height,planes:null,pixelType:null,noDataValue:null,format:u},f)),extent:n.extent},params:n}}_generateRasterInfo(e,t){return this.generateRasterInfo(e,t).catch(()=>null)}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;let t=Je(e,{multidimensionalSubset:this.multidimensionalSubset});if(t!=null&&t.length>0){this.mosaicRule=this.mosaicRule||new M;let e=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&this.rasterFunction.functionName?.toLowerCase()!==`none`&&t.forEach(e=>e.variableName=``),t=t.filter(({variableName:e,dimensionName:t})=>e&&e!==`*`||t),!e?.length&&t.length&&(this.mosaicRule.multidimensionalDefinition=t)}}_processVisibleRastersResponse(e,t){t||={};let n=e.value,{templateRRFunctionNames:r,showNoDataRecords:i,returnDomainValues:a,templateFields:o}=t,s=e.processedValues,c=e.catalogItems?.features,l=e.properties?.Values?.map(e=>e.replaceAll(/ /gi,`, `))||[],u=this.objectIdField||`ObjectId`,d=typeof n==`string`&&n.toLowerCase().includes(`nodata`),f=[];if(n&&!c&&(!d||i)){let e={};e[u]=0,l=[n],c=[new ne({geometry:this.fullExtent,attributes:e})],this.multidimensionalInfo&&this.sourceType===`raster-dataset`&&jt(this.rasterFields,e,t.effectiveMultidimensionalDefinition)}if(!c)return[];this._updateResponseFieldNames(c,o),d&&!i&&(c=[]);let{itemPixelValue:p,servicePixelValue:m}=Et,h=this.rasterFields.some(e=>e.name===p),g=this.graphicOrigin;for(let e=0;e<c.length;e++){let t=c[e];if(n!=null){let a=l[e],o=this.rasterFunction&&s&&s.length>0&&r&&r.length>0&&r.includes(this.rasterFunction.functionName)?s[r.indexOf(this.rasterFunction.functionName)]:n;if(a.toLowerCase()===`nodata`&&!i)continue;h&&(t.attributes[p]=a),t.attributes[m]=o,this._updateFeatureWithMagDirValues(t,a);let c=this.fields&&this.fields.length>0,u=this.rasterFunction&&this.serviceRasterInfo.attributeTable!=null?c?a:n:o;this.rasterFunction||(u=c?a:n),this._updateFeatureWithRasterAttributeTableValues(t,u)}if(t.sourceLayer=t.layer=this,t.origin=g,a&&this._updateFeatureWithDomainValues(t),r&&s&&r.length===s.length)for(let e=0;e<r.length;e++){let n=`${Et.servicePixelValue}.${r[e]}`;t.attributes[n]=s[e]}f.push(c[e])}return f}_processMultidimensionalIntersection(e,t,n){let{multidimensionalSubset:r}=this;if(!r)return{isOutSide:!1,timeExtent:t,mosaicRule:n=this._combineMosaicRuleWithTimeExtent(n,t)};if(r){let{isOutside:n,intersection:i}=We(r,{geometry:e,timeExtent:t});if(n)return{isOutSide:!0,timeExtent:null,mosaicRule:null};i?.timeExtent!=null&&(t=i.timeExtent)}if(n=this._combineMosaicRuleWithTimeExtent(n,t),n?.multidimensionalDefinition){let{isOutside:e}=We(r,{multidimensionalDefinition:n.multidimensionalDefinition});if(e)return{isOutSide:!0,timeExtent:null,mosaicRule:null}}return{isOutSide:!1,timeExtent:t,mosaicRule:n}}_updateFeatureWithRasterAttributeTableValues(e,t){let n=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(n==null)return;let{features:r,fields:i}=n,a=i.map(e=>e.name).find(e=>e.toLowerCase()===`value`);if(!a)return;let o=r.filter(e=>e.attributes[a]===(t==null?null:parseInt(t,10)));o&&o[0]&&i.forEach(t=>{let n=`Raster.`+t.name;e.attributes[n]=o[0].attributes[t.name]})}_updateFeatureWithMagDirValues(e,t){if(!this._isVectorDataSet())return;let n=t.split(/,\s*/).map(e=>parseFloat(e)),r=n.map(e=>[e]),i=n.map(e=>({minValue:e,maxValue:e,noDataValue:null})),a=new lt({height:1,width:1,pixelType:`f32`,pixels:r,statistics:i});this.pixelFilter!=null&&this.pixelFilter({pixelBlock:a,extent:new ke(0,0,0,0,this.spatialReference)});let o=this.serviceDataType===`esriImageServiceDataTypeVector-MagDir`?[a.pixels[0][0],a.pixels[1][0]]:dt([a.pixels[0][0],a.pixels[1][0]]);e.attributes[Et.magnitude]=o[0],e.attributes[Et.direction]=o[1]}_updateFeatureWithDomainValues(e){(this.fields&&this.fields.filter(e=>e.domain?.type===`coded-value`))?.forEach(t=>{let n=e.attributes[t.name];if(n!=null){let r=t.domain.codedValues.find(e=>e.code===n);r&&(e.attributes[t.name]=r.name)}})}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;let n=this.fieldsIndex;n!=null&&e.forEach(e=>{if(e?.attributes)for(let r of t){let t=n.get(r)?.name;t&&t!==r&&(e.attributes[r]=e.attributes[t],delete e.attributes[t])}})}_getRenderingRuleString(e){if(e){let t=e.toJSON();return t=t.rasterFunctionDefinition??t,(t.thumbnail||t.thumbnailEx)&&(t.thumbnail=t.thumbnailEx=null),JSON.stringify(t)}return null}_hasRasterFunction(e){return e?.functionName!=null&&e.functionName.toLowerCase()!==`none`}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if(e===`Raw`)return e.replace(`Raw`,`None`);let n=e.toLowerCase().replaceAll(/ /gi,`_`);return t.has(n)?t.get(n):e}_isRFTJson(e){return e?.name&&e.arguments&&e.function&&e.hasOwnProperty(`functionType`)}_isVectorDataSet(){return this.serviceDataType===`esriImageServiceDataTypeVector-UV`||this.serviceDataType===`esriImageServiceDataTypeVector-MagDir`}_applyMosaicAndRenderingRules(e){let{raster:t,mosaicRule:n,rasterFunction:r}=this;r&&e.rasterFunction==null&&(e.rasterFunction=r),n&&e.mosaicRule==null&&(e.mosaicRule=n),t&&e.raster==null&&(e.raster=t)}async _updateCurrentRasterInfo(e){if(this.renderer||this.symbolizer){let t=await this._generateRasterInfo(this.rasterFunction,{signal:e});t&&(this.rasterInfo=t)}}_applyMosaicRule(e){let{raster:t,mosaicRule:n}=this;n&&e.mosaicRule==null&&(e.mosaicRule=n),t&&e.raster==null&&(e.raster=t)}_readCapabilities(e){let t=e.capabilities?e.capabilities.toLowerCase().split(`,`).map(e=>e.trim()):[`image`,`catalog`],{currentVersion:n,maxRecordCount:r}=e,i=t.includes(`image`),a=e.serviceDataType===`esriImageServiceDataTypeElevation`,o=!(!e.spatialReference&&!e.extent?.spatialReference),s=t.includes(`edit`),c=t.includes(`mensuration`)&&o,l=e.mensurationCapabilities==null?[]:e.mensurationCapabilities.toLowerCase().split(`,`).map(e=>e.trim()),u=c&&l.includes(`basic`),d=this._isMosaicDataset(e)&&t.includes(`catalog`),f=t.includes(`download`),p=n>=10.7&&a||n>=11.4&&(a||c&&l.includes(`3d`)),m=d&&e.fields&&e.fields.length>0,h=m&&e.supportsAdvancedQueries?e.advancedQueryCapabilities:void 0;return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:i,supportsExportImage:i,supportsIdentify:i,supportsImageToMap:n>=11.2&&d,supportsImageToMapMultiray:n>=11.2&&d,supportsMapToImage:n>=11.2&&d,supportsFindImages:n>=11.2&&d,supportsGetImageUrl:n>=11.3&&f,supportsMeasure:c,supportsMeasureFromImage:n>=11.2,supportsDownload:f,supportsQuery:m,supportsGetSamples:n>=10.2&&i,supportsProject:n>=10.3&&i,supportsComputeStatisticsHistograms:n>=10.4&&i,supportsQueryBoundary:n>=10.6&&i,supportsCalculateVolume:p,supportsComputePixelLocation:n>=10.7&&d,supportsComputeAngles:n>=10.91,supportsQueryGPSInfo:n>=11.2&&d,supportsAdd:s,supportsDelete:s,supportsEditing:s,supportsUpdate:s,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryBins:!1,supportsQueryPivot:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:r,maxRecordCountFactor:void 0,maxUniqueIDCount:void 0,supportsStatistics:!!h?.supportsStatistics,supportsOrderBy:!!h?.supportsOrderBy,supportsDistinct:!!h?.supportsDistinct,supportsPagination:!!h?.supportsPagination,supportsPaginationOnAggregatedQueries:!!h?.supportsPaginationOnAggregatedQueries,supportsStandardizedQueriesOnly:!!h?.useStandardizedQueries,supportsPercentileStatistics:!!h?.supportsPercentileStatistics,supportsCentroid:!!h?.supportsReturningGeometryCentroid,supportsCentroidOnDegeneratedQuantizedGeometry:!1,supportsCurrentUser:!1,supportsDegeneratedQuantizedGeometry:!1,supportsDistance:!!h?.supportsQueryWithDistance,supportsExtent:!!h?.supportsReturningQueryExtent,supportsGeometryProperties:!!h?.supportsReturningGeometryProperties,supportsHavingClause:!!h?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsReturnMesh:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:h?.supportsSqlExpression??!!h,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!h?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0,supportsTrueCurve:!1},mensuration:{supportsDistanceAndAngle:u,supportsAreaAndPerimeter:u,supportsPointOrCentroid:u,supportsHeightFromBaseAndTop:c&&l.includes(`base-top height`),supportsHeightFromBaseAndTopShadow:c&&l.includes(`base-top shadow height`),supportsHeightFromTopAndTopShadow:c&&l.includes(`top-top shadow height`),supports3D:c&&l.includes(`3d`)}}}};function s(e){return e?.path??``}return O([i({clonable:!1})],r.prototype,`_functionRasterInfos`,void 0),O([i({readOnly:!0})],r.prototype,`_serviceSupportsMosaicRule`,void 0),O([T(`_serviceSupportsMosaicRule`,[`currentVersion`,`fields`])],r.prototype,`readServiceSupportsMosaicRule`,null),O([i({readOnly:!0})],r.prototype,`_rasterFunctionNamesIndex`,null),O([i()],r.prototype,`adjustAspectRatio`,void 0),O([i({type:[se],json:{write:!0}})],r.prototype,`bandIds`,void 0),O([T(`bandIds`)],r.prototype,`readBandIds`,null),O([i({readOnly:!0,json:{read:!1}})],r.prototype,`capabilities`,void 0),O([T(`service`,`capabilities`,[`capabilities`,`currentVersion`,`serviceDataType`])],r.prototype,`readCapabilities`,null),O([i({type:Number})],r.prototype,`compressionQuality`,void 0),O([C(`compressionQuality`)],r.prototype,`writeCompressionQuality`,null),O([i({type:Number})],r.prototype,`compressionTolerance`,void 0),O([C(`compressionTolerance`)],r.prototype,`writeCompressionTolerance`,null),O([i({json:{read:{source:`copyrightText`}}})],r.prototype,`copyright`,void 0),O([i({readOnly:!0,dependsOn:[`_serviceSupportsMosaicRule`]})],r.prototype,`defaultMosaicRule`,void 0),O([T(`defaultMosaicRule`,[`defaultMosaicMethod`])],r.prototype,`readDefaultMosaicRule`,null),O([i({type:String,json:{name:`layerDefinition.definitionExpression`,write:{enabled:!0,allowNull:!0}}})],r.prototype,`definitionExpression`,void 0),O([i({readOnly:!0,constructOnly:!0})],r.prototype,`exportImageServiceParameters`,void 0),O([i()],r.prototype,`rasterInfo`,void 0),O([i({readOnly:!0,type:[de]})],r.prototype,`fields`,void 0),O([i({readOnly:!0})],r.prototype,`fieldsIndex`,null),O([i({type:[`png`,`png8`,`png24`,`png32`,`jpg`,`bmp`,`gif`,`jpgpng`,`lerc`,`tiff`,`bip`,`bsq`],json:{write:!0}})],r.prototype,`format`,null),O([T(`service`,`format`,[`serviceDataType`])],r.prototype,`readFormat`,null),O([i({type:ke})],r.prototype,`fullExtent`,void 0),O([i({readOnly:!0})],r.prototype,`hasMultidimensions`,void 0),O([i({json:{read:{source:`maxImageHeight`}}})],r.prototype,`imageMaxHeight`,void 0),O([i({json:{read:{source:`maxImageWidth`}}})],r.prototype,`imageMaxWidth`,void 0),O([i({type:String,json:{type:st.jsonValues,read:st.read,write:st.write}})],r.prototype,`interpolation`,void 0),O([i()],r.prototype,`minScale`,void 0),O([T(`service`,`minScale`)],r.prototype,`readMinScale`,null),O([i()],r.prototype,`maxScale`,void 0),O([T(`service`,`maxScale`)],r.prototype,`readMaxScale`,null),O([i({type:M})],r.prototype,`mosaicRule`,null),O([T(`mosaicRule`,[`mosaicRule`,`defaultMosaicMethod`])],r.prototype,`readMosaicRule`,null),O([C(`mosaicRule`)],r.prototype,`writeMosaicRule`,null),O([i()],r.prototype,`multidimensionalInfo`,void 0),O([i({type:ft,json:{write:!0}})],r.prototype,`multidimensionalSubset`,void 0),O([i({json:{type:se}})],r.prototype,`noData`,void 0),O([C(`noData`)],r.prototype,`writeNoData`,null),O([i({type:String,json:{type:Ye.jsonValues,read:Ye.read,write:Ye.write}})],r.prototype,`noDataInterpretation`,void 0),O([i({type:String,readOnly:!0,json:{read:{source:[`fields`]}}})],r.prototype,`objectIdField`,void 0),O([T(`objectIdField`)],r.prototype,`readObjectIdField`,null),O([i({readOnly:!0})],r.prototype,`geometryType`,void 0),O([i({})],r.prototype,`typeIdField`,void 0),O([i({})],r.prototype,`types`,void 0),O([i({readOnly:!0})],r.prototype,`parsedUrl`,null),O([i({type:Function})],r.prototype,`pixelFilter`,void 0),O([i()],r.prototype,`raster`,void 0),O([i({readOnly:!0})],r.prototype,`sourceType`,void 0),O([T(`sourceType`,[`serviceSourceType`,`fields`])],r.prototype,`readSourceType`,null),O([i()],r.prototype,`viewId`,void 0),O([i({types:St})],r.prototype,`renderer`,null),O([i({types:St,json:{name:`layerDefinition.drawingInfo.renderer`,origins:{"web-scene":{types:mt,name:`layerDefinition.drawingInfo.renderer`,write:{overridePolicy:e=>({enabled:e&&e.type!==`vector-field`})}}}}})],r.prototype,`internalRenderer`,null),O([T(`internalRenderer`)],r.prototype,`readRenderer`,null),O([C(`internalRenderer`)],r.prototype,`writeRenderer`,null),O([i({clonable:!1})],r.prototype,`symbolizer`,void 0),O([i(h)],r.prototype,`opacity`,void 0),O([i({readOnly:!0})],r.prototype,`rasterFields`,null),O([i({constructOnly:!0})],r.prototype,`rasterFunctionInfos`,void 0),O([i({type:N,json:{name:`renderingRule`}})],r.prototype,`rasterFunction`,null),O([T(`rasterFunction`,[`renderingRule`,`rasterFunctionInfos`])],r.prototype,`readRasterFunction`,null),O([i({readOnly:!0})],r.prototype,`serviceDataType`,void 0),O([i({readOnly:!0,type:y})],r.prototype,`spatialReference`,void 0),O([T(`spatialReference`,[`spatialReference`,`extent`])],r.prototype,`readSpatialReference`,null),O([i({type:it.apiValues,json:{read:it.read,type:it.jsonValues}})],r.prototype,`pixelType`,void 0),O([C(`pixelType`)],r.prototype,`writePixelType`,null),O([i({constructOnly:!0,type:nt})],r.prototype,`serviceRasterInfo`,void 0),O([i()],r.prototype,`sourceJSON`,void 0),O([i(v)],r.prototype,`url`,void 0),O([i({readOnly:!0})],r.prototype,`version`,void 0),O([T(`version`,[`currentVersion`,`fields`,`timeInfo`])],r.prototype,`readVersion`,null),r=O([w(`esri.layers.mixins.ArcGISImageService`)],r),r},$=class extends Oe(te(n(_(b(Vt(Dr(Ct(_e(fe(xe(ae(A(re))))))))))))){constructor(...t){super(...t),this.graphicOrigin=new Ut(this),this.isReference=null,this.operationalLayerType=`ArcGISImageServiceLayer`,this.popupEnabled=!0,this.popupTemplate=null,this.screenSizePerspectiveEnabled=!0,this.type=`imagery`,this._debouncedSaveOperations=Ee(async(t,n,r)=>{let{save:i,saveAs:a}=await e(async()=>{let{save:e,saveAs:t}=await import(`./imageryUtils-CkENtvf8.js`);return{save:e,saveAs:t}},__vite__mapDeps([0,1,2,3,4,5,6]));switch(t){case 0:return i(this,n);case 1:return a(this,r,n)}})}normalizeCtorArgs(e,t){return typeof e==`string`?{url:e,...t}:e}load(e){let t=e==null?null:e.signal;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:[`Image Service`]},e).catch(Te).then(()=>this._fetchService(t))),Promise.resolve(this)}set elevationInfo(e){e?.mode!==`relative-to-scene`&&this._set(`elevationInfo`,e),this._validateElevationInfo(e)}get legendEnabled(){return!this._isPreviewLayer&&(this._get(`legendEnabled`)??!0)}set legendEnabled(e){this._set(`legendEnabled`,e)}get listMode(){return this._isPreviewLayer?`hide`:this._get(`listMode`)}set listMode(e){this._set(`listMode`,e)}writeOperationalLayerType(e,t,n){t[n]=this.renderer?.type===`vector-field`?`ArcGISImageServiceVectorLayer`:`ArcGISImageServiceLayer`}get defaultPopupTemplate(){return this.createPopupTemplate()}get _isPreviewLayer(){return!(!this.raster||!this.url?.toLowerCase().includes(`/rasterrendering/imageserver`))}createPopupTemplate(e){let{rasterFields:t}=this,n=new Set,r=Et.itemPixelValue.toLowerCase(),i=this.sourceType===`raster-dataset`,a=Lt.toLowerCase(),o=`${Et.servicePixelValue.toLowerCase()}.`;for(let e of t){let t=e.name.toLowerCase();t===r||t.startsWith(o)||i&&t.startsWith(a)||n.add(e.name)}let s=oe({fields:t,title:this.title},{...e,visibleFieldNames:n}),{rasterInfo:c}=this;return s?.fieldInfos&&c&&kt(s.fieldInfos,c),s}queryFeatures(e,t){return this.queryRasters(e,t).then(e=>{if(e?.features)for(let t of e.features)t.layer=t.sourceLayer=this,t.origin=this.graphicOrigin;return e})}queryFeatureCount(e,t){return this.queryRasterCount(e,t)}redraw(){this.emit(`redraw`)}async save(e){return this._debouncedSaveOperations(0,e)}async saveAs(e,t){return this._debouncedSaveOperations(1,t,e)}serviceSupportsSpatialReference(e){return Me(this,e)}write(e,n){if(!this._isPreviewLayer)return super.write(e,n);if(n?.messages){let e=`${n.origin}/${n.layerContainerType||`operational-layers`}`;n.messages.push(new t(`layer:unsupported`,`Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e}'`,{layer:this}))}return null}_validateElevationInfo(e){Le(o.getLogger(this),Re(`Imagery layers`,`relative-to-scene`,e)),Le(o.getLogger(this),Ie(`Imagery layers`,e))}};O([i({type:Pe,value:null,json:{name:`layerDefinition.elevationInfo`,write:!0,origins:{"portal-item":{read:!1,write:!1},"web-map":{read:!1,write:!1}}}})],$.prototype,`elevationInfo`,null),O([i({readOnly:!0,clonable:!1})],$.prototype,`graphicOrigin`,void 0),O([i(s)],$.prototype,`legendEnabled`,null),O([i({type:[`show`,`hide`]})],$.prototype,`listMode`,null),O([i({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],$.prototype,`isReference`,void 0),O([i({type:[`ArcGISImageServiceLayer`],json:{origins:{"web-map":{type:[`ArcGISImageServiceLayer`,`ArcGISImageServiceVectorLayer`],read:!1,write:{target:`layerType`,ignoreOrigin:!0}}}}})],$.prototype,`operationalLayerType`,void 0),O([C(`web-map`,`operationalLayerType`)],$.prototype,`writeOperationalLayerType`,null),O([i(r)],$.prototype,`popupEnabled`,void 0),O([i({type:pe,json:{read:{source:`popupInfo`},write:{target:`popupInfo`}}})],$.prototype,`popupTemplate`,void 0),O([i({readOnly:!0})],$.prototype,`defaultPopupTemplate`,null),O([i(ee)],$.prototype,`screenSizePerspectiveEnabled`,void 0),O([i({readOnly:!0,json:{read:!1}})],$.prototype,`type`,void 0),O([i({readOnly:!0})],$.prototype,`_isPreviewLayer`,null),$=O([w(`esri.layers.ImageryLayer`)],$);var Or=$;export{Or as default};