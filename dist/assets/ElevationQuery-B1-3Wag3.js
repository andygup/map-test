import{$T as e,$x as t,BT as n,CE as r,DT as i,Ex as a,Kg as o,Lx as s,Px as c,VT as l,Vg as u,Xb as d,Yb as f,dD as p,fT as m,ix as h,jg as g,kD as _,lx as v,mx as y,sT as b,vv as x,yg as S}from"./index-BN8X5Ryz.js";import{t as C}from"./GeometryDescriptor-CmFSJK3t.js";var w=class{constructor(e,t){this.layer=e,this.parameters=t}},ee=class extends w{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type=`geometry`}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(e=>e.tile=null);else{let{tileInfo:t,tilemapCache:n}=this.layer,r=D(t,n)[e].level;this.geometry.coordinates.forEach(e=>e.tile=t.tileAt(r,e.x,e.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(let e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(let t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(let t of this.geometry.coordinates){let n=t.tile?.id;t.tile=n?e[n]:null}}getTilesToFetch(){return p(this.geometry.coordinates.filter(({tile:e,elevationTile:t})=>e?.id&&!t),(e,t)=>e.tile?.id===t.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(let t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>t.tile=null)}},T=class extends w{constructor(e,t,n,r){super(e,n),this.maskExtents=r,this.type=`extent`,this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.clone().intersection(e.fullExtent)}selectTilesAtLOD(e,t){let n=this._maximumLodForRequests(t),r=Math.min(n,e);r<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(r)}_maximumLodForRequests(e){let{tileInfo:t,tilemapCache:n}=this.layer,r=D(t,n);if(!e)return r.length-1;let i=this.extent;if(i==null)return-1;for(let n=r.length-1;n>=0;n--){let a=r[n],o=a.resolution*t.size[0],s=a.resolution*t.size[1];if(Math.ceil(i.width/o)*Math.ceil(i.height/s)<=e)return n}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(let t of this._candidateTiles){let n=t.id&&e[t.id];n&&(this._fetchedCandidates.add(t),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=O(this._candidateTiles.map(t=>e[t.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){let n=this._candidateTiles;this._candidateTiles=[],n.forEach(n=>{if(this._fetchedCandidates.has(n))return void t?.(n);let r=!1;e(n,()=>r=!0),r?t?.(n):this._candidateTiles.push(n)}),this._candidateTiles=O(this._candidateTiles,t)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;let t=this.extent;if(t==null)return;let{tileInfo:n,tilemapCache:r}=this.layer,i=D(n,r)[e],a=n.tileAt(i.level,t.xmin,t.ymin),o=a.extent,s=i.resolution*n.size[0],c=i.resolution*n.size[1],l=Math.ceil((t.xmax-o[0])/s),u=Math.ceil((t.ymax-o[1])/c);for(let e=0;e<u;e++)for(let t=0;t<l;t++){let r=new g(a.level,a.row-e,a.col+t);n.updateTileInfo(r),this._tileIsMasked(r)||this._candidateTiles.push(r)}}_tileIsMasked(e){return this.maskExtents?.some(t=>f(t,e.extent))??!1}};function E(e){return e?.tileInfo!=null}function D(e,t){let n=e.lods;if(E(t)){let{effectiveMinLOD:e,effectiveMaxLOD:r}=t;return n.filter(t=>t.level>=e&&t.level<=r)}return n}function O(e,t){let n={},r=[];for(let i of e){let e=i.id;e&&!n[e]?(n[e]=i,r.push(i)):t?.(i)}let i=r.sort((e,t)=>e.level-t.level);return i.filter((e,n)=>{for(let r=0;r<n;r++){let n=i[r].extent;if(n&&f(n,e.extent))return t?.(e),!1}return!0})}var k=class{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}},A=class{constructor(e,t=null){if(this.key=e,t!=null){let n=e.extent;this._samplerData=new k(t,n)}}get zmin(){return this._samplerData==null?0:this._samplerData.data.minValue}get zmax(){return this._samplerData==null?0:this._samplerData.data.maxValue}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,t){if(this._samplerData==null)return;let{safeWidth:n,data:r,dx:i,dy:a,y1:o,x0:s}=this._samplerData,{width:c,values:l,noDataValue:u}=r,d=j(a*(o-t),0,n),f=j(i*(e-s),0,n),p=Math.floor(d),m=Math.floor(f),h=p*c+m,g=h+c,_=l[h],v=l[g],y=l[h+1],b=l[g+1];if(_!==u&&v!==u&&y!==u&&b!==u){let e=f-m,t=_+(y-_)*e;return t+(v+(b-v)*e-t)*(d-p)}}};function j(e,t,n){return e<t?t:e>n?n:e}var M=class extends x{queryElevation(e){let t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case`point`:return N(e,t,this);case`polyline`:return P(e,t,this);case`multipoint`:return F(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;let n=e.spatialReference;if(n.equals(t))return e;let i=c(e,t);return i||r.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),i}};function N(e,t,n){return e.hasZ=!0,e.z=n.elevationAt(t.x,t.y),e}function P(e,t,n){I.spatialReference=t.spatialReference;let r=e.hasM&&!e.hasZ;for(let i=0;i<e.paths.length;i++){let a=e.paths[i],o=t.paths[i];for(let e=0;e<a.length;e++){let t=a[e],i=o[e];I.x=i[0],I.y=i[1],r&&(t[3]=t[2]),t[2]=n.elevationAt(I.x,I.y)}}return e.hasZ=!0,e}function F(e,t,n){I.spatialReference=t.spatialReference;let r=e.hasM&&!e.hasZ;for(let i=0;i<e.points.length;i++){let a=e.points[i],o=t.points[i];I.x=o[0],I.y=o[1],r&&(a[3]=a[2]),a[2]=n.elevationAt(I.x,I.y)}return e.hasZ=!0,e}M=_([l(`esri.layers.support.ElevationSampler`)],M);var I=new a,L=class extends M{get spatialReference(){return this.extent.spatialReference}constructor(e){let t=e.noDataValue,n=`tiles`in e?e.tiles.map(n=>new R({tile:n,tileInfo:e.tileInfo,noDataValue:t})):e.samplers;super({noDataValue:t,samplers:n});let r=n[0];if(r){this.extent=r.extent.clone();let{min:e,max:t}=r.demResolution;this.demResolution={min:e,max:t};for(let e=1;e<n.length;e++){let t=n[e];this.extent.union(t.extent),this.demResolution.min=Math.min(this.demResolution.min,t.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,t.demResolution.max)}}else{let t=`tileInfo`in e?e.tileInfo:null;this.extent=v(y(),t?.spatialReference??s.WGS84),this.demResolution={min:0,max:0}}}elevationAt(e,t){let n;for(let r of this.samplers)if(r.containsAt(e,t)&&(n=r.elevationAt(e,t),n!==r.noDataValue))return n;return n??(r.getLogger(this).warn(`#elevationAt()`,`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}};_([n({constructOnly:!0})],L.prototype,`noDataValue`,void 0),_([n({constructOnly:!0})],L.prototype,`samplers`,void 0),L=_([l(`esri.layers.support.TileElevationSampler`)],L);var R=class extends M{get spatialReference(){return this.extent.spatialReference}constructor(e){super(e);let n=e.tile.key.extent;this.extent=v(n,e.tileInfo.spatialReference),this.extent.zmin=e.tile.zmin,this.extent.zmax=e.tile.zmax;let r=t(e.tileInfo.spatialReference),i=e.tileInfo.lodAt(e.tile.key.level).resolution*r;this.demResolution={min:i,max:i}}contains(e){let t=this.projectIfRequired(e,this.spatialReference);return t!=null&&this.containsAt(t.x,t.y)}containsAt(e,t){return d(this.tile.key.extent,e,t)}elevationAt(e,t){return this.containsAt(e,t)?this.tile.sample(e,t)??this.noDataValue:this.noDataValue}};_([n({constructOnly:!0})],R.prototype,`tile`,void 0),_([n({constructOnly:!0})],R.prototype,`noDataValue`,void 0),_([n({constructOnly:!0})],R.prototype,`tileInfo`,void 0),R=_([l(`esri.layers.support.TileElevationSampler.SingleTileElevationSampler`)],R);async function z(t,n,r){if(t=r?.ignoreInvisibleLayers?t.filter(e=>e.visible):t.slice(),!t.length)throw new e($,`Elevation queries require at least one elevation layer to fetch tiles from`);let i=C.fromGeometry(n),a={...Z,...r,returnSampleInfo:!0},o=t.pop(),s=await B(o,i,a),c=await W(t,s,a);return c.geometry=c.geometry.export(),r?.returnSampleInfo||delete c.sampleInfo,c}async function B(t,n,r){if(!t)throw new e($,`Elevation queries require an elevation layer to fetch tiles from`);if(!n||!(n instanceof C)&&n.type!==`point`&&n.type!==`multipoint`&&n.type!==`polyline`)throw new e(`elevation-query:invalid-geometry`,`Only point, polyline and multipoint geometries can be used to query elevation`);let i={...Z,...r},a=new ee(t,n.spatialReference,i),o=i.signal;return await t.load({signal:o}),await te(a,n,o),await G(a,o),await Q(a,o),se(a),ce(a,o)}async function V(t,n,r){if(t=Array.isArray(t)?t:[t],(t=r?.ignoreInvisibleLayers?t.filter(e=>e.visible):t.slice()).length===0)throw new e($,`Elevation queries require at least one elevation layer to fetch tiles from`);if(!n||n.type!==`extent`)throw new e(`elevation-query:invalid-extent`,`Invalid or undefined extent`);let i={...Z,...r,returnSampleInfo:!0},a=H(t[t.length-1],n,i);return t.length===1?a:U(t,n,await a,i)}async function H(e,t,n,r){let i=n.signal;await e.load({signal:i});let a=t.spatialReference,s=e.tileInfo.spatialReference;a.equals(s)||(await u([{source:a,dest:s}],{signal:i}),t=o(t,s));let c=new T(e,t,n,r);await G(c,i),await Q(c,i);let l=c.elevationTiles,d=c.layer.tileInfo,f=c.parameters.noDataValue;return new L({noDataValue:f,tiles:l,tileInfo:d})}async function U(e,t,n,r){if(e.pop(),!e.length)return n;let i=n.samplers.filter(e=>!e.tile.hasNoDataValues).map(e=>h(e.extent)),a=await H(e[e.length-1],t,r,i);if(a.samplers.length===0)return n;let o=n.samplers.concat(a.samplers),s=r.noDataValue;return U(e,t,new L({samplers:o,noDataValue:s}),r)}async function W(e,t,n){let r=t.geometry.coordinates,a=t.sampleInfo;i(a);let o=[],s=[];for(let t=0;t<r.length;t++)a[t].demResolution<0&&e.length&&(o.push(r[t]),s.push(t));let c=e.pop();if(c==null||o.length===0)return t;let l=t.geometry.clone(o),u=await B(c,l,n),d=u.sampleInfo;if(!d)throw Error(`no sampleInfo`);return s.forEach((e,t)=>{r[e].z=u.geometry.coordinates[t].z,a[e].demResolution=d[t].demResolution,a[e].source=d[t].source}),W(e,t,n)}async function G(t,n){t.type===`geometry`&&ne(t);let r=t.parameters.demResolution;if(typeof r==`number`)ie(t,r);else if(r===`finest-contiguous`)await K(t,n);else{if(r!==`auto`)throw new e(`elevation-query:invalid-dem-resolution`,`Invalid dem resolution value '${r}', expected a number, "finest-contiguous" or "auto"`);await J(t,n)}}async function K(e,t){let{tileInfo:n,tilemapCache:r}=e.layer,i=X(n,r,e.parameters.minDemResolution);await q(e,i,t)}async function q(t,n,r){let i=t.layer;if(t.selectTilesAtLOD(n),n<0)return;let a=i.tilemapCache,o=t.getTilesToFetch();try{if(a&&!E(a))await m(Promise.all(o.map(e=>a.fetchAvailability(e.level,e.row,e.col,{signal:r}))),r);else if(await Q(t,r),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new e(`elevation-query:has-unavailable-tiles`,`Some elevation tiles are unavailable`)}catch(e){b(e),await q(t,n-1,r)}}async function J(e,t){ae(e),oe(e);let n=e.layer.tilemapCache;if(!n||E(n))return Y(e,t);let r=e.getTilesToFetch(),i={},a=r.map(async e=>{let r=new g(0,0,0),a=await S(n.fetchAvailabilityUpsample(e.level,e.row,e.col,r,{signal:t}));!1===a.ok?b(a.error):e.id!=null&&(i[e.id]=r)});await m(Promise.all(a),t),e.remapTiles(i)}async function Y(e,t){let n=e.layer.tileInfo;await Q(e,t);let r=!1;e.forEachTileToFetch((e,t)=>{n.upsampleTile(e)?r=!0:t()}),r&&await Y(e,t)}function X(e,n,r=0){let i=D(e,n),a=i.length-1;if(r>0){let n=r/t(e.spatialReference),o=i.findIndex(e=>e.resolution<n);o===0?a=0:o>0&&(a=o-1)}return a}var Z={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:`auto`,minDemResolution:0,signal:null};async function te(t,n,r){let i,a=t.layer.tileInfo.spatialReference;if(n instanceof C?i=await n.project(a,r):(await u([{source:n.spatialReference,dest:a}],{signal:r}),i=o(n,a)),!i)throw new e(`elevation-query:spatial-reference-mismatch`,`Cannot query elevation in '${n.spatialReference.wkid}' on an elevation service in '${a.wkid}'`);t.geometry=C.fromGeometry(i)}function ne(e){if(e.layer.fullExtent==null)return;let t=new A(new g(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;let n=e.layer.fullExtent;e.geometry.coordinates.forEach(e=>{let r=e.x,i=e.y;(r<n.xmin||r>n.xmax||i<n.ymin||i>n.ymax)&&(e.elevationTile=t)})}function re(e,n){let{tileInfo:r,tilemapCache:i}=e.layer,a=n/t(r.spatialReference),o=D(r,i),s=o[0],c=0;for(let e=1;e<o.length;e++){let t=o[e];Math.abs(t.resolution-a)<Math.abs(s.resolution-a)&&(s=t,c=e)}return c}function ie(e,t){let n=re(e,t);e.selectTilesAtLOD(n)}function ae(e){let{tileInfo:t,tilemapCache:n}=e.layer,r=X(t,n,e.parameters.minDemResolution);e.selectTilesAtLOD(r,e.parameters.maximumAutoTileRequests)}async function Q(e,t){let n=e.getTilesToFetch(),r={},i=e.parameters.cache,a=e.parameters.noDataValue,o={noDataValue:a,signal:t},s=n.map(async t=>{if(t.id==null)return;let n=`${e.layer.uid}:${t.id}:${a}`,s=i?.get(n),c=s??await e.layer.fetchTile(t.level,t.row,t.col,o);i?.put(n,c),r[t.id]=new A(t,c)});await m(Promise.allSettled(s),t),e.populateElevationTiles(r)}function oe(e){let t=e.layer.tileInfo,n=0,r={},i=e=>{e.id!=null&&(e.id in r?r[e.id]++:(r[e.id]=1,n++))},a=e=>{if(e.id==null)return;let t=r[e.id];t===1?(delete r[e.id],n--):r[e.id]=t-1};e.forEachTileToFetch(i,a);let o=!0;for(;o&&(o=!1,e.forEachTileToFetch(r=>{n<=e.parameters.maximumAutoTileRequests||(a(r),t.upsampleTile(r)&&(o=!0),i(r))},a),o););}function se(e){e.geometry.coordinates.forEach(t=>{let n=t.elevationTile,r=e.parameters.noDataValue;if(n){let e=n.sample(t.x,t.y);e==null?t.elevationTile=null:r=e}t.z=r})}async function ce(e,t){let n=await e.geometry.project(e.outSpatialReference,t);i(n);let r={geometry:n.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(r.sampleInfo=le(e)),e.geometry.coordinates.forEach(e=>{e.tile=null,e.elevationTile=null}),r}function le(e){let n=e.layer.tileInfo,r=t(n.spatialReference);return e.geometry.coordinates.map(t=>{let i=-1;return t.elevationTile&&t.elevationTile!==e.outsideExtentTile&&(i=n.lodAt(t.elevationTile.key.level).resolution*r),{demResolution:i,source:i===-1?void 0:e.layer}})}var $=`elevation-query:invalid-layer`;export{$ as InvalidLayerError,V as createSampler,Z as defaultOptions,X as getFinestLodIndex,B as query,z as queryAll};