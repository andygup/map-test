const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/projectBuffer-4IiBedaM.js","assets/index-CzMixifc.js","assets/index-CDgdHpAj.css","assets/projectionUtils-B7CQOzZM.js","assets/projectMeshVertexPositions-BE6vKAN1.js","assets/vec3-D13Z1xO0.js","assets/vec4-CJBDH7oG.js","assets/computeTranslationToOriginAndRotation-DwwRDWAD.js","assets/projectPointToVector-D72S8Uh5.js","assets/spatialReferenceEllipsoidUtils-b6wDfyu0.js","assets/MeshLocalVertexSpace-Dfv_NBsU.js","assets/BufferView-BPABY7if.js","assets/Util-YNFIi00s.js","assets/projectMeshVertexPositions-Cs04NHNO.js","assets/vertexSpaceConversion-WXuyjrGI.js","assets/meshVertexSpaceUtils-CrM2H6JB.js"])))=>i.map(i=>d[i]);
import{BS as e,LS as t,Lf as n,Pf as r,c_ as i,ew as a,oT as o,wx as s}from"./index-CzMixifc.js";import{n as c,t as l}from"./MeshLocalVertexSpace-Dfv_NBsU.js";import"./projectPointToVector-D72S8Uh5.js";import{n as u,o as d}from"./vec3-D13Z1xO0.js";import"./dehydratedPoint-CVzHYxaL.js";import"./projectVectorToVector-CZxjcyx6.js";import"./WorkerHandle-CebpJ7hn.js";function f(){return m??=(async()=>await(await e(()=>import(`./i3s-DEQtLHCc.js`),[])).default({locateFile:e=>t(`esri/libs/i3s/${e}`)}))(),m}function p(){m=null}var m,h=class{constructor(e,t,n,r,i,a){this.layout=e,this.interleavedVertexData=t,this.indices=n,this.hasColors=r,this.hasModifications=i,this.positionData=a}},g=class{constructor(e,t,n,r,i,a,o){this.componentOffsets=e,this.featureIds=t,this.anchorIds=n,this.anchors=r,this.transformedGeometry=i,this.globalTrafo=a,this.obb=o}};new o({deallocator:null}),i();async function _(e){E=await P();let t=[e.geometryBuffer];return{result:O(E,e,t),transferList:t}}async function v(e){E=await P();let t=[e.geometryBuffer],{geometryBuffer:n}=e,r=n.byteLength,i=E._malloc(r),a=new Uint8Array(E.HEAPU8.buffer,i,r);a.set(new Uint8Array(n));let o=E.dracoDecompressPointCloudData(i,a.byteLength);if(E._free(i),o.error.length>0)throw Error(`i3s.wasm: ${o.error}`);let s=o.featureIds?.length>0?o.featureIds.slice():null,c=o.positions.slice();return s&&t.push(s.buffer),t.push(c.buffer),{result:{positions:c,featureIds:s},transferList:t}}async function y(e){await P(),A(e);let t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function b(e){await P(),D(e)}async function x(e){E=await P(),E.setLegacySchema(e.context,e.jsonSchema)}async function S(t){let{localMatrix:i,origin:a,positions:o,vertexSpace:u}=t,d=s.fromJSON(t.inSpatialReference),f=s.fromJSON(t.outSpatialReference),p=i?n(i):void 0,m=r(a),h,[{projectBuffer:g},{initializeProjection:_}]=await Promise.all([e(()=>import(`./projectBuffer-4IiBedaM.js`),__vite__mapDeps([0,1,2])),e(()=>import(`./projectionUtils-B7CQOzZM.js`),__vite__mapDeps([3,1,2]))]);await _(d,f);let v=[0,0,0];if(!g(m,d,0,v,f,0))throw Error(`Failed to project`);if(u.type===`georeferenced`&&u.origin==null){if(h=new Float64Array(o.length),!g(o,d,0,h,f,0,h.length/3))throw Error(`Failed to project`)}else{let t=u.type===`georeferenced`?c.fromJSON(u):l.fromJSON(u),{projectMeshVertexPositions:n}=await e(async()=>{let{projectMeshVertexPositions:e}=await import(`./projectMeshVertexPositions-BE6vKAN1.js`);return{projectMeshVertexPositions:e}},__vite__mapDeps([4,5,1,2,6,7,8,9,10,11,12,13,14,15])),r=n({vertexAttributes:{position:o},transform:p?{localMatrix:p}:void 0,vertexSpace:t,spatialReference:d},f);if(!r)throw Error(`Failed to project`);h=r}let y=h.length,[b,x,S]=v;for(let e=0;e<y;e+=3)h[e]-=b,h[e+1]-=x,h[e+2]-=S;return{result:{projected:h,original:o,projectedOrigin:v},transferList:[h.buffer,o.buffer]}}async function C({normalMatrix:e,normals:t}){let n=new Float32Array(t.length);return d(n,t,e),a(e)&&u(n,n),{result:{transformed:n,original:t},transferList:[n.buffer,t.buffer]}}function w(e){j(e)}var T,E;function D(e){if(!E)return;let t=e.modifications,n=E._malloc(8*t.length),r=new Float64Array(E.HEAPU8.buffer,n,t.length);for(let e=0;e<t.length;++e)r[e]=t[e];E.setModifications(e.context,n,t.length,e.isGeodetic),E._free(n)}function O(e,t,n){let{context:r,globalTrafo:i,mbs:a,obbData:o,elevationOffset:s,geometryBuffer:c,geometryDescriptor:l,indexToVertexProjector:u,vertexToRenderProjector:d}=t,f=e._malloc(c.byteLength),p=e._malloc(33*Float64Array.BYTES_PER_ELEMENT),m=new Uint8Array(e.HEAPU8.buffer,f,c.byteLength);m.set(new Uint8Array(c));let _=new Float64Array(e.HEAPU8.buffer,p,33);M(_,[NaN,NaN,NaN],0);let v=3;M(_,i,v),v+=16,M(_,a.center,v),v+=3,_[v++]=a.radius,o&&M(_,o,v++);let y=l,b={isDraco:!1,isLegacy:!1,color:t.layouts.some(e=>e.some(e=>e.name===`color`)),normal:t.needNormals&&t.layouts.some(e=>e.some(e=>e.name===`normalCompressed`)),uv0:t.layouts.some(e=>e.some(e=>e.name===`uv0`)),uvRegion:t.layouts.some(e=>e.some(e=>e.name===`uvRegion`)),featureIndex:y.featureIndex},x=e.process(r,!!t.obbData,f,m.byteLength,y,b,p,s,u,d,t.normalReferenceFrame);if(e._free(p),e._free(f),x.error.length>0)throw Error(`i3s.wasm: ${x.error}`);if(x.discarded)return null;let S=x.componentOffsets.length>0?x.componentOffsets.slice():null,C=x.featureIds.length>0?x.featureIds.slice():null,w=x.anchorIds.length>0?Array.from(x.anchorIds):null,T=x.anchors.length>0?Array.from(x.anchors):null,E=x.interleavedVertedData.slice().buffer,D=x.indicesType===1?new Uint16Array(x.indices.buffer,x.indices.byteOffset,x.indices.byteLength/2).slice():new Uint32Array(x.indices.buffer,x.indices.byteOffset,x.indices.byteLength/4).slice(),O=x.positions.slice(),{buffer:k,byteOffset:A,byteLength:j}=x.positionIndices,N=x.positionIndicesType===1?new Uint16Array(k,A,j/2).slice():new Uint32Array(k,A,j/4).slice(),P=new h(t.layouts[0],E,D,x.hasColors,x.hasModifications,{data:O,indices:N});return C&&n.push(C.buffer),S&&n.push(S.buffer),n.push(E),n.push(D.buffer),n.push(O.buffer),n.push(N.buffer),new g(S,C,w,T,P,i,x.obb)}function k(e){return e===0?0:e===1?1:e===2?2:3}function A(e){if(!E)return;let{context:t,buffer:n}=e,r=E._malloc(n.byteLength),i=n.byteLength/Float64Array.BYTES_PER_ELEMENT,a=new Float64Array(E.HEAPU8.buffer,r,i),o=new Float64Array(n);a.set(o),E.filterOBBs(t,r,i),o.set(a),E._free(r)}function j(e){E&&E.destroy(e)===0&&(E=null,T=null,p())}function M(e,t,n){for(let r=0;r<t.length;++r)e[r+n]=t[r]}async function N(){E||await P()}async function P(){return E||=await(T??=f()),E}var F={transform:(e,t)=>E&&O(E,e,t),destroy:j};export{w as destroyContext,v as dracoDecompressPointCloudData,y as filterObbsForModifications,A as filterObbsForModificationsSync,N as initialize,k as interpretObbModificationResults,_ as process,S as project,x as setLegacySchema,b as setModifications,D as setModificationsSync,F as test,C as transformNormals};