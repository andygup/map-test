import{$x as e,Aw as t,BT as n,Bl as r,Db as i,Eb as a,Ib as o,Ob as s,Pb as c,Rl as l,Uu as u,VT as d,cw as f,hv as p,jb as m,kD as h,kb as g,kl as _,lw as v,y_ as y}from"./index-BN8X5Ryz.js";import"./quatf64-D37SEdPg.js";import"./plane-Da5EsY0J.js";import"./vectorStacks-Cuo89CNO.js";import"./projectPointToVector-BkRdoTqD.js";import"./dehydratedPoint-CWZQBefp.js";import"./projectVectorToVector-DGzn2p7I.js";import"./memoize-Dl61_jt0.js";import{m as b}from"./elevationInfoUtils-uoMH3ofe.js";import"./ObjectStack-l5kM7JZu.js";import"./ray-LkJ58wpZ.js";import{d as x,r as S}from"./quantity-Co6flzuS.js";import"./geodesicUtils-D99LxQ6q.js";import{_ as C,c as w,g as T,h as E,i as D,l as O,o as k}from"./LineSnappingHint-CmFAetWF.js";import{n as A}from"./ParallelSnappingHint-CVYaPm-q.js";import{a as j,l as M,o as N,r as P}from"./snappingUtils-D3oTIKrZ.js";import"./vec3-B94Y7ih2.js";import"./sphere-d9-4vNcj.js";import{f as ee,u as te}from"./constraints-Ch5tsKD8.js";import"./SnappingCandidate-DueCLuvH.js";import{t as F}from"./LineSnappingCandidate-BNbhbOGH.js";import{n as I,t as L}from"./RightAngleTriangleSnappingCandidate-CqVuCsko.js";import"./RightAngleSnappingHint-tXLlHR_t.js";import{n as R,t as z}from"./viewUtils-GR2hLWLo.js";import"./viewUtils-H4dpIyqQ.js";import{c as B,n as V}from"./angularMeasurementUtils-DQYnovl-.js";var H=class{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=A.shortLineThreshold*A.shortLineThreshold}snap(e,t){return t.vertexHandle==null?this.snapNewVertex(e,t):t.vertexHandle.type===`vertex`?this.snapExistingVertex(e,t):[]}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(E(e.leftVertex.pos,this.view,t),E(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:n}){return this.squaredShortLineThreshold===0||P(z(t,n,b,this.view),z(e,n,b,this.view))>this.squaredShortLineThreshold}isVertical(t,n,{spatialReference:r}){let i=e(r);return c(C(t),C(n))*i<A.verticalLineThresholdMeters}squaredProximityThreshold(e){return e===`touch`?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){let{distance:e,touchSensitivityMultiplier:t}=this.options,n=e*t;return n*n}},U=class extends H{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=n.segments.length,i=[];if(r<1)return i;let{spatialReference:a}=t,o=z(e,a,b,this.view),{view:s}=this,c=n.segments[r-1],l=c;do{if(N(l)&&this.edgeExceedsShortLineThreshold(l,t)){let n=j(l,s,t);this._processCandidateProposal(n.left,n.right,e,o,t,i)}l=l.leftVertex.leftSegment}while(l&&l!==c);return i}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2)return n;let{view:a}=this,{spatialReference:o}=t,s=z(e,o,b,a),c=r.leftSegment,l=r.rightSegment;N(c)&&N(l)&&this.edgeExceedsShortLineThreshold(c,t)&&this.edgeExceedsShortLineThreshold(l,t)&&this._processCandidateProposal(E(c.leftVertex.pos,a,t),E(l.rightVertex.pos,a,t),e,s,t,n);let u=i.segments[0],d=u;do{if(N(d)&&d!==r.leftSegment&&d!==r.rightSegment&&this.edgeExceedsShortLineThreshold(d,t)){let r=j(d,a,t);this._processCandidateProposal(r.left,r.right,e,s,t,n)}d=d.rightVertex.rightSegment}while(d&&d!==u);return n}_processCandidateProposal(e,t,n,r,i,a){let{spatialReference:o,pointer:s}=i,c=y();W(c,e,t,n,i,this._geodesicLengthMeasurementUtils);let l=T(O(c));P(r,z(l,o,b,this.view))<this.squaredProximityThreshold(s)&&a.push(new F({lineStart:e,lineEnd:t,targetPoint:l,isDraped:i.elevationInfo?.mode===`on-the-ground`}))}};function W(e,t,n,r,i,a){G(e,t,n,r,i,a)||K(e,r,t,n)}function G(e,t,n,r,{spatialReference:i},a){let o=B(t,n,i,i);if(o==null)return!1;let s=B(n,r,i,i);if(s==null)return!1;let c=a.geodesicDistance(n,r,i);if(c==null)return!1;let l=Math.abs(v.shortestSignedDiff(o,s))>Math.PI/2?f.normalize(o+Math.PI):o;return V(e,n,i,x(c,`meters`),S(l,`radians`,`geographic`),`geodesic`),e[2]=r[2],!0}function K(e,t,n,r){ee(t,{start:n,end:r,type:1},e),e[2]=t[2]}var q=class extends H{snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=n.segments.length,i=n.vertices.length,a=[];if(r<2)return a;let{view:o}=this,s=z(e,t.spatialReference,b,o),c=n.vertices[0],l=n.vertices[i-1],u=N(l.leftSegment)?E(l.pos,o,t):null,d=N(c.rightSegment)?E(c.pos,o,t):null,f=n.segments[r-1],p=f;do{if(N(p)&&this.edgeExceedsShortLineThreshold(p,t)){let n=j(p,o,t);u&&this._checkEdgeForParallelLines(n,u,e,s,t,a),d&&this._checkEdgeForParallelLines(n,d,e,s,t,a)}p=p.leftVertex.leftSegment}while(p&&p!==f);return a}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<3)return n;let{view:a}=this,o=z(e,t.spatialReference,b,a),s=r.leftSegment,c=r.rightSegment,l=i.vertices[0],u=E(l.pos,a,t),d=i.vertices.length,f=i.vertices[d-1],p=E(f.pos,a,t),m=i.segments[0],h=m;do{if(N(h)&&h!==s&&h!==c&&this.edgeExceedsShortLineThreshold(h,t)){let i=j(h,a,t);N(s)&&this._checkEdgeForParallelLines(i,E(s.leftVertex.pos,a,t),e,o,t,n),N(c)&&this._checkEdgeForParallelLines(i,E(c.rightVertex.pos,a,t),e,o,t,n),r===l?this._checkEdgeForParallelLines(i,p,e,o,t,n):r===f&&this._checkEdgeForParallelLines(i,u,e,o,t,n)}h=h.rightVertex.rightSegment}while(h&&h!==m);return n}_checkEdgeForParallelLines(e,t,n,r,a,o){let s=e.left,c=e.right;if(k(Y,C(t),C(s),C(c)),i(Y,C(t))<A.parallelLineThreshold)return;k(Y,C(n),C(s),C(c),C(t));let{spatialReference:l,pointer:u}=a,d=T(w(Y[0],Y[1],n[2]));if(P(r,z(d,l,b,this.view))<this.squaredProximityThreshold(u)){if(this.isVertical(d,t,a)||this.isVertical(s,c,a)||J(e,o))return;o.push(new I({referenceLine:e,lineStart:t,targetPoint:d,isDraped:a.elevationInfo?.mode===`on-the-ground`}))}}};function J(e,t){let n=e.left,r=e.right;for(let a of t)if(k(Y,C(r),C(a.constraint.start),C(a.constraint.end),C(n)),i(Y,C(r))<A.parallelLineThreshold)return a.addReferenceLine(e),!0;return!1}var Y=u(),ne=class extends H{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=[];if(n.vertices.length<2)return r;let{view:i}=this,a=z(e,t.spatialReference,b,i),o=n.vertices.at(-1);N(o.leftSegment)&&this._checkForSnappingCandidate(1,r,o.leftSegment,o,o.leftSegment.leftVertex,e,a,t);let s=n.vertices[0];return N(s.rightSegment)&&this._checkForSnappingCandidate(2,r,s.rightSegment,s,s.rightSegment.rightVertex,e,a,t),r}snapExistingVertex(e,t){let n=[],r=t.vertexHandle;if(r.part.vertices.length<3)return n;let{view:i}=this,a=z(e,t.spatialReference,b,i),o=r.leftSegment,s=r.rightSegment;if(N(o?.leftVertex.leftSegment)){let r=o.leftVertex.leftSegment;this._checkForSnappingCandidate(3,n,r,r.rightVertex,r.leftVertex,e,a,t)}if(N(s)&&N(s.rightVertex.rightSegment)){let r=s.rightVertex.rightSegment;this._checkForSnappingCandidate(3,n,r,r.leftVertex,r.rightVertex,e,a,t)}return n}_checkForSnappingCandidate(e,t,n,r,i,a,o,s){if(!N(n)||!this.edgeExceedsShortLineThreshold(n,s))return;let c=this.view,l=E(r.pos,c,s),u=E(i.pos,c,s);re(Z,u,l,a,s,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,u,l,Z,a,o,s)}_checkForSnappingCandidateAlongProjectedRay(e,t,n,i,a,c,l,u){let{spatialReference:d,pointer:f}=u,p=g(X,C(c),C(i)),h=m(a,p)/o(a),_=s(X,C(i),a,h),v=T(w(_[0],_[1],c[2]));if(P(l,z(v,d,b,this.view))>this.squaredProximityThreshold(f)||this.isVertical(v,i,u)||this.isVertical(i,n,u))return;let x=r(y(),i,a,Math.sign(h));t.push(new R({targetPoint:v,constraint:new te(i,O(x)),previousVertex:n,otherVertex:i,otherVertexType:1,selfSnappingType:e,isDraped:u.elevationInfo?.mode===`on-the-ground`}))}};function re(e,t,n,r,i,a){ie(e,t,n,r,i,a)||ae(e,t,n)}function ie(e,t,n,r,{spatialReference:i},a){let o=B(t,n,i,i);if(o==null)return!1;let s=B(n,r,i,i);if(s==null)return!1;let c=Math.sign(f.shortestSignedDiff(o,s))*Math.PI*.5,l=S(o+c,`radians`,`geographic`),u=y(),d=a.geodesicDistance(n,r,i);return d!=null&&(V(u,n,i,x(d,`meters`),l,`geodesic`),_(e,u,n),!0)}function ae(e,t,n){let r=g(X,C(n),C(t));l(e,r[1],-r[0],0)}var X=u(),Z=y(),oe=class extends H{snapNewVertex(e,t){let n=t.editGeometryOperations.data.parts[0],r=[],i=n.vertices.length;if(t.editGeometryOperations.data.type!==`polygon`||i<2)return r;let{view:a}=this,o=n.vertices[0],s=n.vertices[i-1];if(s.leftSegment&&s.leftSegment.type!==`line`||s.rightSegment&&s.rightSegment.type!==`line`)return r;let c=E(o.pos,a,t),l=E(s.pos,a,t);return this._processCandidateProposal(c,l,e,t,r),r}snapExistingVertex(e,t){let n=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2||t.editGeometryOperations.data.type===`polyline`&&(r.index===0||r.index===i.vertices.length-1)||r.leftSegment?.type!==`line`||r.rightSegment?.type!==`line`)return n;let{view:a}=this,o=E(r.leftSegment.leftVertex.pos,a,t),s=E(r.rightSegment.rightVertex.pos,a,t);return this._processCandidateProposal(o,s,e,t,n),n}_processCandidateProposal(e,t,n,r,i){if(!this.exceedsShortLineThreshold(e,t,r))return;let o=a(Q,C(e),C(t),.5),s=.5*c(C(e),C(t)),l=D(Q,C(n),o,s),u=T(w(l[0],l[1],n[2])),{spatialReference:d,pointer:f}=r,p=z(n,d,b,this.view);if(P(p,z(u,d,b,this.view))<this.squaredProximityThreshold(f)){if(this.isVertical(e,u,r)||this.isVertical(u,t,r))return;i.push(new L({targetPoint:u,point1:e,point2:t,isDraped:r.elevationInfo?.mode===`on-the-ground`}))}}},Q=u(),$=class extends t{constructor(e){super(e),this.updating=!1,this._snappers=new p,this._domain=2}initialize(){this._snappers.push(new q(this.view,this.options),new U(this.view,this.options,this.geodesicLengthMeasurementUtils),new ne(this.view,this.options,this.geodesicLengthMeasurementUtils),new oe(this.view,this.options))}set options(e){this._set(`options`,e);for(let t of this._snappers)t.options=e}async fetchCandidates(e,t,n){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];let r=[];for(let t of this._snappers.items)for(let i of t.snap(e,n))r.push(i);return M(e,r),r}};h([n({readOnly:!0})],$.prototype,`updating`,void 0),h([n({constructOnly:!0})],$.prototype,`view`,void 0),h([n({constructOnly:!0})],$.prototype,`geodesicLengthMeasurementUtils`,void 0),h([n()],$.prototype,`options`,null),$=h([d(`esri.views.interactive.snapping.SelfSnappingEngine`)],$);export{$ as SelfSnappingEngine};