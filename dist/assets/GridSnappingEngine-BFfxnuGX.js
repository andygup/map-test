import{DT as e,Fg as t,Fl as n,Nx as r,OT as i,Tg as a,_w as o,fw as s,gD as c,sa as l,uE as u,uu as d}from"./index-ByaFsVj4.js";import"./quatf64-eO7UAs9K.js";import"./plane-Dmhe_zL4.js";import"./vectorStacks-DhZu7qGn.js";import"./dehydratedPoint-CVzHYxaL.js";import"./elevationInfoUtils-CyQsBf6_.js";import"./ObjectStack-C2IlraSC.js";import"./ray-CUcS4KDu.js";import"./geodesicUtils-Dvm-3luO.js";import{d as f,m as p}from"./LineSnappingHint-3ZzJwo5I.js";import{t as m}from"./snappingUtils-C_5v3bem.js";import"./vec3-DP8KhY5h.js";import"./sphere-BCy4W-Wa.js";import"./constraints-CFQ1UrIW.js";import"./SnappingCandidate-CgOYxD9J.js";import"./IntersectionSnappingHint-DV5I0-bt.js";import{t as h}from"./IntersectionSnappingCandidate-DSIWvb7L.js";import{t as g}from"./LineSnappingCandidate-COvu3vdD.js";import{n as _,r as v,t as y}from"./gridUtils-B4rTEPQ9.js";var b=class extends o{constructor(e){super(e),this.options=null}destroy(){this._set(`options`,null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:s(this.view.rotation??0)}get gridRotation(){return s(this.grid?.rotation??0)}get gridCenter(){let{spatialReference:e,grid:n}=this;if(!n||!e||!a(n.center.spatialReference,e))return null;try{let r=t(n.center,e),i=e.isWrappable&&this.view?.center!=null?d(r.x,this.view.center.x,e):r.x;return p(i,r.y,r.z)}catch(e){return u.getLogger(this).errorOnce(`Grid Snapping - Failed to project grid center.`,e),null}}get offsetScaleFactor(){let{pixelsPerStride:e,grid:t}=this;if(!t||!e)return 1;let{majorLineInterval:n,dynamicScaling:r}=t;return n<1?null:y(n,e,r)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){let{grid:e}=this;return e?r(e.spacing,e.units,`meters`):null}get viewMetersPerPixel(){let{viewMetersPerSRUnit:e}=this;return e==null?null:e*l(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){let{spatialReference:e}=this.view;return this.gridCenter?_(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){let{gridMetersPerStride:e,viewMetersPerPixel:t}=this;return t&&e?e/t:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,t,n){let{options:r,view:i}=this;if(!r?.effectiveGridEnabled||!i.grid||n.feature?.attributes&&m in n.feature.attributes)return[];let a=n.coordinateHelper.arrayToPoint(e),o=r.distance*(n.pointer===`touch`?r.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(a,o)}fetchCandidatesSync(e,n){let r=[],{grid:i,effectiveViewRotation:o,gridRotation:s,gridCenter:c,viewMetersPerPixel:l,viewMetersPerSRUnit:u,offsetScaleFactor:d,spatialReference:f,gridMetersPerStride:m,pixelsPerStride:_}=this;if(!(i&&l&&u&&c&&f&&d&&m&&_)||!i.dynamicScaling&&_<5||!a(e.spatialReference,f))return r;let v=t(e,f),y=p(v.x,v.y,v.z),b=x(y,-s,c,-o),T=m/u*d,E=S(b,T,c),{shouldSnapX:D,shouldSnapY:O}=C(E,b,n,l,u);if(!D&&!O)return[];let k=p((D?E:b)[0],(O?E:b)[1]),A=x(k,s,c,o),j=x(E,s,c,o);if(O){let e=w(E,b,T,`y`),t=x(e,s,c,o);r.push(new g({lineStart:j,lineEnd:t,targetPoint:A,isDraped:!1}))}if(D){let e=w(E,b,T,`x`),t=x(e,s,c,o);r.push(new g({lineStart:j,lineEnd:t,targetPoint:A,isDraped:!1}))}return D&&O&&r.push(new h(A,r[0],r[1],!1)),r}};c([e({constructOnly:!0})],b.prototype,`view`,void 0),c([e()],b.prototype,`options`,void 0),c([e()],b.prototype,`grid`,null),c([e()],b.prototype,`effectiveViewRotation`,null),c([e()],b.prototype,`gridRotation`,null),c([e()],b.prototype,`gridCenter`,null),c([e()],b.prototype,`offsetScaleFactor`,null),c([e()],b.prototype,`spatialReference`,null),c([e()],b.prototype,`gridMetersPerStride`,null),c([e()],b.prototype,`viewMetersPerPixel`,null),c([e()],b.prototype,`viewMetersPerSRUnit`,null),c([e()],b.prototype,`pixelsPerStride`,null),c([e()],b.prototype,`updating`,null),b=c([i(`esri.views.interactive.snapping.GridSnappingEngine`)],b);var x=(e,t,r,i)=>{let a=f(e[0],e[1],e[2]);return n(a,n(a,a,r,t),r,i)},S=(e,t,n)=>{let r=(e[0]-n[0])/t,i=(e[1]-n[1])/t,a=Math.trunc(r),o=Math.trunc(i),s=Math.round(r%1),c=Math.round(i%1),l=n[0]+(a+s)*t,u=n[1]+(o+c)*t;return p(l,u)},C=(e,t,n,r,i)=>{if(r<=0)return{shouldSnapX:!1,shouldSnapY:!1};let a=(e[0]-t[0])/r,o=(e[1]-t[1])/r;return{shouldSnapX:Math.abs(a*i)<n,shouldSnapY:Math.abs(o*i)<n}},w=(e,t,n,r)=>{if(r===`y`){let r=t[0]>e[0]?1:-1;return p(e[0]+n*r,e[1])}let i=t[1]>e[1]?1:-1;return p(e[0],e[1]+n*i)};export{b as GridSnappingEngine};