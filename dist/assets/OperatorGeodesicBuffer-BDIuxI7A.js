import{AD as e,DD as t}from"./index-BN8X5Ryz.js";import{A as n,C as r,Cn as i,I as a,Qt as o,bn as s,cn as c,dn as l,gn as u,in as d,kt as f,ln as p,mn as m,nt as h,pn as g,st as _,wn as v}from"./Point2D-DJueHbCy.js";import{t as y}from"./Envelope2D-B7gkUj4e.js";import{$t as b,B as x,C as S,Cn as C,E as w,En as T,G as E,K as D,Kn as O,Mn as k,Mt as A,N as ee,O as j,P as M,Tt as N,Un as P,Ut as F,Vn as te,Wn as I,Xt as L,Y as ne,a as R,at as z,jn as re,l as ie,lt as ae,m as B,n as oe,nt as se,o as ce,ot as le,r as V,t as H,tn as U,un as W,y as G,yn as K}from"./SpatialReference-CfUjvF_j.js";import{t as q}from"./Transformation2D-D07KwcEj.js";import{n as ue,t as de}from"./SimpleGeometryCursor-BILtMaQf.js";import"./OperatorDefinitions-C5Pat-Jx.js";import{t as fe}from"./GeometryCleaner-BEJM7I4l-oPXfH0kn.js";function pe(e,t,n,r,a,o){r<Number.MAX_VALUE&&r>-Number.MAX_VALUE||d(`Geodesic_bufferer.buffer - bad distance`),m(e);let s=fe(e),l=s.getGeometryType();if(i(l)){let e=s.getPointCount(),i=8e6;if(Math.abs(r)>i&&(e>50||l!==c.enumMultiPoint&&n===4&&e>2)){let e=s,c=r>0?1:-1,l=7e6,u=r,d=1;do d++,u=(Math.abs(u)-l)*c;while(Math.abs(u)>i);u=r;for(let r=0;r<d-1;r++)e=J(e,t,n,l*c,a,d,o),u=(Math.abs(u)-l)*c;return e=J(e,t,n,u,a,d,o),e}}return J(s,t,n,r,a,1,o)}var me=class{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){let t=new K,n=new Se(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,n)}bufferPolyline(e){let t=new Se(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){let t=new Ce(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){let t=e.getXY();t.scale(this.m_rpu);let n=new K;if(this.bufferPoint2D(t,!1,n)){let e=O(null,n,!0);n=S(n,e,!0,!0,-1,this.m_progressTracker,0,!1)}return n=new A().foldInto360RangeGeodetic(n,this.m_gcs,2),n}processGnomonicBufferPiecesCursor(e,t){let n=t,r=n.getGnomonic(),i=E(le()),o=new H,s=new z().executeMany(o,i,this.m_progressTracker,2),c=_(6,!1),l=a(y,6);this.initializeGrid(c,l);let u=[null,null,null,null,null,null],d=[null,null,null,null,null,null],f=[null,null,null,null,null,null],p,m,h;for(;(p=n.next())!==null;){if(m=n.getGnomonic(),m!==r){if(r!==null){let t=s.next();if(o=null,s=null,t!=null){let n=O(i,t,!0),a=k(n);t=r.unproject(t,a,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,c,l,u,d,f)}}m!==null&&(o=new H,s=new z().executeMany(o,i,this.m_progressTracker,2)),r=m}if(n.isRunningInGnomonic()){if(m.project(p),n.needsSimplify()){let e=O(null,p,!0);p=S(p,e,!0,!0,-1,this.m_progressTracker,0,!1)}o.tick($(p)),s.tock()}else this.putInGridCursors(e,p,i,!0,c,l,u,d,f)}let g=!1;for(let e=0;e<6;e++)if(f[e]!=null){g=!0;break}if(g){let t=!1,a=[null,null,null,null,null,null];if(e){let r=n.m_densified;if(n.m_densified=null,r!==null){let n=new q;n.scale(1/this.m_rpu,1/this.m_rpu),r.applyTransformation(n),this.m_distance>0?this.putInGridCursors(e,r,i,!1,c,l,u,d,f):(this.processInGrid(e,r,!1,c,l,u,a),t=!0)}}let p=new H,m=new z().executeMany(p,this.m_gcs,this.m_progressTracker,2);if(s!==null){let t=s.next();o=null,s=null;let n=O(i,t,!0),a=k(n);t=r.unproject(t,a,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,c,l,u,d,f)}for(let e=0;e<6;e++)if(f[e]!=null){let n=f[e].next();f[e]=null,d[e]=null,t&&a[e]!==null&&(n=new B().execute(a[e],n,i,this.m_progressTracker));let r=O(i,n,!0),o=k(r);n=u[e].unproject(n,o,this.m_progressTracker),n=new ce().execute(n,this.m_gcs,!0,this.m_progressTracker),p.tick($(n)),m.tock()}h=m.next()}else{let t,a=!1;if(e){let e=n.m_densified;if(n.m_densified=null,e!==null){let n=new q;n.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(n),m.project(e);let r=O(null,e,!0);e=S(e,r,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(o.tick($(e)),s.tock()):(t=e,a=!0)}}let c=s.next();o=null,s=null,a&&(c=new B().execute(t,c,i,this.m_progressTracker));let l=O(i,c,!0),u=k(l);h=r.unproject(c,u,this.m_progressTracker),h=new ce().execute(h,this.m_gcs,!0,this.m_progressTracker)}return h=new A().foldInto360RangeGeodetic(h,this.m_gcs,2),h}putInGridCursors(e,t,n,r,i,a,o,s,c){let l=[null,null,null,null,null,null];this.processInGrid(e,t,r,i,a,o,l);for(let e=0;e<6;e++)l[e]!==null&&(s[e]===null&&(s[e]=new H,c[e]=new z().executeMany(s[e],n,this.m_progressTracker,2)),s[e].tick($(l[e])),c[e].tock())}processInGrid(e,t,n,r,i,a,o){let s=.01,c=this.insertGeodeticPointsAlongGrid(t,i,s);for(let e=0;e<6;e++){if(r[e])continue;let l=i[e].clone();l.inflateCoords(s,s);let u=T(t,l),d=P(null,u,!1).total(),p=U(c,l,d,NaN,this.m_progressTracker);if(p!==null&&!p.isEmpty()){if(p===c&&(p=p.clone()),a[e]===null){let t=new f;e<3?t.setCoords(0,1):t.setCoords(0,-1);let n=new f;n.setAdd(i[e].getCenter(),t),a[e]=Q(this.m_gcs,n)}a[e].project(p);let t=O(null,p,!0);p=S(p,t,n,!0,-1,this.m_progressTracker,0,!1),o[e]=p}}}insertGeodeticPointsAlongGrid(e,t,n){let r=y.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),i=ae(this.m_gcs,r,e,!0,this.m_progressTracker),a=new C,o=a.addGeometry(i);return N(a,o,this.m_gcs,0,2,!0,t[0].xmax+n),N(a,o,this.m_gcs,0,2,!0,t[1].xmax+n),N(a,o,this.m_gcs,0,2,!1,t[1].ymin+n),n!==0&&(N(a,o,this.m_gcs,0,2,!0,t[0].xmax-n),N(a,o,this.m_gcs,0,2,!0,t[1].xmax-n),N(a,o,this.m_gcs,0,2,!1,t[1].ymin-n)),a.getGeometry(o)}initializeGrid(e,t){for(let t=0;t<6;t++)e[t]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,n,r,i,a){let o=e[0],s=e.at(-1),c=o.y<s.y?o.y:s.y,l=o.y>s.y?o.y:s.y,u=x.q(this.m_a,this.m_eSquared,c),d=x.q(this.m_a,this.m_eSquared,l);if(this.m_q90-(u+t+this.m_absDistance)>.001&&this.m_q90+(d-t-this.m_absDistance)>.001)return!1;let f=n-h,p=r+h,m=f-Math.PI,g=f+Math.PI,_=p+Math.PI,v=[NaN],y=[NaN],b=[NaN],S=[NaN],C=!1;if(he(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,f,m,s,p,v,y),he(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,s,_,p,o,m,b,S),(p<v[0]&&v[0]<_||p<y[0]&&y[0]<_)&&(C=!0),C||(m<b[0]&&b[0]<f||m<S[0]&&S[0]<f)&&(C=!0),!C&&i)return!1;let w=[];for(let t=e.length-1;t>=0;t--)w.push(e[t]);a.setEmpty(),a.addPathPoint2D(null,0,!0);let T=0;T=Y(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,f,p,i,T,a),T=X(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,s,p,_,this.m_cornerStep,i,T,a,v[0],y[0]),T=Y(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,w,_,g,i,T,a),T=X(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,m,f,this.m_cornerStep,i,T,a,b[0],S[0]);let E=!1;return i||(E=this.checkAndPrepForPole(a)),C||E}bufferPoint2D(e,t,n){n.setEmpty(),n.addPathPoint2D(null,0,!0),X(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,0,n);let r=!1;return t||(r=this.checkAndPrepForPole(n)),r}checkAndPrepForPole(e){let t=this.checkAndPrepForPoleTouch(e),n=this.checkAndPrepForPoleWrap(e);return t||n}checkAndPrepForPoleTouch(e){let t=new y;return e.queryEnvelope(t),!(!j(t.ymax,this.m_gcs90)&&!j(t.ymin,-this.m_gcs90))&&(this.prepPoleTouch(e),!0)}checkAndPrepForPoleWrap(e){let t=e.getXY(0),n=e.getXY(e.getPointCount()-1);return Math.abs(t.x-n.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){let t=new K;t.insertPath2D(-1,null,0,0,!0);let n=e.getPathStart(0),r=e.getPathEnd(0),i=r-n,a=-1;for(a=n;a<r;a++){let t=e.getXY(a),n=j(t.y,this.m_gcs90),r=j(t.y,-this.m_gcs90);if(!n&&!r)break}let o=a,s=!1,c=NaN;do{let r=e.getXY(o),a=j(r.y,this.m_gcs90),l=j(r.y,-this.m_gcs90),u=n+(o+1-n)%i;if(a||l){let n=f.construct(c,r.y);t.insertPoint2D(0,-1,n);let i=e.getXY(u),a=j(i.y,this.m_gcs90),o=j(i.y,-this.m_gcs90);a||o||(n=f.construct(i.x,r.y),s?t.setXY(t.getPointCount()-1,n):t.insertPoint2D(0,-1,n)),s=!0}else t.insertPoint2D(0,-1,r),c=r.x,s=!1;o=u}while(o!==a);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){let t=new K,n=new K,r=new q,i=e.getXY(e.getPathStart(0)),a=e.getXY(e.getPathEnd(0)-1),o=this.m_gcs360,s=this.m_gcs180,c=new y;c.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});let l=new y;e.queryEnvelope(l);let u=Math.ceil(l.width()/o),d,p;i.x>a.x?(d=-o,p=this.m_gcs90):(d=o,p=-this.m_gcs90),r.setShiftCoords(d,0),t.addPath(e,0,!0),n.add(t,!1);let m=new I;for(let e=0;e<u;e++)n.applyTransformation(r),n.getPointByVal(0,m),t.lineToPoint(m),t.addSegmentsFromPath(n,0,0,n.getSegmentCount()-1,!1);let h=t.getXY(0),g=t.getXY(t.getPointCount()-1);h.y=p,g.y=p,t.lineTo(g);let _=new f;for(_.setCoordsPoint2D(g),_.x-=.5*d;Math.abs(_.x-h.x)>s;)t.lineTo(_),_.x-=.5*d;t.lineTo(h);let v=c.getCenterX(),b=new y;t.queryEnvelope(b);let x=0,S=b.getCenter().x;S-v>s?x=-Math.ceil((S-v-s)/o):v-S>s&&(x=Math.ceil((v-S-s)/o)),x!==0&&(r.setShiftCoords(x*o,0),t.applyTransformation(r));let w=new C,E=w.addGeometry(t);N(w,E,this.m_gcs,0,2,!0,c.xmin),N(w,E,this.m_gcs,0,2,!0,c.xmax);let D=w.getGeometry(E),O=T(D,c);O.inflateCoords(0,1);let k=P(null,O,!0).total(),A=U(D,c,k,NaN,this.m_progressTracker);e.setEmpty(),e.add(A,!1)}prepDoublePoleWrap(e){let t=this.m_gcs360,n=this.m_gcs180,r=new y;r.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});let i=r.getCenter().x,a=new y;e.queryPathEnvelope(0,a);let o,s=0,c=a.getCenter().x;if(c-i>n?s=-Math.ceil((c-i-n)/t):i-c>n&&(s=Math.ceil((i-c-n)/t)),s!==0){let n=new q;n.setShiftCoords(s*t,0),e.getImpl().applyTransformationToPath(n,0),e.queryPathEnvelope(0,a),c=a.getCenter().x}let l=new y;r.containsExclusiveEnvelope(a)?(o=!1,l.setCoords({env2D:r})):(o=!0,l.setCoords({env2D:r}),l.xmin-=t,l.xmax+=t);let u=e.createInstance();u.addPathPoint2D(null,0,!0);let d=new f;if(d.setCoords(l.xmin,l.ymin),u.insertPoint2D(0,-1,d),d.setCoords(l.xmin,l.ymax),u.insertPoint2D(0,-1,d),d.setCoords(.5*(l.xmin+l.xmax),l.ymax),u.insertPoint2D(0,-1,d),d.setCoords(l.xmax,l.ymax),u.insertPoint2D(0,-1,d),d.setCoords(l.xmax,l.ymin),u.insertPoint2D(0,-1,d),d.setCoords(.5*(l.xmin+l.xmax),l.ymin),u.insertPoint2D(0,-1,d),o){u.addPath(e,0,!0);let n=new q;c<i?n.setShiftCoords(t,0):n.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(n,0),u.addPath(e,0,!0);let a=new C,o=a.addGeometry(u);N(a,o,this.m_gcs,0,2,!0,r.xmin),N(a,o,this.m_gcs,0,2,!0,r.xmax),u=a.getGeometry(o);let s=T(u,r);s.inflateCoords(0,1);let l=P(null,s,!0).total();u=U(u,r,l,NaN,this.m_progressTracker)}else u.addPath(e,0,!0);e.setEmpty(),e.add(u,!1)}setMinCornerStep(){let n={stack:[],error:void 0,hasError:!1};try{let i=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);i=Math.min(i,.125*this.m_a*Math.PI);let a=new f;a.setCoords(0,10*this.m_rpu);let o=45*this.m_rpu,s=t(n,new r(new V,new V),!1),c=t(n,new r(new V,new V),!1),l=t(n,new r(new V,new V),!1),u=t(n,new r(new V,new V),!1),d=new f,p=new f,m=new f,h=new f;for(R.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,i,0,s.at(0),s.at(1)),d.setCoords(s.at(0).val,s.at(1).val),R.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,i,o,c.at(0),c.at(1)),p.setCoords(c.at(0).val,c.at(1).val);;){let n={stack:[],error:void 0,hasError:!1};try{let e=.5*(0+o);R.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,i,e,l.at(0),l.at(1)),m.setCoords(l.at(0).val,l.at(1).val);let r=t(n,new V,!1),s=t(n,new V,!1);R.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,p.x,p.y,r,s,null,2),R.geodeticCoordinate(this.m_a,this.m_eSquared,d.x,d.y,.5*r.val,s.val,u.at(0),u.at(1),2),h.setCoords(u.at(0).val,u.at(1).val);let f=t(n,new V,!1);if(R.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,h.x,h.y,f,null,null,2),f.val<=this.m_convergenceOffset)break;o*=.9,R.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,i,o,c.at(0),c.at(1)),p.setCoords(c.at(0).val,c.at(1).val)}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}let g=o-0;this.m_cornerStep=2*Math.PI/Math.ceil(2*Math.PI/g)}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}setMinSegmentStep(){let n={stack:[],error:void 0,hasError:!1};try{let i=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);i=Math.min(i,.125*this.m_a*Math.PI);let a=new f,o=new f;a.setCoords(0,10*this.m_rpu),o.setCoords(10*this.m_rpu,10*this.m_rpu);let s=t(n,new V,!1),c=t(n,new V,!1),l=t(n,new V,!1);R.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,o.x,o.y,l,s,c,this.m_curveType);let u=t(n,new r(new V,new V),!1),d=t(n,new r(new V,new V),!1),p=new f,m=t(n,new V,!1),h=t(n,new r(new V,new V),!1),g=t(n,new r(new V,new V),!1),_=t(n,new r(new V,new V),!1),v=t(n,new r(new V,new V),!1),y=new f,b=new f,x=new f,S=new f,C=1,w=s.val,T=c.val,E=w-.5*Math.PI,D=T+.5*Math.PI,O=l.val;for(R.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,i,E,h.at(0),h.at(1)),y.setCoords(h.at(0).val,h.at(1).val),R.geodesicCoordinate(this.m_a,this.m_eSquared,o.x,o.y,i,D,g.at(0),g.at(1)),b.setCoords(g.at(0).val,g.at(1).val);;){let n={stack:[],error:void 0,hasError:!1};try{let r=.5*(0+C);R.geodeticCoordinate(this.m_a,this.m_eSquared,a.x,a.y,r*O,w,u.at(0),u.at(1),this.m_curveType),p.setCoords(u.at(0).val,u.at(1).val),R.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,p.x,p.y,null,null,m,this.m_curveType);let s=m.val+.5*Math.PI;R.geodesicCoordinate(this.m_a,this.m_eSquared,p.x,p.y,i,s,_.at(0),_.at(1)),x.setCoords(_.at(0).val,_.at(1).val);let c=t(n,new V,!1),l=t(n,new V,!1);R.geodeticDistance(this.m_a,this.m_eSquared,y.x,y.y,b.x,b.y,c,l,null,2),R.geodeticCoordinate(this.m_a,this.m_eSquared,y.x,y.y,.5*c.val,l.val,v.at(0),v.at(1),2),S.setCoords(v.at(0).val,v.at(1).val);let f=t(n,new V,!1);if(R.geodeticDistance(this.m_a,this.m_eSquared,x.x,x.y,S.x,S.y,f,null,null,2),f.val<=this.m_convergenceOffset)break;{let n={stack:[],error:void 0,hasError:!1};try{C*=.9,R.geodeticCoordinate(this.m_a,this.m_eSquared,a.x,a.y,C*O,w,d.at(0),d.at(1),this.m_curveType),o.setCoords(d.at(0).val,d.at(1).val);let e=t(n,new V,!1);R.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,o.x,o.y,null,null,e,this.m_curveType);let r=e.val+.5*Math.PI;R.geodesicCoordinate(this.m_a,this.m_eSquared,o.x,o.y,i,r,g.at(0),g.at(1)),b.setCoords(g.at(0).val,g.at(1).val)}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}let k=C*O;k>1e5&&(k=1e5),this.m_segmentStep=k}catch(e){n.error=e,n.hasError=!0}finally{e(n)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}};function J(e,t,n,r,i,a,d){if(e.isEmpty())return new K({vd:e.getDescription()});let f=e;if(o(f)){let e=10*t.getTolerance(0);f=new b().execute(f,0,e,0,d,12e3)}let p=new me(d);p.m_sr=t,p.m_gcs=t.getGCS(),p.m_transform=ee(t,p.m_gcs,null);let m=ie();p.m_gcs.querySpheroidData(m);let h=new y;f.queryEnvelope(h),p.m_a=m.majorSemiAxis,p.m_eSquared=m.e2,p.m_rpu=p.m_gcs.getUnit().getUnitToBaseFactor(),p.m_gcs90=.5*Math.PI/p.m_rpu,p.m_gcs180=Math.PI/p.m_rpu,p.m_gcs360=2*Math.PI/p.m_rpu,p.m_gcs60=p.m_gcs360/6,p.m_q90=x.q90(p.m_a,p.m_eSquared),p.m_ellipticToGeodesicMaxRatio=.5*p.m_a*Math.PI/p.m_q90,p.m_radTolerance=p.m_gcs.getTolerance(0)*p.m_rpu,n===4?(p.m_curveType=2,p.m_bShapePreserving=!0):(p.m_curveType=n,p.m_bShapePreserving=!1),p.m_distance=r,p.m_absDistance=Math.abs(r),Number.isNaN(i)||i<=0?p.setConvergenceOffset():p.m_convergenceOffset=Math.max(i,.001),p.m_convergenceOffset/=a;let _,v=f.getGeometryType();if(l(v)){let e=new W({vd:f.getDescription()});e.addSegment(f,!0),_=e,v=c.enumPolyline}else if(v===c.enumEnvelope){let e=f,t=new y;e.queryEnvelope(t);let n=k(P(p.m_sr,h,!0));if(t.minDimension()<=n)if(t.maxDimension()===0){let t=new I({vd:f.getDescription()});e.getCenter(t),_=t,v=c.enumPoint}else{let t=new W({vd:f.getDescription()});t.addEnvelope(e,!1),_=t,v=c.enumPolyline}else{let t=new K({vd:f.getDescription()});t.addEnvelope(e,!1),_=t,v=c.enumPolygon}}else _=f;if(p.setMinCornerStep(),u(v)||p.setMinSegmentStep(),p.m_absDistance<=.5*p.m_convergenceOffset)return v===c.enumPolygon?p.m_bShapePreserving?_:w(_,p.m_sr,p.m_curveType,p.m_segmentStep,-1,d):new K({vd:_.getDescription()});if(p.m_distance<0&&v!==c.enumPolygon)return new K({vd:_.getDescription()});if(p.m_bShapePreserving&&g(v)){let e=w(_,t,4,NaN,p.m_convergenceOffset,d);_=new A().execute(e,p.m_transform,d)}else _=new A().execute(_,p.m_transform,d);if(_=oe(_,p.m_gcs),_.isEmpty())return new K({vd:_.getDescription()});!p.m_bShapePreserving&&g(v)&&(_=ne(p.m_rpu,_)),_=_e(_,p.m_gcs);let S=new K;switch(v){case c.enumPolygon:S=p.bufferPolygon(_);break;case c.enumPolyline:S=p.bufferPolyline(_);break;case c.enumMultiPoint:S=p.bufferMultiPoint(_);break;case c.enumPoint:S=p.bufferPoint(_);break;default:s(``)}let C=new A().execute(S,p.m_transform.getInverse(),d);return C.mergeVertexDescription(_.getDescription()),C}function Y(n,i,a,o,s,c,l,u,d,p,m){let h={stack:[],error:void 0,hasError:!1};try{let e=new f;e.setNAN(),d||m.getPointCount()>0&&(e.setCoordsPoint2D(m.getXY(m.getPointCount()-1)),e.scale(a));let g=t(h,new V,!1),_=t(h,new r(new V,new V),!1),v=new f,y=new f,b=c.at(-1),x=1/a;for(let t=0;t<c.length;t++){let r=c[t],a;t===0?a=l:t===c.length-1?a=u:(R.geodeticDistance(n,i,b.x,b.y,r.x,r.y,null,null,g,s),a=g.val-.5*Math.PI),R.geodesicCoordinate(n,i,r.x,r.y,o,a,_.at(0),_.at(1)),d?y.setCoords(_.at(0).val,_.at(1).val):(v.setCoords(_.at(0).val,_.at(1).val),p=ge(r.x,v.x,e.x,p),y.setCoords(p+v.x,v.y),e.setCoordsPoint2D(y)),y.scale(x),m.insertPoint2D(0,-1,y)}return p}catch(e){h.error=e,h.hasError=!0}finally{e(h)}}function X(n,i,a,o,s,c,l,u,d,p,m,h=NaN,g=NaN){let _={stack:[],error:void 0,hasError:!1};try{if(l-c<u)return p;let e=t(_,new r(new V,new V),!1),v=new f,y=new f,b=new f;y.setNAN(),d||m.getPointCount()>0&&(y.setCoordsPoint2D(m.getXY(m.getPointCount()-1)),y.scale(a));let x=Math.ceil(c/u),S=x++*u;S===c&&(S=x++*u);let C=c,w=1/a;for(;S<l+u&&(C<h&&h<S?(S=h,x--):C<g&&g<S&&(S=g,x--),!(S>=l));)R.geodesicCoordinate(n,i,s.x,s.y,o,S,e.at(0),e.at(1)),d?b.setCoords(e.at(0).val,e.at(1).val):(v.setCoords(e.at(0).val,e.at(1).val),p=ge(s.x,v.x,y.x,p),b.setCoords(p+v.x,v.y),y.setCoordsPoint2D(b)),b.scale(w),m.insertPoint2D(0,-1,b),C=S,S=x++*u;return p}catch(e){_.error=e,_.hasError=!0}finally{e(_)}}function he(i,a,o,s,c,l,u,d,p,m,h){let g={stack:[],error:void 0,hasError:!1};try{let e=new f,o=new f,_=t(g,new r(new V,new V),!1);R.geodesicCoordinate(i,a,c.x,c.y,s,l,_.at(0),_.at(1)),e.setCoords(_.at(0).val,_.at(1).val),R.geodesicCoordinate(i,a,c.x,c.y,s,u,_.at(0),_.at(1)),o.setCoords(_.at(0).val,_.at(1).val);let v=t(g,new V,!1);for(R.geodeticDistance(i,a,d.x,d.y,e.x,e.y,null,v,null,0),m[0]=v.val,R.geodeticDistance(i,a,d.x,d.y,o.x,o.y,null,v,null,0),h[0]=v.val;m[0]<=h[0];)m[0]+=n;for(;m[0]>h[0];)m[0]-=n;for(;m[0]>=p;)m[0]-=n,h[0]-=n;for(;m[0]<p;)m[0]+=n,h[0]+=n}catch(e){g.error=e,g.hasError=!0}finally{e(g)}}function ge(e,t,r,i){if(Number.isNaN(r)){for(;i+t-e>Math.PI;)i-=n;for(;e-(i+t)>Math.PI;)i+=n;return i}return i+t-r>Math.PI?i-=n:r-(i+t)>Math.PI&&(i+=n),i}function _e(e,t){let n=e.getGeometryType(),r;if(r=g(n)?e.getPathCount():n===c.enumMultiPoint?e.getPointCount():1,r===1)return e;let i=[],a=[];for(let o=0;o<r;o++){i.push(o);let r=new f;if(g(n)){let t=new y;e.queryPathEnvelope(o,t),r.assign(t.getCenter())}else r.assign(e.getXY(o));let s=t.toGeohash(r);a.push(s)}i.sort((e,t)=>a[e]<a[t]?-1:a[e]>a[t]?1:0);let o=e.createInstance();for(let t=0;t<r;t++){let r=i[t];g(n)?o.addPath(e,r,!0):o.addPoints(e,r,r+1)}return o}function ve(n,r,i,a,o,s){let c={stack:[],error:void 0,hasError:!1};try{if(a>=s)return!1;let e=i[0],l=i.at(-1),u=t(c,new V,!1),d=t(c,new V,!1),f=t(c,new V,!1);R.greatEllipticDistance(n,r,o.x,o.y,e.x,e.y,u,null,null),R.greatEllipticDistance(n,r,o.x,o.y,l.x,l.y,d,null,null),R.greatEllipticDistance(n,r,e.x,e.y,l.x,l.y,f,null,null);let p=Math.min(u.val,d.val)+f.val,m=p+a;if(m<s)return!0;let h=t(c,new V,!1);p=Math.max(u.val,d.val);for(let e=1;e<i.length-1;e++){let t=i[e];R.greatEllipticDistance(n,r,o.x,o.y,t.x,t.y,h,null,null),h.val>p&&(p=h.val)}return m=p+a,m<s}catch(e){c.error=e,c.hasError=!0}finally{e(c)}}function Z(e,t,n,r,i,a,o,s){let c;if(r.length%2==0){let e=r.length>>1,t=r[e],n=r[e-1];c=f.lerp(t,n,.5)}else c=r[r.length-1>>1].clone();let l=c.clone(),u=F(e,t,l,75/180*Math.PI);return!!ve(e,t,r,i,l,u)&&(a!==null&&(a.setCoordsPoint2D(c),a.scale(1/n)),o!==null&&o.setCoordsPoint2D(l),s!==null&&(s[0]=u),!0)}function ye(n,r,i,a,o,s){let c={stack:[],error:void 0,hasError:!1};try{if(a>=s)return!1;let e=t(c,new V,!1);return R.greatEllipticDistance(n,r,o.x,o.y,i.x,i.y,e,null,null),e.val+a<s}catch(e){c.error=e,c.hasError=!0}finally{e(c)}}function be(e,t,n,r,i,a,o,s){let c=F(e,t,r,75/180*Math.PI);return!!ye(e,t,r,i,r,c)&&(a!==null&&(a.setCoordsPoint2D(r),a.scale(1/n)),o!==null&&o.setCoordsPoint2D(r),s!==null&&(s[0]=c),!0)}function Q(e,t){return new se(e,t)}function $(e){return te(e,0)||re(e,0),e}var xe=class{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new f,this.m_minGnomonicRadius=NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}},Se=class extends xe{constructor(e,t,n){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new K,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=n,this.m_bNeedsSimplify=!0;let r=new y;this.m_multiPath.queryEnvelope(r);let i=r.getCenter(),a=i.clone();a.scale(this.m_bufferer.m_rpu),this.m_gnomonic=Q(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=a.clone(),this.m_minGnomonicRadius=F(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,a,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(this.m_segIter===null){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;this.m_densified!==null&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;this.m_densified!=null&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let n=0,r=new f,i=new f;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){let e=this.m_segIter.nextSegment();if(r.setCoordsPoint2D(e.getStartXY()),i.setCoordsPoint2D(e.getEndXY()),r.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),G(r,i))r.x=i.x;else if(L(r,i))i.x=r.x;else{let e=-1,t=-1,n=this.m_segIter.getPathIndex(),a=this.m_multiPath.getPathStart(n),o=this.m_multiPath.getPathEnd(n);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<a&&(e=this.m_multiPath.isClosedPath(n)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(n)?a:-1),e!==-1){let t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),L(t,r)&&(r.x=t.x)}if(t!==-1){let e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),G(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0;let a=M(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,i,this.m_bufferer.m_segmentStep,NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(n===0)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||=this.tryUpdateGnomonic(this.m_densifiedPoints);else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(a===0||D(r,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(r,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(a,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),t===null&&(t=new K,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),n++}if(this.m_currentDensifiedDelta=[0],n>0){let e=this.m_segIter.getStartPointIndex(),a=this.m_segIter.getPathIndex();for(;n>0;){if(this.m_segIter.previousSegment(),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),r.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(G(r,i))r.x=i.x;else if(L(r,i))i.x=r.x;else{let e=-1,t=-1,n=this.m_segIter.getPathIndex(),a=this.m_multiPath.getPathStart(n),o=this.m_multiPath.getPathEnd(n);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<a&&(e=this.m_multiPath.isClosedPath(n)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(n)?a:-1),e!==-1){let t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),L(t,r)&&(r.x=t.x)}if(t!==-1){let e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),G(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0,M(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,r,this.m_bufferer.m_segmentStep,NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),n--}return r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=X(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,r,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,a),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return this.m_gnomonic!==null&&ve(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){let t=new f,n=new f,r=[0];return Z(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,n,r)?(this.m_gnomonicCenterRad.setCoordsPoint2D(n),this.m_minGnomonicRadius=r[0],this.m_gnomonic=Q(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){let t=this.m_densifiedPoints[0],r=NaN,i=this.m_startAzimuth[0]-h,a=this.m_endAzimuth[0]+h,o=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(r=this.m_lastAzimuth+h,i=r+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(r=this.m_lastAzimuth+h,i=r+Math.PI-(n-(this.m_startAzimuth[0]-this.m_lastAzimuth))),o=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let a=!1;if(Math.abs(i-r)<=.5*this.m_bufferer.m_cornerStep&&(o||(a=!0)),a){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){let t=new f;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=n:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=n)}i=.5*(i+r)}else if(o){let n=new f;n.setCoordsPoint2D(t),n.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,n)}else X(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],r,i,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,Y(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,i,a,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}},Ce=class extends xe{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;let n=new y;this.m_multiPoint.queryEnvelope(n);let r=n.getCenter(),i=r.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=Q(this.m_bufferer.m_gcs,r),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=F(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;let e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||=this.tryUpdateGnomonic(e);let t=new K;return this.m_bNeedsSimplify=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t),t}isPointBufferInCurrentGnomonic(e){return this.m_gnomonic!==null&&ye(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){let t=new f,n=new f,r=[0];return be(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,n,r)?(this.m_gnomonicCenterRad.setCoordsPoint2D(n),this.m_minGnomonicRadius=r[0],this.m_gnomonic=Q(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}},we=class{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,n,r,i,a,o,s){if(o){let o=new Te(e,t,n,r,i,!1,a,s);return new z().executeMany(o,t,s)}return new Te(e,t,n,r,i,!1,a,s)}execute(e,t,n,r,i,a,o){let s=new de([e]),c=[r],l=this.executeMany(s,t,n,c,i,!1,a,o).next();return l||p(`geodesic buffer null output`),l}},Te=class extends ue{constructor(e,t,n,r,i,a,o,s){super(),this.m_currentUnionEnvelope2D=new y,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=s,a&&v(``),t||d(``),t.getCoordinateSystemType()===0&&d(``),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=n,this.m_distances=r,this.m_convergenceOffset=i,this.m_bOutlineOnly=a,this.m_bUnion=o}next(){let e;for(;e=this.m_inputGeoms.next();)return m(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return pe(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}};export{we as OperatorGeodesicBuffer};